<hr/>
<h3 id="creating-a-project-with-cargo">Creating a Project with
<code>Cargo</code></h3>
<ol type="1">
<li>To create a new project:</li>
</ol>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new <span class="op">&lt;</span>projname<span class="op">&gt;</span></span></code></pre></div>
<ol start="2" type="1">
<li><p>It will create a new dir based on the
<strong><code>&lt;projname&gt;</code></strong>,<br />
and inside it you will have a <strong><code>Cargo.toml</code></strong>
file and a <strong><code>src/</code></strong> directory with
<strong><code>main.rs</code></strong> file inside.</p></li>
<li><p>It also initialized a new Git repo along with a
<strong><code>.gitignore</code></strong> file.<br />
Git files won‚Äôt be generated if you run
<strong><code>cargo new</code></strong> within an exisiting Git
repo.<br />
You can override this behavior by using
<strong><code>cargo new --vcs={ none | git | hg | pijul | fossil }</code></strong>.</p></li>
<li><p>Cargo expects your source files to live inside the
<strong><code>src/</code></strong> directory.<br />
The top-level project directory is just for README files, license
information, configuration files, and anything else not related to your
code.</p></li>
</ol>
<hr/>
<h3 id="building-and-running-a-cargo-project">Building and Running a
Cargo Project</h3>
<ol type="1">
<li>To build your project inside the directory:</li>
</ol>
<div class="sourceCode" id="cb2"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo build</span></code></pre></div>
<ul>
<li>This wil create an executable in
<strong><code>./target/debug/</code></strong> dir rather than your curr
dir,<br />
and why it‚Äôs inside a debug dir it‚Äôs because the default build is a
debug build.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li>Running <strong><code>cargo build</code></strong> for the first time
also causes <strong><code>Cargo</code></strong> to create a new file at
the top level, which is <strong><code>Cargo.lock</code></strong>.<br />
This file keeps track of the exact versions of dependencies in your
project.<br />
You will NOT ever need to change this file manually,
<strong><code>Cargo</code></strong> manages it for you.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>We can also <strong><em>compile + run</em></strong> the code in one
command:</li>
</ol>
<div class="sourceCode" id="cb3"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo run</span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>Cargo also provides a command called
<strong><code>cargo check</code></strong>.<br />
This command quickly checks your code to make sure it compiles but does
<code>NOT</code> produce an executable.<br />
And this command is much faster than
<strong><code>cargo build</code></strong>.</li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo check</span></code></pre></div>
<hr/>
<h3 id="building-for-release">Building for Release</h3>
<ol type="1">
<li><p>When your project is finally ready for release, you can use
<strong><code>cargo build --release</code></strong> to compile it with
optimizations.</p></li>
<li><p>This command will create an executable in
<strong><code>target/release/</code></strong>.</p></li>
</ol>
<hr/>
<h3 id="updating-a-crate-to-get-a-new-version">Updating a Crate to Get a
New Version</h3>
<ol type="1">
<li><p>When you do want to update a <strong><code>crate</code></strong>,
Cargo provides the command
<strong><code>cargo update</code></strong>,<br />
which will ignore the <strong><code>Cargo.lock</code></strong> file and
figure out all the latest versions that fit your configurations in
<strong><code>Cargo.toml</code></strong>.<br />
And Cargo will then write those versions to the
<strong><code>Cargo.lock</code></strong> file.</p></li>
<li><p>Like if you wrote <strong><code>rand="0.8.5"</code></strong> even
when updating cargo will only look for versions of <code>rand</code>
crate greater than or equal to <code>0.8.5</code> and lower than
<code>0.9.0</code>.<br />
If you wrote <strong><code>rand="0.9.0"</code></strong> then it would
also notice the change in <code>0.9.x</code> series.</p></li>
</ol>
<hr/>
<h3 id="cargo-documentations">Cargo Documentations</h3>
<ol type="1">
<li><strong><code>cargo doc --open</code></strong> will build
documentation provided by all your dependencies locally and open it in
your browser.</li>
</ol>
<hr/>
<h3 id="let">let</h3>
<ol type="1">
<li><strong><code>let</code></strong> defines a constant local
variable.</li>
</ol>
<hr/>
<h3 id="let-mut">let mut</h3>
<ol type="1">
<li><strong><code>let mut</code></strong> defines a mutable local
variable.</li>
</ol>
<hr/>
<h3 id="const">const</h3>
<ol type="1">
<li><strong><code>const</code></strong> <code>MUST</code> be used with
type annotation, and defines a global-scoped const variable.</li>
</ol>
<hr/>
<h3 id="shadowing">Shadowing</h3>
<ol type="1">
<li>Example <code>1</code>:</li>
</ol>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> x <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;The value of x in the inner scope is: {x}&quot;</span>)<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value of x is: {0}&quot;</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co">        The value of x in the inner scope is: 12</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co">        The value of x is: 6</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Example <code>2</code>:</li>
</ol>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaces <span class="op">=</span> <span class="st">&quot;   &quot;</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> spaces <span class="op">=</span> spaces<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* This is not possible, but above possible.</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">     * An advantage of shadowing.</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        let mut spaces = &quot;   &quot;;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        spaces = spaces.len();</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span></code></pre></div>
<ul>
<li>The only difference between shadowing and <code>mut</code> is that
it allows you to change variable types.</li>
</ul>
<hr/>
<h3 id="data-types">Data Types</h3>
<ol type="1">
<li><p>Keep in mind that Rust is a
<strong><code>statically typed</code></strong> language,<br />
which means that it must know the types of all variables at compile
time.</p></li>
<li><p>The compiler can usually infer what type we want to use based on
the value and how we use it.<br />
In cases when many types are possible, such as when we converted a
<strong><code>String</code></strong> to a numeric type using
<strong><code>parse()</code></strong> method,<br />
we have to add a <code>type annotation</code>.</p></li>
</ol>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If we did NOT annote `:u32` it will raise a compile error!</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> guess<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> <span class="st">&quot;42&quot;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>parse()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>expect(<span class="st">&quot;NaN!&quot;</span>)<span class="op">;</span></span></code></pre></div>
<hr/>
<h3 id="scalar-types">Scalar Types</h3>
<ol type="1">
<li>A scalar type represents a single value.<br />
Rust has four primary scalar types:
<ol type="a">
<li><code>integer</code></li>
<li><code>floating point</code></li>
<li><code>boolean</code></li>
<li><code>character</code></li>
</ol></li>
</ol>
<hr/>
<h3 id="integer-types">Integer Types</h3>
<ol type="1">
<li><p>8-bit <strong><code>i8</code></strong>,
<strong><code>u8</code></strong></p></li>
<li><p>16-bit <strong><code>i16</code></strong>,
<strong><code>u16</code></strong></p></li>
<li><p>32-bit <strong><code>i32</code></strong>,
<strong><code>u32</code></strong></p></li>
<li><p>64-bit <strong><code>i64</code></strong>,
<strong><code>u64</code></strong></p></li>
<li><p>128-bit <strong><code>i128</code></strong>,
<strong><code>u128</code></strong></p></li>
<li><p>arch, <strong><code>size</code></strong>,
<strong><code>usize</code></strong>, depends on the architecture of the
machine you‚Äôre running on,<br />
e.g.¬†it would be <code>64-bit</code> if you‚Äôre running on a
<code>64-bit architecture</code>.</p></li>
</ol>
<hr/>
<h3 id="integer-literals">Integer literals</h3>
<ol type="1">
<li><p>Decimal<br />
e.g.¬†<code>1_000</code></p></li>
<li><p>Hex<br />
e.g.¬†<code>0xff</code>, <code>0xFF</code>, <code>0Xff</code>,
<code>0XFF</code></p></li>
<li><p>Octal<br />
e.g.¬†<code>0o77</code>, <code>0O77</code></p></li>
<li><p>Binary<br />
e.g.¬†<code>0b1111_0000</code>, <code>0B1111_0000</code></p></li>
<li><p>Byte (<code>u8</code> only)<br />
e.g.¬†<code>b'A'</code></p></li>
<li><p>You can also use a suffix to designate the type,<br />
e.g.¬†<code>57u8</code>, <code>57U8</code></p></li>
<li><p>Integer types are default to
<strong><code>i32</code></strong>.</p></li>
</ol>
<hr/>
<h3 id="inetger-overflow">Inetger Overflow</h3>
<ol type="1">
<li><p>Let‚Äôs say you have a variable of type
<strong><code>u8</code></strong> that can hold values between
<strong><code>0</code></strong> and
<strong><code>255</code></strong>.<br />
If you try to change the variable to a value outside that range, such as
<strong><code>256</code></strong>,<br />
integer overflow will occur, which can result in one of two
behaviors.</p>
<p>When you‚Äôre compiling in <strong><code>debug</code></strong>
mode,<br />
Rust includes checks for integer overflow that cause your program to
panic at runtime if this behavior occurs.<br />
Rust uses the term panicking when a program exits with an
error.</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>When you‚Äôre compiling in <strong><code>release</code></strong>
mode with the <strong><code>--release</code></strong> flag,<br />
Rust does <code>NOT</code> include checks for integer overflow that
cause panics.</p>
<p>Instead, if overflow occurs, Rust performs
<code>two's complement wrapping</code>.<br />
In short, values greater than the maximum value the type can hold ‚Äúwrap
around‚Äù to the minimum of the values the type can hold.</p>
<p>In the case of a <strong><code>u8</code></strong>, the value
<strong><code>256</code></strong> becomes
<strong><code>0</code></strong>, the value
<strong><code>257</code></strong> becomes
<strong><code>1</code></strong>, and so on.</p></li>
</ol>
<hr/>
<h3 id="floating-point-types">Floating-Point Types</h3>
<ol type="1">
<li>Rust also has two primitive types for floating-point numbers
<strong><code>f32</code></strong> and
<strong><code>f64</code></strong>.<br />
Which are <code>32</code>-bit and <code>64</code>-bit in size,
respectively.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The default type is <strong><code>f64</code></strong> because on
modern CPUs,<br />
it‚Äôs roughly the same speed as <strong><code>f32</code></strong> but is
capable of more precision.</li>
</ol>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">2.0</span><span class="op">;</span>        <span class="co">// :f64</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">3.0</span><span class="op">;</span>   <span class="co">// :f32</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>All floating-point types are <code>signed</code>.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Rust also supports the basic mathematical operations you‚Äôd expect
for all the number types.</li>
</ol>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> sum <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> diff <span class="op">=</span> <span class="dv">95.3</span> <span class="op">-</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> production <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> quotient  <span class="op">=</span> <span class="dv">55.7</span> <span class="op">/</span> <span class="dv">11.2</span><span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> truncated <span class="op">=</span> <span class="op">-</span><span class="dv">5</span>   <span class="op">/</span> <span class="dv">3</span><span class="op">;</span>        <span class="co">// -&gt; -1</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> remainder <span class="op">=</span> <span class="dv">43</span> <span class="op">%</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="the-boolean-type">The Boolean Type</h3>
<ol type="1">
<li>A <strong><code>bool</code></strong> type has only two possible
values: <strong><code>true</code></strong> and
<strong><code>false</code></strong>.</li>
</ol>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> b1 <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> b2<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="the-character-type">The Character Type</h3>
<ol type="1">
<li>The <strong><code>char</code></strong> type is the language‚Äôs most
primitive alphabetic type.</li>
</ol>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> c1 <span class="op">=</span> <span class="ch">&#39;z&#39;</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> c2<span class="op">:</span> <span class="dt">char</span> <span class="op">=</span> <span class="ch">&#39;Z&#39;</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> heart_eyed_cat <span class="op">=</span> <span class="ch">&#39;üòª&#39;</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ol start="2" type="1">
<li>However, a <strong><code>char</code></strong> is still yet far from
an Unicode type.<br />
Tho like ASCII, accented letters, Chinese, Japanese, Korean characters
and some emojis are valid.</li>
</ol>
<hr/>
<h3 id="compound-types">Compound Types</h3>
<ol type="1">
<li>Compound types can group multiple values into one type.<br />
Rust has two primitive compound types:
<strong><code>tuple</code></strong> and
<strong><code>array</code></strong>.</li>
</ol>
<hr/>
<h3 id="the-tuple-type">The Tuple Type</h3>
<ol type="1">
<li>A <strong><code>tuple</code></strong> is a general way of grouping
together a number of values,<br />
with a variety of types into one compound type.<br />
Tuples have a <code>fixed length</code>, once declared, they can
<code>NOT</code> grow or shrink in size.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We create a tuple by writing a <code>comma-separated</code> list of
values inside <code>parentheses</code>.<br />
Each position in the tuple has a type,<br />
and the types of the different values in the tuple don‚Äôt have to be the
same.</li>
</ol>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tup1<span class="op">:</span> (<span class="dt">i32</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">u8</span>) <span class="op">=</span> (<span class="dv">1989</span><span class="op">,</span> <span class="dv">6.4</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span>  <span class="co">// :(i32, f64, u8)</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tup2 <span class="op">=</span> (<span class="dv">1989</span><span class="op">,</span> <span class="dv">6.4</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span>                  <span class="co">// :(i32, f64, i32)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (x<span class="op">,</span> y<span class="op">,</span> z) <span class="op">=</span> tup1<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value of y is {y}&quot;</span>)<span class="op">;</span>          <span class="co">// -&gt; 6.4</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> ninteen_eighty_four <span class="op">=</span> tup2<span class="op">.</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> june_fourth <span class="op">=</span> tup2<span class="op">.</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> one <span class="op">=</span> tup2<span class="op">.</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>You can use pattern matching to de-construct a tuple value,<br />
also you can use <code>0</code>-indexed index followed by a period
(<strong><code>.</code></strong>) to access the element.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>The tuple without any values has a special name,
<strong><code>unit</code></strong>.<br />
This value and its corresponding type are both written
<strong><code>()</code></strong>,<br />
and represent an empty value or an empty return type.</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>Expressions implicitly return the <strong><code>unit</code></strong>
value if they don‚Äôt return any other value.</li>
</ol>
<hr/>
<h3 id="the-array-type">The Array Type</h3>
<ol type="1">
<li>Unlike tuple, every element of an array must have the
<strong><em>same type</em></strong>.<br />
And unlike arrays in some other languages, arrays in Rust have a
<code>fixed length</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We write the values in an array as a comma-separated list inside
square brackets:</li>
</ol>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>An array is NOT as flexible as the vector type, though.<br />
A vector is a similar collection type provided by the standard library
that is allowed to grow or shrink in size.<br />
Arrays are useful when you want your data allocated on the
<code>stack</code> rather than <code>heap</code>.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>You write an array‚Äôs type using square brackets with the type of
each element, a semicolon,<br />
and then the number of elements in the array, like so:</li>
</ol>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arr<span class="op">:</span> [<span class="dt">i32</span><span class="op">;</span> <span class="dv">5</span>] <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>You can also initialize an array to contain the same value for each
element by specifying the initial value,<br />
followed by a semicolon, and then the length of the array in square
brackets,<br />
as shown here:</li>
</ol>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// [value; count]</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">3</span><span class="op">;</span> <span class="dv">5</span>]<span class="op">;</span>   <span class="co">// [3, 3, 3, 3, 3]</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Arrays are <code>0</code>-indexed. Out-of-index checks are performs
in run-time.</li>
</ol>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> first  <span class="op">=</span> arr[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> second <span class="op">=</span> arr[<span class="dv">1</span>]<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> index <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">std::io::</span>stdin()</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>read_line(<span class="op">&amp;</span><span class="kw">mut</span> index)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>expect(<span class="st">&quot;Failed to read a line!&quot;</span>)<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> index<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> index</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span>trim()</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span>parse()</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span>expect(<span class="st">&quot;Index entered was not a number!&quot;</span>)<span class="op">;</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">&lt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> elem <span class="op">=</span> arr[index]<span class="op">;</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;The value at index {index} is {elem}&quot;</span>)<span class="op">;</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="functions">Functions</h3>
<ol type="1">
<li>Rust code uses <code>snake_case</code> as the conventional style for
<em>functions</em> and <em>variables</em>,<br />
in which all letters are lowercase and underscores separate words.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We define a function in Rust by entering
<strong><code>fn</code></strong> followed by a function name and a set
of parentheses.<br />
The curly brackets tell the compiler where the function body begins and
ends.</li>
</ol>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;main function.&quot;</span>)<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        anoth_fn()<span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> anoth_fn() <span class="op">{</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Another function.&quot;</span>)<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>In function signatures, you must declare the type of each
parameter.<br />
When defining multiple parameters, separate the parameter declarations
with commas.</li>
</ol>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>        display_items(<span class="ch">&#39;A&#39;</span><span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> display_items(name<span class="op">:</span> <span class="dt">char</span><span class="op">,</span> count<span class="op">:</span> <span class="dt">u32</span>) <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;There are {count} {name}(s)&quot;</span>)<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>Functions can return values to the code that calls them.<br />
We don‚Äôt name return values, but we must declare their type after an
arrow (<strong><code>-&gt;</code></strong>).<br />
We can return early from a function by using the
<strong><code>return</code></strong> keyword and specifying a
value,<br />
but most functions return the last expression implicitly.</li>
</ol>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> five() <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>        <span class="dv">5</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> plus_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> five()<span class="op">;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{x}&quot;</span>)<span class="op">;</span>    <span class="co">// -&gt; 5</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> plus_one(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        println(<span class="st">&quot;{x}&quot;</span>)<span class="op">;</span>     <span class="co">// -&gt; 11</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="statements-and-expressions">Statements and Expressions</h3>
<ol type="1">
<li>Function bodies are made up of a series of <code>statements</code>
optionally ending in an <code>expression</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Because Rust is an expression-based language, this is an important
distinction to understand.<br />
<code>Statements</code> are instructions that perform some action and do
not return a value.<br />
<code>Expressions</code> evaluate to a resultant value.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>For example, creating a variable and assigning a value to it with
the <code>let</code> keyword is a statement.<br />
Statements do not return values.</p>
<p>Therefore, you can‚Äôt assign a <code>let</code> statement to another
variable,<br />
as the following code you‚Äôll get a compiler error:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">// WRONG!!</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> (<span class="kw">let</span> y <span class="op">=</span> <span class="dv">6</span>)<span class="op">;</span>    <span class="co">// ERR</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="kw">let</span> y <span class="op">=</span> <span class="dv">6</span><span class="op">;</span>      <span class="co">// OK</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Calling a function is an expression.<br />
Calling a macro is an expression.<br />
A new scope block created with curly brackets is an expression.</p></li>
</ol>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y <span class="op">=</span> <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>            x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>        println(<span class="st">&quot;{y}&quot;</span>)<span class="op">;</span>         <span class="co">// -&gt; 11</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>NOTE here that you can NOT write <code>x + 1;</code> at the end of
the block,<br />
because this way the value returned beomces
<strong><code>()</code></strong> which is an
<strong><code>unit</code></strong>. It‚Äôs like Pascal.</li>
</ul>
<hr/>
<h3 id="control-flow">Control Flow</h3>
<ol type="1">
<li>An <strong><code>if</code></strong> expression allows you to branch
your code depending on conditions.</li>
</ol>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> number <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> number <span class="op">&lt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Too small!&quot;</span>)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> number <span class="op">&gt;</span> <span class="dv">5</span> <span class="op">{</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Too big!&quot;</span>)<span class="op">;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Perfect!&quot;</span>)<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The semicolon is not required,</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// after an if statement that executes as a standalone control structure (which is this case),</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// but it does no harm if you include it.</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>It‚Äôs also worth noting that the condition in the control flow must
be a <strong><code>bool</code></strong>.<br />
If the condition is <code>NOT</code> a
<strong><code>bool</code></strong>, we‚Äôll get an error.<br />
For example, try running the following code:</li>
</ol>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> number <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="cf">if</span> number <span class="op">{</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                <span class="co">// ^^^^^^</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                <span class="co">// expected `bool`, found `integer`</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>            number <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span>      <span class="co">// This semicolon is for terminating the whole assignment statement.</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>And also <code>NOTE</code> that if you use
<strong><code>if</code></strong> as an expression <code>MUST</code>
provide an <strong><code>else</code></strong> block!</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>When the <strong><code>if</code></strong> expression is the last
thing in a block or a function, it returns a value,<br />
and you should <code>NOT</code> use a semicolon, because that would
prevent it from returning the desired value.</li>
</ol>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_value(number<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> number <span class="op">==</span> <span class="dv">3</span> <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>       <span class="co">// No semicolon!!</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> get_value(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>And here explaining why assignment needs an semicolon
(<strong><code>;</code></strong>) to end but as return expression it
does not.<br />
Because the assignment is essentially an <code>(let x = ...) (;)</code>
which needs a semicolon to end.</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>Also notice, <strong><code>if</code></strong> expression must return
the same type when used in a <code>let</code> statement.<br />
The following code will cause a compiler error:</li>
</ol>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cond <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> number <span class="op">=</span> <span class="cf">if</span> cond <span class="op">{</span> <span class="dv">10</span> <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> <span class="st">&quot;zero&quot;</span> <span class="op">};</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// _            ^^^^ expected integer, found `&amp;str`</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// |</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// expected beacuse of this</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>The <strong><code>loop</code></strong> keyword tells Rust to execute
a block of code over and over again forever,<br />
until you explicitly tell it to stop.</li>
</ol>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Again!&quot;</span>)<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>You can add the value you want returned after the
<strong><code>break</code></strong> expression you use to stop the
<strong><code>loop</code></strong>.</li>
</ol>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>            counter <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> counter <span class="op">==</span> <span class="dv">10</span> <span class="op">{</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>                <span class="co">// break &lt;label&gt; &lt;expression&gt;</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> counter <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span>   <span class="co">// -&gt; 11</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li><p>If you have loops within loops,<br />
<strong><code>break</code></strong> and
<strong><code>continue</code></strong> only apply to the innermost loop
at that point.</p>
<p>You can optionally specify a <code>loop label</code> on a loop<br />
that you can then use with <strong><code>break</code></strong> or
<strong><code>continue</code></strong> to specify that those keywords
apply to the labeled loop instead of the innermost loop.</p>
<p>Loop labels must begin with a single quote (<code>'</code>).</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">&#39;outer</span><span class="op">:</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{count}&quot;</span>)<span class="op">;</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> remaining <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&#39;inner</span><span class="op">:</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{remaining}&quot;</span>)<span class="op">;</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> remaining <span class="op">==</span> <span class="dv">9</span> <span class="op">{</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> count <span class="op">==</span> <span class="dv">2</span> <span class="op">{</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span> <span class="ot">&#39;outer</span><span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>            remaining <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;End.&quot;</span>)<span class="op">;</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Rust has a built-in language construct for
<strong><code>while</code></strong> loop.</p></li>
</ol>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> count <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{count}&quot;</span>)<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>            count <span class="op">-=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>You can use a <strong><code>for</code></strong> loop and execute
some code for each item in a collection.</li>
</ol>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">40</span><span class="op">,</span> <span class="dv">50</span>]<span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> elem <span class="kw">in</span> arr <span class="op">{</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{elem}&quot;</span>)<span class="op">;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// (1..4)  is 1,2,3</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// (1..=4) is 1,2,3,4</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// parentheses are optional, added it for better calling the .rev() method.</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// .rev() means to reverse the sequence.</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> number <span class="kw">in</span> (<span class="dv">1</span><span class="op">..</span><span class="dv">4</span>)<span class="op">.</span>rev() <span class="op">{</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{number}&quot;</span>)<span class="op">;</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="what-is-ownership">What is Ownership?</h3>
<ol type="1">
<li><p>Ownership is a set of rules that govern how a Rust program
manages memory.</p></li>
<li><p>All programs have to manage the way they use a computer‚Äôs memory
while running.<br />
Some languages have garbage collection (GC) that regularly looks for
no-longer-used memory as the program runs,<br />
in other languages, the programmer must explicitly allocate and free the
memory.</p></li>
<li><p>Rust uses a third approach:<br />
memory is managed through a system of ownership with a set of rules that
the compiler checks.<br />
If any of the rules are violated, the program won‚Äôt compile.<br />
None of the features of ownership will slow down your program while it‚Äôs
running.</p></li>
</ol>
<hr/>
<h3 id="the-stack-and-the-heap">The Stack and the Heap</h3>
<ol type="1">
<li>Both the <strong><code>stack</code></strong> and the
<strong><code>heap</code></strong> are parts of memory available to your
code to use at runtime,<br />
but they are structured in different ways.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>The <strong><code>stack</code></strong> stores values in the
order it gets them and removes the values in the opposite order.<br />
This is referred to as last in, first out (FILO).</p>
<p>Adding data is called pushing onto the stack, and removing data is
called popping off the stack.<br />
All data stored on the stack must have a
<code>known, fixed size</code>.<br />
Data with an <code>unknown size</code> at compile time or a size that
might <code>change</code> MUST be stored on the <code>heap</code>
instead.</p></li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>The <strong><code>heap</code></strong> is less organized, when
you put data on the heap, you request a certain amount of space.</p>
<p>The memory allocator finds an empty spot in the <code>heap</code>
that is big enough,<br />
marks it as being in use, and returns a <code>pointer</code>, which is
the address of that location.<br />
This process is called allocating on the heap and is sometimes
abbreviated as just allocating<br />
(pushing values onto the stack is not considered allocating).</p>
<p>Because the pointer to the heap is a known, fixed size, you can store
the pointer on the stack,<br />
but when you want the actual data, you must follow the pointer.</p></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>Pushing to the <strong><code>stack</code></strong> is
<code>faster</code> than allocating on the heap<br />
because the allocator never has to search for a place to store new data,
that location is always at the top of the stack.</p>
<p>Comparatively, allocating space on the heap requires more work<br />
because the allocator must first find a big enough space to hold the
data and then perform bookkeeping to prepare for the next
allocation.</p></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>Accessing data in the <strong><code>heap</code></strong> is
<code>slower</code> than accessing data on the stack<br />
because you have to follow a pointer to get there.<br />
Contemporary processors are faster if they jump around less in
memory.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li>When your code calls a function, the values passed into the function
(including, potentially, pointers to data on the heap)<br />
and the function‚Äôs local variables get pushed onto the stack.<br />
When the function is over, those values get popped off the stack.</li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>Keeping track of what parts of code are using what data on the
heap,<br />
minimizing the amount of duplicate data on the heap,<br />
and cleaning up unused data on the heap so you don‚Äôt run out of space
are all problems that ownership addresses.</li>
</ol>
<hr/>
<h3 id="ownership-rules">Ownership Rules</h3>
<ol type="1">
<li><p>Every value in Rust has an
<strong><code>owner</code></strong>.</p></li>
<li><p>There can only be <code>ONE</code>
<strong><code>owner</code></strong> at a time.</p></li>
<li><p>When the <strong><code>owner</code></strong> goes out of scope,
the value will be dropped.</p></li>
</ol>
<hr/>
<h3 id="varable-scope">Varable Scope</h3>
<ol type="1">
<li>A scope is the range within a program for which an item is
valid.<br />
e.g.¬†a function, a code block, etc.</li>
</ol>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span>                       <span class="co">// `s` is not valid here, it&#39;s not yet declared.</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>    <span class="co">// `s` is valid from this point.</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                       <span class="co">// This scope is now over, and `s` is no longer valid.</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li><p>To illustrate the rules of ownership,<br />
we need a data type that is more complex than those we covered in the
previous sections.<br />
The <strong><code>String</code></strong> type is a great example.</p>
<p>We‚Äôve already seen string literals, where a string value is hardcoded
into our program.<br />
String literals are convenient, but they aren‚Äôt suitable for every
situation in which we may want to use text.</p>
<p>One reason is that the string literal isn‚Äôt immutable.<br />
Another is that not every string value can be known when we write our
code,<br />
for example, what if we want to take user input and store it?</p>
<p>For these situations, Rust has a second string type,
<strong><code>String</code></strong>.<br />
This type manages data allocated on the <code>heap</code>,<br />
and as such is able to store an amount of text that is unknown to us at
compile time.<br />
You can create a <strong><code>String</code></strong> from a string
literal using the <strong><code>from( )</code></strong> function, like
so:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> hello <span class="op">=</span> <span class="st">&quot;hello&quot;</span><span class="op">;</span>                <span class="co">// :&amp;str</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span>  <span class="co">// :String</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>s<span class="op">.</span>push_str(<span class="st">&quot;, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span>                    <span class="co">// -&gt; Hello, world!</span></span></code></pre></div></li>
</ol>
<ul>
<li>So, what‚Äôs the difference here?<br />
Why can <strong><code>String</code></strong> be mutated but literals
cannot?<br />
The difference is in how these two types deal with memory.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li><p>In the case of a string literal,<br />
we know the contents at compile time, so the text is hardcoded directly
into the final executable.<br />
This is why string literals are fast and efficient.<br />
But these properties only come from the string literal‚Äôs
immutability.</p>
<p>With the <strong><code>String</code></strong> type,<br />
in order to support a mutable, growable piece of text, we need to
allocate an amount of memory on the heap,<br />
unknown at compile time, to hold the contents.</p>
<p>This means:</p>
<ul>
<li>The memory must be requested from the allocator at runtime.</li>
<li>We need a way of returning this memory to the allocator when we‚Äôre
done with it.</li>
</ul>
<p>That first part is done by us:</p>
<ul>
<li>When we call <strong><code>String::from( )</code></strong>, its
implementation requests the memory it needs.</li>
<li>This is pretty much universal in programming languages.</li>
</ul>
<p>However, the second part is different:</p>
<ul>
<li>In languages with a garbage collector (GC),<br />
the GC keeps track of and cleans up memory that isn‚Äôt being used
anymore, and we don‚Äôt need to think about it.</li>
<li>In most languages without a GC, it‚Äôs our responsibility to identify
when memory is no longer being used and to call code to explicitly free
it, just as we did to request it.</li>
<li>Doing this correctly has historically been a difficult programming
problem.</li>
<li>If we forget, we‚Äôll waste memory. If we do it too early, we‚Äôll have
an invalid variable.</li>
<li>If we do it twice, that‚Äôs a bug too. We need to pair exactly one
allocate with exactly one free.</li>
</ul>
<p>Rust thus takes a different path:</p>
<ul>
<li>Memory is automatically returned once the variable that owns it goes
out of scope.</li>
<li>When a variable goes out of scope, Rust calls a special function for
us.</li>
<li>This function is called <strong><code>drop()</code></strong>, and
it‚Äôs where the author of <strong><code>String</code></strong> can put
the code to return the memory.</li>
<li>Rust calls <strong><code>drop()</code></strong> automatically at the
closing curly bracket.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>NOTE in C++, this pattern of deallocating resources at the end of an
item‚Äôs lifetime is sometimes called Resource Acquisition Is
Initialization (<code>RAII</code>).<br />
The <strong><code>drop()</code></strong> function in Rust will be
familiar to you if you‚Äôve used <code>RAII</code> patterns.</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>To ensure memory safety, for types allocated on the heap, after the
line <code>let s2 = s1;</code>, Rust considers
<strong><em><code>s1</code></em></strong> as no longer valid.<br />
Therefore, Rust doesn‚Äôt need to free anything when
<strong><em><code>s1</code></em></strong> goes out of scope.</li>
</ol>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{s1}&quot;</span>)<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">//^^^^ value borrowed here after move</span></span></code></pre></div>
<ul>
<li>If you wanna use both <strong><em><code>s1</code></em></strong> and
<strong><em><code>s2</code></em></strong>, do this:</li>
</ul>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s2 <span class="op">=</span> s1<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{s1}&quot;</span>)<span class="op">;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{s2}&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Stack-Only data‚Äôs copy is much simpler.</li>
</ol>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{x}, {y}&quot;</span>)<span class="op">;</span></span></code></pre></div>
<ul>
<li>The reason is that types such as integers that have a
<code>known fixed size</code> at compile time are stored entirely on the
stack,<br />
so copies of the actual values are quick to make.</li>
<li>That means there‚Äôs no reason we would want to prevent
<strong><em><code>x</code></em></strong> from being valid after we
create the variable <strong><em><code>y</code></em></strong>.</li>
<li>In other words, there‚Äôs no difference between deep and shallow
copying here,<br />
so calling <strong><code>clone()</code></strong> would <code>NOT</code>
do anything different from the usual shallow copying, and we can leave
it out.</li>
</ul>
<p><br />
</p>
<ol start="7" type="1">
<li>Rust has a special annotation called the
<strong><code>Copy</code></strong> trait,<br />
we can place on types that are stored on the stack, as integers
are.<br />
If a type implements the <strong><code>Copy</code></strong> trait,
variables that use it do not move, but rather are trivially
copied,<br />
making them still valid after assignment to another variable.<br />
And they do NOT call <strong><code>drop()</code></strong> when come out
of scope.</li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>Rust will NOT let us annotate a type with
<strong><code>Copy</code></strong> if the type, or any of its parts, has
implemented the <strong><code>Drop</code></strong> trait.<br />
If we add the <strong><code>Copy</code></strong> annotation to that
type, we‚Äôll get a compile-time error.</li>
</ol>
<p><br />
</p>
<ol start="9" type="1">
<li><p>Here are some of the types that implicitly implement
<strong><code>Copy</code></strong>:</p>
<ol type="a">
<li>All integer types, such as <code>u32</code>.</li>
<li>The Boolean type <code>bool</code>.</li>
<li>All floating types, sucha s <code>f32</code>.</li>
<li>The Character type <code>char</code>.</li>
<li>Tuples if they only contain types also implement <code>Copy</code>
trait.<br />
e.g.¬†<code>(i32, i32)</code> YES, but <code>(i32, String)</code>
NO.</li>
</ol></li>
</ol>
<hr/>
<h3 id="ownership-and-functions">Ownership and Functions</h3>
<ol type="1">
<li>The mechanics of passing a value to a function are similar to those
when assigning a value to a variable.<br />
Passing a variable to a function will move or copy, just as assignment
does.</li>
</ol>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span>  <span class="co">// `s` comes into scope.</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        takes_ownership(s)<span class="op">;</span>             <span class="co">// `s` value moves into the function,</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// ... and so is no longer valid here.</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>                      <span class="co">// `x` comes into scope.</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        makes_copy(x)<span class="op">;</span>                  <span class="co">// `x` would move into the function, but  i32  is a Copy.</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// ... so it&#39;s still valid to use it after here.</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                                   <span class="co">// Here, `x` goes out of scope, then `s`.</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">// But because the value of `s` was moved, nothing special happens.</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> takes_ownership(some_string<span class="op">:</span> <span class="dt">String</span>) <span class="op">{</span>   <span class="co">// `some_string` comes into scope.</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{some_string}&quot;</span>)<span class="op">;</span></span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                                           <span class="co">// `some_string` comes out of scope and  drop()  is called,</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>                                                <span class="co">// ... the backing memory is freed.</span></span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> makes_copy(some_integer<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span>          <span class="co">// `some_integer` comes into scope.</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{some_integer}&quot;</span>)<span class="op">;</span></span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                                           <span class="co">// `some_integer` goes out of scope, nothing special happens.</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Returning values can also transfer ownership.</li>
</ol>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s1 <span class="op">=</span> gives_ownership()<span class="op">;</span>                     <span class="co">// `gives_ownership()` moves its return value into `s1`.</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span>                 <span class="co">// `s2` comes into scope.</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s3 <span class="op">=</span> takes_and_gives_ownership_back(s2)<span class="op">;</span>    <span class="co">// `s2` is moved into `takes_and_gives_ownership_back()`,</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>                                                        <span class="co">// which later moves its return value into `s3`.</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                                                   <span class="co">// Here, `s3` goes out of scope and is dropped.</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>                                                        <span class="co">// `s2` was moved, so nothing happens.</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>                                                        <span class="co">// `s1 goes out of scope and is dropped.`</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> gives_ownership() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> some_string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;yours&quot;</span>)<span class="op">;</span>        <span class="co">// `some_string` comes into scope.</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>        some_string                                     <span class="co">// `some_string` is returned and moves out to the calling function.</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> takes_and_gives_ownership_back(a_string<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span> <span class="co">// `a_string` comes into scope.</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>        a_string                                                    <span class="co">// `a_string` is returned and moves out to the calling function.</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>When a variable that includes data on the heap goes out of
scope,<br />
the value will be cleaned up by <strong><code>drop()</code></strong>
unless ownership of the data has been moved to another variable.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Inside a <strong><code>tuple</code></strong> there could be both
move and copy:</li>
</ol>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (s2<span class="op">,</span> len) <span class="op">=</span> calc_len(s1)<span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> calc_len(s<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> (<span class="dt">String</span><span class="op">,</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> len <span class="op">=</span> s<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        (s<span class="op">,</span> len) <span class="co">// Here, `s` will be moved, but `len` will be copied.</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="references-and-borrowing">References and Borrowing</h3>
<ol type="1">
<li>What if we want to let a function use a value but <code>NOT</code>
take ownership?<br />
Luckily, Rust has a feature for using a value without transferring
ownership, called <strong><code>reference</code></strong>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>A <strong><code>reference</code></strong> is like a pointer in
that it‚Äôs an address we can follow to access the data stored at that
address,<br />
that data is owned by some other variable.</p>
<p>However, unlike a pointer,<br />
a <strong><code>reference</code></strong> is guaranteed to point to a
valid value of a particular type for the life of that reference.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> calc_len(<span class="op">&amp;</span>s1)<span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The length of {s1} is {len}.&quot;</span>)<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> calc_len(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    s<span class="op">.</span>len()</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<ul>
<li>Those ampersands represent references, and they allow you to refer
to some value without taking ownership of it.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>The opposite of referencing by using
<strong><code>&amp;</code></strong> is
<strong><code>de-referencing</code></strong>,<br />
which is accomplished with the dereference operator
(<strong><code>*</code></strong>).<br />
We‚Äôll see some uses of the dereference operator in later chapters!</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>When functions have references as parameters instead of the
actual values,<br />
we do <code>NOT</code> need to return the values in order to give back
ownership, because we never had ownership.</p>
<p>We call the action of creating a reference
<strong><code>borrowing</code></strong>.<br />
As in real life, if a person owns something, you can borrow it from
them.<br />
When you‚Äôre done, you have to give it back. You don‚Äôt own it.</p></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>So, what happens if we try to modify something we‚Äôre
borrowing?<br />
Spoiler alert: it does NOT work!</li>
</ol>
<div class="sourceCode" id="cb40"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>        change(<span class="op">&amp;</span>s)<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> change(some_string<span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        some_string<span class="op">.</span>push_str(<span class="st">&quot;, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  ^^^^^^^^^^^ `some_string` is a `&amp;` reference,</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//              so the data it refers to cannot be borrowed as mutable.</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Just as variables are <strong><code>immutable</code></strong> by
default, so are references.<br />
We are NOT allowed to modify something we have only reference to.</li>
</ul>
<p><br />
</p>
<ol start="6" type="1">
<li>We can fix the code allowing us to modify a borrowed value with just
a <strong><code>mutable reference</code></strong>:</li>
</ol>
<div class="sourceCode" id="cb41"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        change(<span class="op">&amp;</span><span class="kw">mut</span> s)<span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> change(something<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>        something<span class="op">.</span>push_str(<span class="st">&quot;, world&quot;</span>)<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>Mutable references have one big restriction,<br />
if you have a mutable reference to a value, you must have NO other
references to that value at a time.<br />
This code that attempts to create two mutable references to
<strong><em><code>s</code></em></strong> will fail:</li>
</ol>
<div class="sourceCode" id="cb42"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      -------- first mutable borrow occurs here.</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      ^^^^^^^^ second mutable borrow occurs here.</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{r2}&quot;</span>)<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This is ok.</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If you borrowed it multiple times, you can always ONLY use the LAST BORROW.</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{r1}&quot;</span>)<span class="op">;</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">//         -- first borrow later used here.</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>As always, we can use curly brackets to create a new scope, allowing
for multiple mutable references,<br />
just not simultaneous:</li>
</ol>
<div class="sourceCode" id="cb43"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>We also can NOT have a mutable reference while we have an immutable
one to the same value.</li>
</ol>
<div class="sourceCode" id="cb44"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span>s<span class="op">;</span>        <span class="co">// OK</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//       -- immutable borrow occurs here.</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span>s<span class="op">;</span>        <span class="co">// OK</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r3 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span>    <span class="co">// ERR!</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      ^^^^^^^ mutable borrow occurs here.</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{} {} {}&quot;</span><span class="op">,</span> r1<span class="op">,</span> r2<span class="op">,</span> r3)<span class="op">;</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                   -- immutable borrow later used here.</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>Note that a reference‚Äôs scope starts from where it is introduced,
and continues through the last time that reference is
<code>used</code>.<br />
For instance, this code will compile because the last usage of the
immutable references, the <strong><code>println!</code></strong>,<br />
occurs before the mutable reference is introduced:</li>
</ol>
<div class="sourceCode" id="cb45"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span>s<span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span>s<span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{r1} {r2}&quot;</span>)<span class="op">;</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r3 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> s<span class="op">;</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{r3}&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="11" type="1">
<li>Example:</li>
</ol>
<div class="sourceCode" id="cb46"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> my_string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;a&quot;</span>)<span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>        first_fn(<span class="op">&amp;</span><span class="kw">mut</span> my_string)<span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{my_string}&quot;</span>)<span class="op">;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> fist_fn(s<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push_str(<span class="st">&quot;a&quot;</span>)<span class="op">;</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>        second_fn(s)<span class="op">;</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> second_fn(s<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">String</span>) <span class="op">{</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push_str(<span class="st">&quot;b&quot;</span>)<span class="op">;</span></span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Output</span></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a><span class="co">        -&gt; aa</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a><span class="co">        -&gt; aab</span></span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a><span class="co">        -&gt; aab</span></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a><span class="co">        -&gt; aab</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span></code></pre></div>
<hr/>
<h3 id="dangling-references">Dangling References</h3>
<ol type="1">
<li>In languages with pointers, it‚Äôs easy to erroneously create a
<code>dangling pointer</code>,<br />
a pointer that references a location in memory that may have been given
to someone else by freeing some memory while preserving a pointer to
that memory.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>In Rust, by contrast, the compiler guarantees that references will
NEVER be dangling references,<br />
if you have a reference to some data, the compiler will ensure that the
data will not go out of scope before the reference to the data
does.</li>
</ol>
<div class="sourceCode" id="cb47"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> ref_to_nothing <span class="op">=</span> dangling()<span class="op">;</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> dangling() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">//               ^ expected named lifetime parameter.</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>)<span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;</span>s</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//  ^^ returns a reference to data owned by the current function.</span></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>This error message refers to a feature we haven‚Äôt covered yet:
<code>lifetimes</code>. We‚Äôll discuss <code>lifetimes</code> in later
chapters!</li>
</ul>
<hr/>
<h3 id="the-rules-of-references-summary">The Rules of References
Summary</h3>
<ol type="1">
<li>At any given time,<br />
you can have either ONE mutable reference or any number of immutabe
references.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>References must always be valid.<br />
Which means the data will NEVER go out of scope before the reference to
the data does.</li>
</ol>
<hr/>
<h3 id="the-slice-type">The Slice Type</h3>
<ol type="1">
<li><strong><code>Slice</code></strong> lets you reference a contiguous
sequence of elements in a collection, rather than the whole
collection.<br />
A slice is a kind of reference, so it <strong><em>does not</em></strong>
have ownership.</li>
</ol>
<hr/>
<h3 id="string-slices">String Slices</h3>
<ol type="1">
<li>A string slice is a reference to part of a
<strong><code>String</code></strong>, and it looks like this:</li>
</ol>
<div class="sourceCode" id="cb48"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello, world&quot;</span>)<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hello <span class="op">=</span> <span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span><span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> world <span class="op">=</span> <span class="op">&amp;</span>s[<span class="dv">7</span><span class="op">..</span><span class="dv">12</span>]<span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> entire_str <span class="op">=</span> <span class="op">&amp;</span>s[<span class="op">..</span>]<span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> entire_str2 <span class="op">=</span> <span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>s<span class="op">.</span>len()]<span class="op">;</span></span></code></pre></div>
<ul>
<li>With Rust‚Äôs <strong><code>..</code></strong> range syntax, if you
want to start at index <code>0</code>, you can simply write
<code>let hello = &amp;s[..5];</code>.<br />
By the same token, if your slice incluses the last byte of
<code>String</code>, you write
<code>let world = &amp;s[7..];</code>.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li>Example 1 : To get the first word in a string, or the entire
string.</li>
</ol>
<div class="sourceCode" id="cb49"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> word <span class="op">=</span> first_word(<span class="op">&amp;</span>s)<span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{word}&quot;</span>)<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>clear()<span class="op">;</span>  <span class="co">// Empties the String, making it equal to &quot;&quot;,</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// thus the slice {word} will also no longer no valid!</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// But NOT because it clears the String, but because it has used a mutable borrow inside it,</span></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// so an immutable borrow like {word} could no longer be used.</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Immutable borrows can NOT be used after a mutable borrow!</span></span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-15"><a href="#cb49-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> first_word(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb49-16"><a href="#cb49-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> bytes <span class="op">=</span> s<span class="op">.</span>as_bytes()<span class="op">;</span></span>
<span id="cb49-17"><a href="#cb49-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-18"><a href="#cb49-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (i<span class="op">,</span> <span class="op">&amp;</span>item) <span class="kw">in</span> bytes<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb49-19"><a href="#cb49-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> item <span class="op">==</span> <span class="ch">b&#39; &#39;</span> <span class="op">{</span></span>
<span id="cb49-20"><a href="#cb49-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">&amp;</span>s[<span class="dv">0</span><span class="op">..</span>i]<span class="op">;</span></span>
<span id="cb49-21"><a href="#cb49-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb49-22"><a href="#cb49-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb49-23"><a href="#cb49-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-24"><a href="#cb49-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">&amp;</span>s[<span class="op">..</span>]</span>
<span id="cb49-25"><a href="#cb49-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="string-literals-as-slices">String Literals as Slices</h3>
<ol type="1">
<li>Recall that we talked about string literals being stored inside the
binary.<br />
Now that we know about slices, we can properly understand string
literals:</li>
</ol>
<div class="sourceCode" id="cb50"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;Hello, world!&quot;</span><span class="op">;</span></span></code></pre></div>
<ul>
<li>The type of <strong><em><code>s</code></em></strong> here is
<strong><code>&amp;str</code></strong>, it is a slice pointing to that
specific point of the binary.<br />
This also explains why string literals are immutable.
<strong><code>&amp;str</code></strong> is an immutable reference.</li>
</ul>
<hr/>
<h3 id="string-slices-as-parameters">String Slices as Parameters</h3>
<ol type="1">
<li>Knowing that you can take slices of literals,<br />
and <strong><code>String</code></strong> values leads us to one more
improvement on <strong><code>first_word()</code></strong>, and that‚Äôs
its signature:</li>
</ol>
<div class="sourceCode" id="cb51"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> first_word(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">String</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span></span></code></pre></div>
<ul>
<li>A more experienced Rust user would write the signature shown below
instead,<br />
because it allows us to use the same function on both
<strong><code>&amp;String</code></strong> values and
<strong><code>&amp;str</code></strong> values.</li>
</ul>
<div class="sourceCode" id="cb52"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> first_word(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span></span></code></pre></div>
<ul>
<li>If we have a string slice, we can pass that directly.<br />
If we have a <strong><code>String</code></strong>, we can pass a slice
of the <strong><code>String</code></strong> or a reference to the
<strong><code>String</code></strong>.<br />
This flexibility takes advantage of <strong><em>deref
coercions</em></strong>, a feature we will cover in later chapters!</li>
</ul>
<div class="sourceCode" id="cb53"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> my_string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> word <span class="op">=</span> first_word(<span class="op">&amp;</span>my_string[<span class="dv">0</span><span class="op">..</span><span class="dv">7</span>])<span class="op">;</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> word <span class="op">=</span> first_word(<span class="op">&amp;</span>my_string[<span class="op">..</span>])<span class="op">;</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> word <span class="op">=</span> first_word(<span class="op">&amp;</span>my_string)<span class="op">;</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> my_string_literal <span class="op">=</span> <span class="st">&quot;hello world&quot;</span><span class="op">;</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> world <span class="op">=</span> first_word(<span class="op">&amp;</span>my_string_literal[<span class="dv">0</span><span class="op">..</span><span class="dv">7</span>])<span class="op">;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> world <span class="op">=</span> first_word(<span class="op">&amp;</span>my_string_literal[<span class="op">..</span>])<span class="op">;</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> world <span class="op">=</span> first_word(my_string_literal)<span class="op">;</span></span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="other-slices">Other Slices</h3>
<ol type="1">
<li>Just as we might want to refer to part of a string, we might also
want to refer to part of an array.</li>
</ol>
<div class="sourceCode" id="cb54"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> slice <span class="op">=</span> <span class="op">&amp;</span>arr[<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>]<span class="op">;</span>     <span class="co">// : &amp;[i32]</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(slice<span class="op">,</span> <span class="op">&amp;</span>[<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span></code></pre></div>
<hr/>
<h3 id="defining-and-instantiating-structs">Defining and Instantiating
Structs</h3>
<ol type="1">
<li>Like tuples, the pieces of a struct can be different types.<br />
Unlike with tuples, in a struct you‚Äôll name each piece of data so it‚Äôs
clear what the values mean.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>To define a struct, we enter the keyword
<strong><code>struct</code></strong> to name the entire structure.<br />
Then, inside curly brackets, we define the names and types of the pieces
of data, which we call <strong><em>fields</em></strong>.</li>
</ol>
<div class="sourceCode" id="cb55"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> User <span class="op">{</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>        active<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>        username<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>        email<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        sign_in_counts<span class="op">:</span> <span class="dt">u64</span><span class="op">,</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li><p>To use a <strong><code>struct</code></strong> after we‚Äôve defined
it,<br />
we create an <strong><em>instance</em></strong> of that it by specifying
concrete values for each of the fields.</p>
<p>We create an instance by stating the name of the struct and then add
curly brackets containing <em>key / value pairs</em>,<br />
where the keys are the names of the fields and the values are the data
we want to store in those fields.</p>
<p>We don‚Äôt have to specify the fields in the same order in which we
declared them in the <strong><code>struct</code></strong>.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> user1 <span class="op">=</span> User <span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>        active<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        username<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;John&quot;</span>)<span class="op">,</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>        email<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;someone@random.com&quot;</span>)<span class="op">,</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>        sign_in_counts<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// To access a specific value from a struct, we use dot notation.</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    user1<span class="op">.</span>email <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;another@example.com&quot;</span>)<span class="op">;</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> user2 <span class="op">=</span> build_user(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello@hi.com&quot;</span>)<span class="op">,</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Pete&quot;</span>))<span class="op">;</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> build_user(email<span class="op">:</span> <span class="dt">String</span><span class="op">,</span> username<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> User <span class="op">{</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>    User <span class="op">{</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>        active<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>        username<span class="op">:</span> username<span class="op">,</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>        email<span class="op">:</span> email<span class="op">,</span></span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>        sign_in_counts<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>NOTE that the <strong><em>entire</em></strong>
<strong><em>instance</em></strong> of
<strong><code>struct</code></strong> must be
<strong><code>mut</code></strong> if you want to change any field.<br />
Rust does <code>NOT</code> allow you to mark only certain fields as
mutable.</p></li>
</ol>
<hr/>
<h3 id="use-the-field-init-shorthand">Use the Field Init Shorthand</h3>
<ol type="1">
<li>If the property names and the <strong><code>struct</code></strong>
field names are exactly the same,<br />
we can use the <strong><em>field init shorthand</em></strong>
syntax:</li>
</ol>
<div class="sourceCode" id="cb57"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> build_user(email<span class="op">:</span> <span class="dt">String</span><span class="op">,</span> username<span class="op">:</span> <span class="dt">String</span>) <span class="op">-&gt;</span> User <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>        User <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>            active<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>            username<span class="op">,</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>            email<span class="op">,</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>            sign_in_counts<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3
id="creating-instances-from-other-instances-with-struct-update-syntax">Creating
Instances from Other Instances with Struct Update Syntax</h3>
<ol type="1">
<li>It‚Äôs often useful to create a new instance that includes most of the
values from another, but changes some.<br />
You can do this using <strong><em>struct update</em></strong>
syntax.</li>
</ol>
<div class="sourceCode" id="cb58"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> user1 <span class="op">=</span> build_user(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello@hi.com&quot;</span>)<span class="op">,</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Pete&quot;</span>))<span class="op">;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here I initialize {user2.username} and {user2.email}</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// because they are `String`, so they do not implement the `Copy` trait.</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If not updating this way the ownership will be transferred.</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> user2 <span class="op">=</span> User <span class="op">{</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>            username<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;John&quot;</span>)<span class="op">,</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>            email<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hejo@hi,com&quot;</span>)<span class="op">,</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">..</span>user1</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The syntax <strong><code>..</code></strong> specifies that the
remaining fields not explicitly set should have the same value<br />
as the fields in the given instance.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li>However, you can NOT use <strong><em>struct update</em></strong>
syntax to update an instance of a different type.</li>
</ol>
<hr/>
<h3
id="use-tuple-structs-without-named-fields-to-create-different-types">Use
Tuple Structs without Named Fields to Create Different Types</h3>
<ol type="1">
<li>Rust also supports structs that look similar to tuples, called
<strong><em>tuple structs</em></strong>.<br />
They just have the types of the fields.</li>
</ol>
<div class="sourceCode" id="cb59"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> Color(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> Point(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> black <span class="op">=</span> Color(<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> origin <span class="op">=</span> Point(<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>Function that takes a parameter of type <code>Color</code> cannot
take a <code>Point</code> as an argument,<br />
even though both types are made up of three <code>i32</code>
values.</li>
<li>Otherwise, <strong><em>tuple struct</em></strong> instances are
similar to tuples in that you can destructure them into their individual
pieces,<br />
and you can use a dot (<code>.</code>) followed by the
<code>0</code>-based index to access an individual value.</li>
</ul>
<hr/>
<h3 id="ownership-of-struct-data">Ownership of Struct Data</h3>
<ol type="1">
<li>In the <code>User</code> struct definition below,<br />
we used the owned <strong><code>String</code></strong> type rather than
the <strong><code>&amp;str</code></strong> string slice type.<br />
This is a deliberate choice because we want each instance of it to OWN
all of its data, and for that data to be valid for as long as the entire
struct is valid.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>It‚Äôs also possible for structs to store references to data owned
by something else,<br />
but to do so requires the use of <strong><em>lifetimes</em></strong>, a
Rust feature that we‚Äôll discuss in later chapters!<br />
Lifetimes ensure that the data referenced by a struct is valid for as
long as the struct is valid.</p>
<p>Let‚Äôs say you try to store a reference in a struct without specifying
lifetimes,<br />
like the following, this won‚Äôt work:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> User <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    active<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    username<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">//            ^ expected named lifetime parameter.</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    email<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co">//         ^ expected named lifetime parameter.</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>    sign_in_counts<span class="op">:</span> <span class="dt">u64</span><span class="op">,</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> user1 <span class="op">=</span> User <span class="op">{</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>        active<span class="op">:</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>        username<span class="op">:</span> <span class="st">&quot;John&quot;</span><span class="op">,</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>        email<span class="op">:</span> <span class="st">&quot;john@example.com&quot;</span><span class="op">,</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>        sign_in_counts<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>An example of using struct:</p></li>
</ol>
<div class="sourceCode" id="cb61"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>        width<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>        height<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rect <span class="op">=</span> Rectangle <span class="op">{</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>            width<span class="op">:</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>            height<span class="op">:</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The are of the rectangle is {}&quot;</span><span class="op">,</span> area(<span class="op">&amp;</span>rect))<span class="op">;</span></span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> area(rectangle<span class="op">:</span> <span class="op">&amp;</span>Rectangle) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        rectangle<span class="op">.</span>width <span class="op">*</span> rectangle<span class="op">.</span>height</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="adding-useful-functionality-with-derived-traits">Adding Useful
Functionality with Derived Traits</h3>
<ol type="1">
<li>The <strong><code>println!</code></strong> macro can do many kinds
of formatting, and by default, the curly brackets tell
<strong><code>println!</code></strong> to use formatting known as
<strong><code>Display</code></strong>,<br />
an output intended for direct end user consumption.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The primitive types we‚Äôve seen so far all implement
<strong><code>Display</code></strong> by default,<br />
because there‚Äôs only one way you‚Äôd want to show an integer or any other
primitive type to a user.<br />
But with structs, the way <strong><code>println!</code></strong> should
format the output is less clear.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>And the <strong><code>{:?}</code></strong> or
<strong><code>{:#?}</code></strong> (for pretty-print) require to
implement the <strong><code>Debug</code></strong> trait.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>Rust does include functionality to print out debugging
information,<br />
but we have to explicitly opt in to make that functionality available
for our struct.</p>
<p>To do that, we add the outer attribute
<strong><code>#[derive(Debug)]</code></strong> just before the
<strong>struct</strong> definition:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    width<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    height<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> rect <span class="op">=</span> Rectangle <span class="op">{</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>        width<span class="op">:</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>        height<span class="op">:</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{rect:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Another way to print out a value using the
<strong><code>Debug</code></strong> format is to use the
<strong><code>dbg!</code></strong> macro,<br />
which takes ownership of an expression (as opposed to
<strong><code>println!</code></strong>, which takes a reference),<br />
prints the file and line number of where that
<strong><code>dbg!</code></strong> macro call occurs in your code along
with the resultant value of that expression, and returns ownership of
the value.</p>
<p>And calling the <strong><code>dbg!</code></strong> macro prints to
the standard error console stream
(<strong><code>stderr</code></strong>),<br />
as opposed to <strong><code>println!</code></strong>, which prints to
the standard output console stream
(<strong><code>stdout</code></strong>).<br />
</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    width<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    height<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> scale <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> rect <span class="op">=</span> Rectangle <span class="op">{</span></span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Because `dbg!` returns ownership of the expression‚Äôs value,</span></span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the width field will get the same value as if we didn‚Äôt have the `dbg!`.</span></span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>        width<span class="op">:</span> <span class="pp">dbg!</span>(<span class="dv">10</span> <span class="op">*</span> scale)<span class="op">,</span></span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a>        height<span class="op">:</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-17"><a href="#cb63-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// We don‚Äôt want `dbg!` to take ownership of {rect},</span></span>
<span id="cb63-18"><a href="#cb63-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// so we use a reference to {rect} in the next call.</span></span>
<span id="cb63-19"><a href="#cb63-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">dbg!</span>(<span class="op">&amp;</span>rect)<span class="op">;</span></span>
<span id="cb63-20"><a href="#cb63-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<hr/>
<h3 id="method-syntax">Method Syntax</h3>
<ol type="1">
<li>Unlike functions, methods are defined within the context of a
<strong><code>struct</code></strong> (or an
<strong><code>enum</code></strong> or a
<strong><code>trait</code></strong> object).</li>
</ol>
<div class="sourceCode" id="cb64"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        width<span class="op">:</span>  <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>        height<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">NOTE</span><span class="co">: here {self} is of type `Self`.</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Rectangle <span class="op">{</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> area(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>width <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>height</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> set_width(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> width<span class="op">:</span> <span class="dt">u32</span>) <span class="op">{</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>width <span class="op">=</span> width<span class="op">;</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> get_width(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>width</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> set_height(<span class="kw">self</span><span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Self</span><span class="op">,</span> height<span class="op">:</span> <span class="dt">u32</span>) <span class="op">{</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>height <span class="op">=</span> height<span class="op">;</span></span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> get_height(<span class="kw">self</span><span class="op">:</span> <span class="op">&amp;</span><span class="dt">Self</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>height</span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> can_hold(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> <span class="op">&amp;</span>Rectangle) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">self</span><span class="op">.</span>width <span class="op">&gt;</span> other<span class="op">.</span>width)</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;&amp;</span></span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">self</span><span class="op">.</span>height <span class="op">&gt;</span> other<span class="op">.</span>height)</span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb64-37"><a href="#cb64-37" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> rect <span class="op">=</span> Rectangle <span class="op">{</span></span>
<span id="cb64-38"><a href="#cb64-38" aria-hidden="true" tabindex="-1"></a>            width<span class="op">:</span>  <span class="dv">20</span><span class="op">,</span></span>
<span id="cb64-39"><a href="#cb64-39" aria-hidden="true" tabindex="-1"></a>            height<span class="op">:</span> <span class="dv">30</span><span class="op">,</span></span>
<span id="cb64-40"><a href="#cb64-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb64-41"><a href="#cb64-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-42"><a href="#cb64-42" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> rect<span class="op">.</span>area())<span class="op">;</span></span>
<span id="cb64-43"><a href="#cb64-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li><p>Rust does NOT have an equivalence to the
<strong><code>-&gt;</code></strong> operator as in C / C++.<br />
Instead, Rust has a feature called <strong><em>automatic
referencing</em></strong> and <strong><em>automatic
dereferencing</em></strong>.<br />
</p>
<p>Here‚Äôs how it works:</p>
<ul>
<li>when you call a method with <code>object.something(</code>),<br />
Rust automatically adds in <strong><code>&amp;</code></strong>,
<strong><code>&amp;mut</code></strong>, or
<strong><code>*</code></strong> so object matches the signature of the
method.</li>
</ul>
<p>In other words, the following are the same:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>p1<span class="op">.</span>distance(<span class="op">&amp;</span>p2)<span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">&amp;</span>p1)<span class="op">.</span>distance(<span class="op">&amp;</span>p2)<span class="op">;</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>All functions defined within an
<strong><code>impl</code></strong> block are called
<strong><em>associated functions</em></strong>.<br />
We can define associated functions that don‚Äôt have
<strong><code>self</code></strong> as their first parameter (and thus
are not methods).</p></li>
</ol>
<div class="sourceCode" id="cb66"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Rectangle <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> square(size<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>                width<span class="op">:</span>  size<span class="op">,</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>                height<span class="op">:</span> size<span class="op">,</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> sq <span class="op">=</span> <span class="pp">Rectangle::</span>square(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Each <strong><code>struct</code></strong> is allowed to have
multiple <strong><code>impl</code></strong> blocks.</li>
</ol>
<div class="sourceCode" id="cb67"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Rectangle <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> area(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>width <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>height</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Rectangle <span class="op">{</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> square(size<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>                width<span class="op">:</span>  size<span class="op">,</span></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>                height<span class="op">:</span> size<span class="op">,</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="defining-an-enum">Defining an Enum</h3>
<ol type="1">
<li><strong><code>enum</code></strong> gives you a way of saying a value
is one of a possible set of values.</li>
</ol>
<div class="sourceCode" id="cb68"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> IpAddrKind <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>        v4<span class="op">,</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>        v6</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> IpAddr <span class="op">{</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>        kind<span class="op">:</span> IpAddrKind<span class="op">,</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>        address<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> home <span class="op">=</span> IpAddr <span class="op">{</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>            kind<span class="op">:</span> <span class="pp">IpAddrKind::</span>v4<span class="op">,</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>            address<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;127.0.0.1&quot;</span>)<span class="op">,</span></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> loopback <span class="op">=</span> IpAddr <span class="op">{</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>            kind<span class="op">:</span> <span class="pp">IpAddrKind::</span>v6<span class="op">,</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>            address<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;::1&quot;</span>)<span class="op">;</span></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> ipv6 <span class="op">=</span> <span class="pp">IpAddrKind::</span>v6<span class="op">;</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>        route(<span class="pp">IpAddrKind::</span>v4)<span class="op">;</span></span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>        route(ipv6)<span class="op">;</span></span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> route(ip<span class="op">:</span> IpAddrKind) <span class="op">{</span></span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Rather than an <strong><code>enum</code></strong> inside a
<strong><code>struct</code></strong>, we can put data directly into each
<strong><code>enum</code></strong> variant.</li>
</ol>
<div class="sourceCode" id="cb69"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> IpAddr <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>        V4(<span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span><span class="op">,</span> <span class="dt">u8</span>)<span class="op">,</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>        V6(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> home <span class="op">=</span> <span class="pp">IpAddr::</span>V4(<span class="dv">127</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> loopback <span class="op">=</span> <span class="pp">IpAddr::</span>V6(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;::1&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>Let‚Äôs look at another example of an
<strong><code>enum</code></strong> has a wide variety of types embedded
in its variants.</li>
</ol>
<div class="sourceCode" id="cb70"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Message <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>        Quit<span class="op">,</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>        Move <span class="op">{</span> x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">i32</span> <span class="op">},</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Write</span>(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>        ChangeColor(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb70-6"><a href="#cb70-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-7"><a href="#cb70-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-8"><a href="#cb70-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Message <span class="op">{</span></span>
<span id="cb70-9"><a href="#cb70-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> call(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb70-10"><a href="#cb70-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb70-11"><a href="#cb70-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb70-12"><a href="#cb70-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-13"><a href="#cb70-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb70-14"><a href="#cb70-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> msg <span class="op">=</span> <span class="pp">Message::</span><span class="bu">Write</span>(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>))<span class="op">;</span></span>
<span id="cb70-15"><a href="#cb70-15" aria-hidden="true" tabindex="-1"></a>        msg<span class="op">.</span>call()<span class="op">;</span></span>
<span id="cb70-16"><a href="#cb70-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="the-option-enum-and-its-advantages-over-null-values">The Option
Enum and Its Advantages Over Null values</h3>
<ol type="1">
<li>The <strong><code>Option</code></strong> enum encodes the very
common scenario,<br />
in which a value could be something or it could be nothing.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Rust does not have nulls,<br />
but it does have an enum that can encode the concept of a value being
present or absent.<br />
This enum is <strong><code>Option&lt;T&gt;</code></strong>, and it is
defined by the standard library as follows:</li>
</ol>
<div class="sourceCode" id="cb71"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span><span class="op">,</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(T)<span class="op">,</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li><p>The <strong><code>Option&lt;T&gt;</code></strong> enum is so
useful that it‚Äôs even included in the
<strong><em>prelude</em></strong>,<br />
you don‚Äôt even need to bring it into scope explicitly.</p>
<p>Its variants are also included in the
<strong><em>prelude</em></strong>,<br />
you can use <strong><code>Some(T)</code></strong> and
<strong><code>None</code></strong> directly without the
<strong><code>Option::</code></strong> prefix.</p>
<p>The <strong><code>&lt;T&gt;</code></strong> is a generic type
parameter, and we‚Äôll cover generics in more detail in later
chapters!</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> some_number <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> some_char   <span class="op">=</span> <span class="cn">Some</span>(<span class="ch">&#39;e&#39;</span>)<span class="op">;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> absent_number<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Because <strong><code>Option&lt;T&gt;</code></strong> and
<strong><code>T</code></strong> (where <code>T</code> can be any type)
are different types,<br />
the compiler won‚Äôt let us use an
<strong><code>Option&lt;T&gt;</code></strong> value as if it were
definitely a valid value.<br />
For example, this code won‚Äôt compile, because it‚Äôs trying to add an
<strong><code>i8</code></strong> to an
<strong><code>Option&lt;i8&gt;</code></strong>:</p></li>
</ol>
<div class="sourceCode" id="cb73"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x<span class="op">:</span> <span class="dt">i8</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> y<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">i8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> sum <span class="op">=</span> x <span class="op">+</span> y<span class="op">;</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          ^ no implementation for `i8 + Option&lt;i8&gt;`</span></span></code></pre></div>
<hr/>
<h3 id="the-match-control-flow-construct">The <code>match</code> Control
Flow Construct</h3>
<ol type="1">
<li>Rust has an extremely powerful control flow construct called
<strong><code>match</code></strong>,<br />
that allows you to compare a value against a series of patterns and then
execute code based on which pattern matches.</li>
</ol>
<div class="sourceCode" id="cb74"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> Coin <span class="op">{</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>            Penny<span class="op">,</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>            Nickel<span class="op">,</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>            Dime<span class="op">,</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>            Quarter<span class="op">,</span></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> value_in_cents(coin<span class="op">:</span> Coin) <span class="op">-&gt;</span> <span class="dt">u8</span> <span class="op">{</span></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> coin <span class="op">{</span></span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Penny     <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;A lucky penny!&quot;</span>)<span class="op">;</span></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">1</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Nicke     <span class="op">=&gt;</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Dime      <span class="op">=&gt;</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Quarter   <span class="op">=&gt;</span> <span class="dv">25</span><span class="op">,</span></span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Another useful feature of <strong><code>match</code></strong> arms
is that they can bind to the parts of the values that match the
pattern.</li>
</ol>
<div class="sourceCode" id="cb75"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> UsState <span class="op">{</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>            Alabama<span class="op">,</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>            Alaska<span class="op">,</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --snip--</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> Coin <span class="op">{</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>            Penny<span class="op">,</span></span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>            Nickel<span class="op">,</span></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a>            Dime<span class="op">,</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>            Quarter(UsState)<span class="op">,</span></span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> value_in_cents(coin<span class="op">:</span> Coin) <span class="op">-&gt;</span> <span class="dt">u8</span> <span class="op">{</span></span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> coin <span class="op">{</span></span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Penny <span class="op">=&gt;</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Nicke <span class="op">=&gt;</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Dime  <span class="op">=&gt;</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb75-20"><a href="#cb75-20" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Coin::</span>Quarter(state)  <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb75-21"><a href="#cb75-21" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;A quarter from {state:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb75-22"><a href="#cb75-22" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">25</span></span>
<span id="cb75-23"><a href="#cb75-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb75-24"><a href="#cb75-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb75-25"><a href="#cb75-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>We can also handle <strong><code>Option&lt;T&gt;</code></strong>
using <strong><code>match</code></strong>, as we did with the
<code>Coin</code> enum!</li>
</ol>
<div class="sourceCode" id="cb76"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> plus_one(x <span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>                <span class="cn">None</span> <span class="op">=&gt;</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(i) <span class="op">=&gt;</span> <span class="cn">Some</span>(i <span class="op">+</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> five <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> six <span class="op">=</span> plus_one(five)<span class="op">;</span></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> nothing <span class="op">=</span> plus_one(<span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>There‚Äôs one other aspect of we need to discuss -
<strong><code>match</code></strong> is exhaustive.<br />
Which means the arms‚Äô patterns must cover all possibilities.<br />
Underscore ( <strong><code>_</code></strong> ) is a special pattern that
matches any value and does not bind to that value.</li>
</ol>
<div class="sourceCode" id="cb77"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> dice_roll <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> dice_roll <span class="op">{</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span> <span class="op">=&gt;</span> add_fancy_hat()<span class="op">,</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>            <span class="dv">6</span> <span class="op">=&gt;</span> remove_fancy_hat()<span class="op">,</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>            other <span class="op">=&gt;</span> move_player(other)<span class="op">,</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> dice_roll <span class="op">{</span></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span> <span class="op">=&gt;</span> add_fancy_hat()<span class="op">,</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a>            <span class="dv">6</span> <span class="op">=&gt;</span> remove_fancy_hat()<span class="op">,</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> reroll()<span class="op">,</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> reroll() <span class="op">{}</span></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add_fancy_hat() <span class="op">{}</span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> remove_fancy_hat() <span class="op">{}</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> move_player(num_spaces<span class="op">:</span> <span class="dt">u8</span>) <span class="op">{}</span></span></code></pre></div>
<hr/>
<h3 id="concise-control-flow-with-if-let">Concise Control Flow with if
let</h3>
<ol type="1">
<li>The <strong><code>if let</code></strong> syntax lets you into a less
verbose way to handle match while ignoring thr rest.</li>
</ol>
<div class="sourceCode" id="cb78"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> config_max <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">3u8</span>)<span class="op">;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> config_max <span class="op">{</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(max) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;The maximum is configured to be {max}&quot;</span>)<span class="op">,</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> ()<span class="op">,</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> config_max <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">3u8</span>)<span class="op">;</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(max) <span class="op">=</span> config_max <span class="op">{</span></span>
<span id="cb78-12"><a href="#cb78-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;The maximum is configured to be {max}&quot;</span>)<span class="op">;</span></span>
<span id="cb78-13"><a href="#cb78-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>We can include an <strong><code>else</code></strong> with an
<strong><code>if let</code></strong>.<br />
The block of code that goes with the <strong><code>else</code></strong>
is the same as the block of code that would go with the <code>_</code>
case in the <strong><code>match</code></strong> expression.</li>
</ol>
<div class="sourceCode" id="cb79"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> coin <span class="op">{</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Coin::</span>Quarter(state) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;A quarter from {state:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> count <span class="op">+=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">let</span> <span class="pp">Coin::</span>Quarter(state) <span class="op">=</span> coin <span class="op">{</span></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;A quarter from {state:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>Naturally there is <strong><code>else if let</code></strong>
also!</li>
</ol>
<div class="sourceCode" id="cb80"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> coin <span class="op">{</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Coin::</span>Quarter(state) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;A quarter from {state:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Coin::</span>Dime <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;It&#39;s a dime!&quot;</span>)<span class="op">,</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> count <span class="op">+=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">let</span> <span class="pp">Coin::</span>Quarter(state) <span class="op">=</span> <span class="op">&amp;</span>coin <span class="op">{</span></span>
<span id="cb80-13"><a href="#cb80-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;A quarter from {state:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb80-14"><a href="#cb80-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">let</span> <span class="pp">Coin::</span>Dime <span class="op">=</span> <span class="op">&amp;</span>coin <span class="op">{</span></span>
<span id="cb80-15"><a href="#cb80-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;It&#39;s a dime!&quot;</span>)<span class="op">;</span></span>
<span id="cb80-16"><a href="#cb80-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb80-17"><a href="#cb80-17" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb80-18"><a href="#cb80-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb80-19"><a href="#cb80-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-20"><a href="#cb80-20" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<hr/>
<h3 id="project-management">Project Management</h3>
<ol type="1">
<li>Rust has a number of features that allow you to manage your code‚Äôs
organization,<br />
including which details are exposed, which details are private, and what
names are in each scope in your programs.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>These features, sometimes collectively referred to as the
<strong><em>module system</em></strong>, include:</p>
<ul>
<li><strong><code>package</code></strong>
<ul>
<li>A Cargo feature that lets you build, test, and share crates.</li>
</ul></li>
<li><strong><code>crate</code></strong>
<ul>
<li>A tree of modules that produces a library or executable.</li>
</ul></li>
<li><strong><code>module</code></strong> and
<strong><code>use</code></strong>
<ul>
<li>Let you control the organization, scope, and privacy of paths.</li>
</ul></li>
<li><strong><code>path</code></strong>
<ul>
<li>A way of naming an item, such as a
<strong><em>structure</em></strong>, <strong><em>function</em></strong>,
or <strong><em>module</em></strong>.</li>
</ul></li>
</ul></li>
</ol>
<hr/>
<h3 id="packages-and-crates">Packages and Crates</h3>
<ol type="1">
<li><p>A <strong><code>crate</code></strong> is the smallest amount of
code that the Rust compiler considers at a time.<br />
Even if you run <strong><code>rustc</code></strong> rather than
<strong><code>cargo</code></strong> and pass a single source code file,
the compiler considers that file to be a
<strong><code>crate</code></strong>.</p>
<p>Crates can contain modules, and the modules may be defined in other
files that get compiled with the crate,<br />
as we‚Äôll see in the coming sections.</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>A <code>crate</code> can come in one of two forms: a
<strong><em>binary crate</em></strong> or a <strong><em>library
crate</em></strong>.</p>
<ul>
<li><strong><em>Binary crates</em></strong>
<ul>
<li>Programs you can compile to an executable that you can run, such as
a command-line program or a server.</li>
<li>Each must have a function called
<strong><code>main()</code></strong> that defines what happens when the
executable runs.</li>
<li>All the crates we‚Äôve created so far have been <strong><em>binary
crates</em></strong>.</li>
</ul></li>
<li><strong><em>Library crates</em></strong>
<ul>
<li>Do <code>NOT</code> have a <strong><code>main()</code></strong>
function, and they don‚Äôt compile to an executable.</li>
<li>Instead, they define functionality intended to be shared with
multiple projects.</li>
<li>For example, the <em>rand</em> crate we used in Chapter 2 provides
functionality that generates random numbers.<br />
</li>
<li>Most of the time when Rust users say
<strong><code>crate</code></strong>, they mean <strong><em>library
crate</em></strong>,<br />
and they use <strong><code>crate</code></strong> interchangeably with
the general programming concept of a
<strong><code>library</code></strong>.</li>
</ul></li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>The <strong><em>crate root</em></strong> is a source file that the
Rust compiler starts from,<br />
and makes up the <strong><em>root</em></strong> <code>module</code> of
your crate.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>A <strong><code>package</code></strong> is a bundle of one or
more <em>crates</em> that provides a set of functionality.<br />
A package contains a <code>Cargo.toml</code> file that describes how to
build those crates.<br />
<code>Cargo</code> is actually a <code>package</code> that contains the
<em>binary crate</em> for the command-line tool you‚Äôve been using to
build your code. The <code>Cargo</code> package also contains a
<em>library crate</em> that the <em>binary crate</em> depends on.</p>
<p>Other projects can depend on the <code>Cargo</code> <em>library
crate</em> to use the same logic the Cargo command-line tool
uses.</p></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>A <code>crate</code> can come in one of two forms: a <em>binary
crate</em> or a <em>library crate</em>.<br />
A <code>package</code> can contain as many <em>binary crates</em> as you
like, but at most ONLY ONE <em>library crate</em>.<br />
A <code>package</code> must contain at least ONE crate, whether that‚Äôs a
<em>library</em> or <em>binary</em> crate.</li>
</ol>
<hr/>
<h3 id="a-walkthrough-of-what-happens-when-we-create-a-package">A
Walkthrough of What Happens When We Create a Package</h3>
<ol type="1">
<li>First we enter the command <code>cargo new my-project</code>.</li>
</ol>
<div class="sourceCode" id="cb81"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new my-project</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Created</span> binary <span class="op">(application)</span> <span class="kw">`</span><span class="ex">my-project</span><span class="kw">`</span> package</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> ls my-project</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Cargo.toml</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">src</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> ls my-project/src</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">main.rs</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>In the project directory, there‚Äôs a <code>Cargo.toml</code> file,
giving us a <code>package</code>.<br />
There‚Äôs also a <code>src/</code> directory that contains
<code>main.rs</code>.<br />
Open <code>Cargo.toml</code> in your text editor, and note there‚Äôs no
mention of <code>src/main.rs</code>.<br />
Cargo follows a convention that <code>src/main.rs</code> is the
<em>crate root</em> of a <em>binary crate</em> with the same name as the
package.<br />
Likewise, Cargo knows that if the package directory contains
<code>src/lib.rs</code>,<br />
the package contains a <em>library crate</em> with the same name as the
package, and <code>src/lib.rs</code> is its <em>crate root</em>.<br />
Cargo passes the <em>crate root</em> files to <code>rustc</code> to
build the <em>library</em> or <em>binary</em>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Here, we have a package that only contains <code>src/main.rs</code>,
meaning it only contains a <em>binary crate</em> named
<code>my-project</code>.<br />
If a package contains <code>src/main.rs</code> and
<code>src/lib.rs</code>, it has two crates, a <em>binary</em> and a
<em>library</em>, both with the same name as the package.<br />
A package can have <em>multiple</em> binary crates by placing files in
the <code>src/bin/</code> directory, each file will be a separate binary
crate.<br />
</li>
</ol>
<hr/>
<h3 id="defining-modules-to-control-scope-and-privacy">Defining Modules
to Control Scope and Privacy</h3>
<ol type="1">
<li>When compiling a crate,<br />
the compiler first looks in the crate root file (usually
<strong><code>src/lib.rs</code></strong> for a <strong><em>library
crate</em></strong> or <strong><code>src/main.rs</code></strong> for a
<strong><em>binary crate</em></strong>).</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The <strong><em>crate root</em></strong> in Rust is the source file
that serves as the entry point for a Rust
<strong><code>crate</code></strong>,<br />
and it forms the root of the module tree for that crate.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>In the <strong><em>crate root</em></strong> file, you can declare
new <strong><em>modules</em></strong>.<br />
Let‚Äôs say you declare a <em><code>garden</code></em> module with
<code>mod garden;</code>.<br />
The compiler will look for the module‚Äôs code in these places:
<ul>
<li>Inline, within curly brackets that replace the semicolon
(<code>;</code>) following
<strong><code>mod garden</code></strong>.</li>
<li>In the file <strong><code>src/garden.rs</code></strong></li>
<li>In the file <strong><code>src/garden/mod.rs</code></strong></li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>In any file other than the <strong><em>crate root</em></strong>, you
can declare <strong><em>submodules</em></strong>.<br />
For example, you might declare <code>mod vegetables;</code> in
<code>src/garden.rs</code>.<br />
The compiler will look for the submodule‚Äôs code within the directory
named for the parent module in these places:
<ul>
<li>Inline, directly following <code>mod vegetables</code>, within curly
brackets instead of the semicolon (<code>;</code>).</li>
<li>In the file
<strong><code>src/garden/vegetables.rs</code></strong></li>
<li>In the file
<strong><code>src/garden/vegetables/mod.rs</code></strong></li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>Once a module is part of your crate, you can refer to code in that
module from anywhere else in that same crate,<br />
as long as the privacy rules allow, using the path to the code.<br />
For example, an <em><code>Asparagus</code></em> type in the
<em><code>garden vegetables</code></em> module would be found at
<em><code>crate::garden::vegetables::Asparagus</code></em>.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li><p>Code within a module is <strong><em>private</em></strong> by
default,<br />
meaning it can NOT be accessed from outside that module, inclduing
parent module.<br />
But child modules can access its parent‚Äôs any item even private items
freely.<br />
But if a parent wants to access child‚Äôs item, only the item needs to be
<strong><em>public</em></strong>, the child module could remain
<strong><em>private</em></strong>.<br />
Sibling modules could access each other‚Äôs items as long as the items are
<strong><code>pub</code></strong>, no need for the modules to be
<strong><em>public</em></strong>.<br />
To make a module <strong><em>public</em></strong>, declare it with
<strong><code>pub mod</code></strong> instead of
<strong><code>mod</code></strong>.</p>
<p>Items inside a <strong><code>pub mod</code></strong> is still
private,<br />
to make items within a public module public as well, use
<strong><code>pub</code></strong> before their declarations.</p>
<p>To access a module‚Äôs elements (functions, structs, constants, etc.)
from outside,<br />
both the module itself and the items inside it must be made public</p>
<p>If you have a two-level module hierarchy, and you want to access the
child module and its items from outside,<br />
both the parent module and the child module must be public.</p></li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>Within a scope, the <strong><code>use</code></strong> keyword
creates shortcuts to items to reduce repetition of long paths.<br />
In any scope that can refer to
<em><code>crate::garden::vegetables::Asparagus</code></em>,<br />
you can create a shortcut with
<em><code>use crate::garden::vegetables::Asparagus;</code></em><br />
and from then on you only need to write <em><code>Asparagus</code></em>
to make use of that type in the scope.</li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>Consider following example:</li>
</ol>
<ul>
<li><strong>File Structure</strong>:</li>
</ul>
<pre class="dir"><code>        backyard/
        |---------- Cargo.lock
        |---------- Cargo.toml
        |---------- src/
                    |---------- garden/
                                    |---------- vegetables.rs
                    |---------- garden.rs
                    |---------- main.rs</code></pre>
<p><br />
</p>
<ul>
<li><strong><code>src/main.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb83"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::garden::vegetables::</span>Asparagus<span class="op">;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// To tell the compiler to include the code it finds in the `src/garden.rs`.</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">mod</span> garden<span class="op">;</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> plant <span class="op">=</span> Asparagus <span class="op">{};</span></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{plant:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li><strong><code>src/garden.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb84"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">// To tell the compiler to include the code in `src/garden/vegetables.rs` too.</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">mod</span> vegetables<span class="op">;</span></span></code></pre></div>
<ul>
<li><strong><code>src/garden/vegetables.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb85"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> Asparagus <span class="op">{}</span></span></code></pre></div>
<hr/>
<h3 id="grouping-related-code-in-modules">Grouping Related Code in
Modules</h3>
<ol type="1">
<li>Create a new library named <code>restaurant</code> by running
<strong><code>cargo new restaurant --lib</code></strong>.<br />
Then enter the code in <strong><code>src/lib.rs</code></strong> to
define some modules and function signatures.</li>
</ol>
<ul>
<li><strong><code>src/lib.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb86"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> seat_at_table() <span class="op">{}</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">mod</span> serving <span class="op">{</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> take_order() <span class="op">{}</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> serve_order() <span class="op">{}</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> handle_payment() <span class="op">{}</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-18"><a href="#cb86-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>We define a module with the <strong><code>mod</code></strong>
keyword followed by the name of the module.<br />
The body of the module then goes inside curly brackets.<br />
Inside modules, we can place other modules.<br />
Modules can also hold definitions for other items, such as structs,
enums, constants, traits and function etc.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Earlier, we mentioned that <strong><code>src/main.rs</code></strong>
and <strong><code>src/lib.rs</code></strong> are called
<strong><em>crate roots</em></strong>.<br />
The reason is that the contents of either of these two files form a
module named <strong><code>crate</code></strong> at the root of the
crate‚Äôs module structure, known as the <strong><em>module
tree</em></strong>.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Module tree for the <code>restaurant</code>:</li>
</ol>
<pre class="dir"><code>    crate
    |---------- front_of_house
                        |---------- hosting
                                    |---------- add_to_waitlist
                                    |---------- seat_at_table
                        |---------- serving
                                    |---------- take_order
                                    |---------- serve_order
                                    |---------- handle_payment</code></pre>
<hr/>
<h3 id="paths-for-referring-to-an-item-in-the-module-tree">Paths for
Referring to an Item in the Module Tree</h3>
<ol type="1">
<li>To call a function, we need to know its path.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>A path can take two forms:</p>
<p>An <strong><code>absolute path</code></strong> is the full path
starting from a <strong><em>crate root</em></strong>.<br />
For code from an external crate, the absolute path begins with the
<strong><em>crate name</em></strong>,<br />
and for code from the current crate, it starts with the literal
<strong><code>crate</code></strong>.</p>
<p>A <strong><code>relative path</code></strong> starts from the
<strong><em>current module</em></strong> and uses
<strong><code>self</code></strong>, <strong><code>super</code></strong>,
or an <em>identifier</em> in the current module.<br />
Both <em>absolute</em> and <em>relative</em> paths are followed by one
or more identifiers separated by double colons
(<strong><code>::</code></strong>).</p></li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>All the source code in your <strong><code>src/</code></strong>
directory of a project is part of the <strong><em>same
crate</em></strong>.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Top-level modules inside a crate (those declared in
<strong><code>main.rs</code></strong> or
<strong><code>lib.rs</code></strong> via
<strong><code>mod</code></strong>) are <strong><em>private</em></strong>
by default,<br />
but they are accessible to other modules <strong><em>within the same
crate</em></strong>.<br />
This means that sibling modules (like
<strong><code>main.rs</code></strong> and another top-level module
declared via <strong><code>mod</code></strong>)<br />
can access each other without needing to be marked
<strong><code>pub</code></strong>, but their items to be accessed needs
to be <strong><code>pub</code></strong>.<br />
This visibility extends throughout the crate internally.</li>
</ol>
<ul>
<li><strong><em>src/lib.rs</em></strong></li>
</ul>
<div class="sourceCode" id="cb88"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">pub</span> <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> start_hosting() <span class="op">{</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span><span class="pp">::hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> eat_at_restaurant() <span class="op">{</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Absolute path:</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">crate</span><span class="pp">::front_of_house::hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Relative path:</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>            <span class="pp">front_of_house::hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-20"><a href="#cb88-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-21"><a href="#cb88-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> back_of_house <span class="op">{</span></span>
<span id="cb88-22"><a href="#cb88-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> fix_incorrect_order() <span class="op">{</span></span>
<span id="cb88-23"><a href="#cb88-23" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span><span class="pp">::</span>prepare_ingradients()<span class="op">;</span></span>
<span id="cb88-24"><a href="#cb88-24" aria-hidden="true" tabindex="-1"></a>                cook_order()<span class="op">;</span></span>
<span id="cb88-25"><a href="#cb88-25" aria-hidden="true" tabindex="-1"></a>                <span class="kw">super</span><span class="pp">::</span>deliver_order()<span class="op">;</span></span>
<span id="cb88-26"><a href="#cb88-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb88-27"><a href="#cb88-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-28"><a href="#cb88-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> prepare_ingradients() <span class="op">{}</span></span>
<span id="cb88-29"><a href="#cb88-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-30"><a href="#cb88-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> cook_order() <span class="op">{}</span></span>
<span id="cb88-31"><a href="#cb88-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb88-32"><a href="#cb88-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-33"><a href="#cb88-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> deliver_order() <span class="op">{}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>You can bring paths into scope with the
<strong><code>use</code></strong> keyword.</li>
</ol>
<ul>
<li><strong><em>src/lib.rs</em></strong></li>
</ul>
<div class="sourceCode" id="cb89"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">pub</span> <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::customer::</span>eat_at_restaurant<span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> eat() <span class="op">{</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true" tabindex="-1"></a>                eat_at_fancy_restaurant()<span class="op">;</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::front_of_house::</span>hosting<span class="op">;</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> eat_at_restaurant() <span class="op">{</span></span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-18"><a href="#cb89-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-19"><a href="#cb89-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> customer <span class="op">{</span></span>
<span id="cb89-20"><a href="#cb89-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::front_of_house::</span>hosting<span class="op">;</span></span>
<span id="cb89-21"><a href="#cb89-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">fn</span> eat_at_fancy_restaurant() <span class="op">{</span></span>
<span id="cb89-22"><a href="#cb89-22" aria-hidden="true" tabindex="-1"></a>                <span class="pp">hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb89-23"><a href="#cb89-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb89-24"><a href="#cb89-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>You can also specify <strong><code>as</code></strong> with a new
local name, or alias, for the type.</li>
</ol>
<div class="sourceCode" id="cb90"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::io::</span><span class="dt">Result</span><span class="op">;</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> test() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::io::</span><span class="dt">Result</span> <span class="kw">as</span> IoResult<span class="op">;</span></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> test() <span class="op">-&gt;</span> IoResult<span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>When we bring a name into scope with the
<strong><code>use</code></strong> keyword, the name available in the new
scope is <strong><em>private</em></strong>.<br />
To enable the code that calls our code to refer to that name as if it
had been defined in that code‚Äôs scope, we can do
<strong><code>pub use</code></strong>.<br />
This technique is called <strong><em>re-exporting</em></strong>,<br />
because we‚Äôre bringing an item into scope but also making that item
available for others to bring into their scope.</li>
</ol>
<div class="sourceCode" id="cb91"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a>                <span class="kw">pub</span> <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Brings `hosting` into the current module scope.</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::front_of_house::</span>hosting<span class="op">;</span></span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> eat_at_restaurant() <span class="op">{</span></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">hosting::</span>add_to_waitlist()<span class="op">;</span> <span class="co">// Works here because of `use`.</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb91-15"><a href="#cb91-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-16"><a href="#cb91-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-17"><a href="#cb91-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb91-18"><a href="#cb91-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb91-19"><a href="#cb91-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb91-20"><a href="#cb91-20" aria-hidden="true" tabindex="-1"></a>                <span class="kw">pub</span> <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb91-21"><a href="#cb91-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb91-22"><a href="#cb91-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-23"><a href="#cb91-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Re-exports `hosting` module.</span></span>
<span id="cb91-24"><a href="#cb91-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::front_of_house::</span>hosting<span class="op">;</span></span>
<span id="cb91-25"><a href="#cb91-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-26"><a href="#cb91-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-27"><a href="#cb91-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> eat_at_restaurant() <span class="op">{</span></span>
<span id="cb91-28"><a href="#cb91-28" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Accessible because of `pub use`</span></span>
<span id="cb91-29"><a href="#cb91-29" aria-hidden="true" tabindex="-1"></a>            <span class="pp">hosting::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb91-30"><a href="#cb91-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb91-31"><a href="#cb91-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>NOTE that the <strong><code>pub use</code></strong> does not change
the privacy of the item it re-exports.</li>
<li>If the item being re-exported (like
<em><code>mod hosting</code></em> here) was not public,<br />
then even if you use <strong><code>pub use</code></strong>, it won‚Äôt
make that item accessible outside the module.</li>
</ul>
<p><br />
</p>
<ol start="8" type="1">
<li><strong><code>pub use</code></strong> is used to re-export items
from a module.<br />
This means that the item being re-exported can be accessed from the
outside,<br />
as if it were defined in the module where
<strong><code>pub use</code></strong> is applied, but only if the item
itself is already <strong><em>public</em></strong>.</li>
</ol>
<div class="sourceCode" id="cb92"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> front_of_house <span class="op">{</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">mod</span> hosting <span class="op">{</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>                <span class="kw">pub</span> <span class="kw">fn</span> add_to_waitlist() <span class="op">{}</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> <span class="kw">use</span> <span class="pp">hosting::</span>add_to_waitlist<span class="op">;</span></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">front_of_house::</span>add_to_waitlist()<span class="op">;</span></span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>If we‚Äôre using multiple items defined in the same crate or same
module,<br />
we can use nested paths to bring the same items into scope in one
line.</li>
</ol>
<div class="sourceCode" id="cb93"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::cmp::</span>Ordering<span class="op">;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::</span>io<span class="op">;</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::</span><span class="op">{</span><span class="pp">cmp::</span>Ordering<span class="op">,</span> io<span class="op">};</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::</span>io<span class="op">;</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::io::</span><span class="bu">Write</span><span class="op">;</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb93-15"><a href="#cb93-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Write</span><span class="op">};</span></span>
<span id="cb93-16"><a href="#cb93-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>If we want to bring <code>ALL</code>
<strong><em>public</em></strong> items defined in a path into
scope,<br />
we can specify that path followed by the <code>*</code> glob
operator:</li>
</ol>
<div class="sourceCode" id="cb94"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::collections::</span><span class="op">*;</span></span></code></pre></div>
<hr/>
<h3 id="storing-lists-of-values-with-vectors">Storing Lists of Values
with Vectors</h3>
<ol type="1">
<li>The first collection type we‚Äôll look at is
<strong><code>Vec&lt;T&gt;</code></strong>, also known as a
<strong><em>vector</em></strong>.<br />
Vectors allow you to store one or more value(s) in a single data
structure that puts all the values next to each other in memory.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Vectors can only store values of the <strong><em>same
type</em></strong>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To create a new empty vector, we call the
<strong><code>Vec::new()</code></strong> function.</li>
</ol>
<div class="sourceCode" id="cb95"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span></code></pre></div>
<ul>
<li><code>NOTE</code> we added a type annotation here, because we aren‚Äôt
inserting any values into this vector.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>More often, you want to create a
<strong><code>Vec&lt;T&gt;</code></strong> with initial values and Rust
will infer the type of value you want to store.<br />
Rust conveniently provides the <strong><code>vec!</code></strong>
macro,<br />
which will create a new vector that holds the values you give it.</li>
</ol>
<div class="sourceCode" id="cb96"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">// : Vec&lt;i32&gt;</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span> </span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>To add elements to a vector, we can use the
<strong><code>push()</code></strong> method.<br />
As with any variable, if we want to be able to change its value, we need
to make it mutable using the <strong><code>mut</code></strong>
keyword.</li>
</ol>
<div class="sourceCode" id="cb97"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push(<span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push(<span class="dv">30</span>)<span class="op">;</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push(<span class="dv">40</span>)<span class="op">;</span></span></code></pre></div>
<ul>
<li>The numbers we place inside are all of type
<strong><code>i32</code></strong>, and Rust infers this from the
data,<br />
so we do <code>NOT</code>need the
<strong><code>Vec&lt;i32&gt;</code></strong> annotation.</li>
</ul>
<p><br />
</p>
<ol start="6" type="1">
<li><p>There are <strong><code>2</code></strong> ways to reference a
value stored in a vector:</p>
<ul>
<li>via <strong><em>indexing</em></strong>.
<ul>
<li><strong><em>Indexing</em></strong> will cause the program to panic
if out of range.</li>
</ul></li>
<li>via the <strong><code>get()</code></strong> method go get an
<strong><code>Option&lt;T&gt;</code></strong>.</li>
</ul>
<div class="sourceCode" id="cb98"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> third<span class="op">:</span> <span class="op">&amp;</span><span class="dt">i32</span> <span class="op">=</span> <span class="op">&amp;</span>v[<span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The third element is {third}&quot;</span>)<span class="op">;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> third<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;&amp;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span> v<span class="op">.</span>get(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> third <span class="op">{</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(third) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;The third element is {third}&quot;</span>)<span class="op">,</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>        <span class="cn">None</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;There is no third element!&quot;</span>)<span class="op">,</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>But be care of the borrowing, the following code result in a
<strong><em>compile-time error</em></strong>:</p></li>
</ol>
<div class="sourceCode" id="cb99"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> first <span class="op">=</span> <span class="op">&amp;</span>v[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          - immutable borrow occurs here.</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>        v<span class="op">.</span>push(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">//^^^^^^^^ mutable borrow occurs here.</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The first elem is {first}&quot;</span>)<span class="op">;</span></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                          ------- immutale borrow later used here.</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>To access each element in a vector in turn, we would
<strong><em>iterate</em></strong> through all of the elements.</li>
</ol>
<div class="sourceCode" id="cb100"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span>]<span class="op">;</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// About dereferencing operator we&#39;ll talk in later chapters!</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="op">&amp;</span><span class="kw">mut</span> v <span class="op">{</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>i <span class="op">+=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This creates temporary immutable references for each element of the vector</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="op">&amp;</span>v <span class="op">{</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>If you do NOT use reference in iteration, after the iteration, the
vector is no longer valid.</li>
</ol>
<div class="sourceCode" id="cb101"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span>]<span class="op">;</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> v <span class="op">{</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// After the loop, {v} is moved thus no longer valid,</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// and also all its elements were moved too.</span></span></code></pre></div>
<hr/>
<h3 id="storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded
Text with Strings</h3>
<ol type="1">
<li>The <strong><code>String</code></strong> type,<br />
which is provided by Rust‚Äôs standard library rather than coded into the
core language,<br />
is a growable, mutable, owned, UTF-8 encoded string type.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>Many of the same operations available with
<strong><code>Vec&lt;T&gt;</code></strong> are available with
<strong><code>String</code></strong> as well,<br />
because <strong><code>String</code></strong> is actually implemented as
a wrapper around a vector of bytes, with some extra guarantees,
restrictions, and capabilities.</p>
<p>An example of a function that works the same way with
<strong><code>Vec&lt;T&gt;</code></strong> and
<strong><code>String</code></strong> is the
<strong><code>new()</code></strong> function to create an instance.</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span></code></pre></div></li>
</ol>
<ul>
<li>This line creates a new, empty string called
<strong><em>s</em></strong>, into which we can then load data.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>Often, we‚Äôll have some initial data with which we want to start the
string.<br />
For that, we use the <strong><code>to_string()</code></strong>
method,<br />
which is available on any type that implements the
<strong><code>Display</code></strong> trait, such as string literals
do.</li>
</ol>
<div class="sourceCode" id="cb103"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="st">&quot;words&quot;</span><span class="op">;</span>             <span class="co">// : &amp;str</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> data<span class="op">.</span>to_string()<span class="op">;</span>       <span class="co">// : String</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;words&quot;</span><span class="op">.</span>to_string()<span class="op">;</span>    <span class="co">// : String</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>A <strong><code>String</code></strong> can grow in size and its
contents can change, just like the contents of a
<strong><code>Vec&lt;T&gt;</code></strong>.<br />
In addition, you can conveniently use the
<strong><code>+</code></strong> operator or the
<strong><code>format!</code></strong> macro to concatenate
<strong><code>String</code></strong> values.</li>
</ol>
<div class="sourceCode" id="cb104"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The `+` operator can concatenate `String` and `&amp;str`.</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// fn add(self, &amp;str) -&gt; String { ... }</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// {s1} is moved, but {s2} remains accessible.</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// &amp;String -&gt; &amp;str is a deref coercion, like &amp;s2 == &amp;s2[..]</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s3 <span class="op">=</span> s1 <span class="op">+</span> <span class="op">&amp;</span>s2<span class="op">;</span></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s3}&quot;</span>)<span class="op">;</span>       <span class="co">// Hello, world!</span></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb104-15"><a href="#cb104-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;tic&quot;</span>)<span class="op">;</span></span>
<span id="cb104-16"><a href="#cb104-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;tac&quot;</span>)<span class="op">;</span></span>
<span id="cb104-17"><a href="#cb104-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s3 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;toe&quot;</span>)<span class="op">;</span></span>
<span id="cb104-18"><a href="#cb104-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-19"><a href="#cb104-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> s1 <span class="op">+</span> <span class="st">&quot; - &quot;</span> <span class="op">+</span> <span class="op">&amp;</span>s2 <span class="op">+</span> <span class="st">&quot; - &quot;</span> <span class="op">+</span> <span class="op">&amp;</span>s3<span class="op">;</span></span>
<span id="cb104-20"><a href="#cb104-20" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span>        <span class="co">// tic - tac - toe</span></span>
<span id="cb104-21"><a href="#cb104-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb104-22"><a href="#cb104-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-23"><a href="#cb104-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-24"><a href="#cb104-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb104-25"><a href="#cb104-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb104-26"><a href="#cb104-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb104-27"><a href="#cb104-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-28"><a href="#cb104-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// {s1} and {s2} are not moved.</span></span>
<span id="cb104-29"><a href="#cb104-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s3 <span class="op">=</span> <span class="pp">format!</span>(<span class="st">&quot;{}{}&quot;</span><span class="op">,</span> s1<span class="op">,</span> s2)<span class="op">;</span></span>
<span id="cb104-30"><a href="#cb104-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-31"><a href="#cb104-31" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s1)<span class="op">;</span></span>
<span id="cb104-32"><a href="#cb104-32" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s2)<span class="op">;</span></span>
<span id="cb104-33"><a href="#cb104-33" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s3)<span class="op">;</span></span>
<span id="cb104-34"><a href="#cb104-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>We also can grow a <code>String</code> by using the
<code>push_str()</code> method to append a string slice.<br />
And the <code>push()</code> method takes a single <code>char</code> as
parameter.</li>
</ol>
<div class="sourceCode" id="cb105"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;foo&quot;</span>)<span class="op">;</span></span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push_str(<span class="st">&quot;bar&quot;</span>)<span class="op">;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;foo&quot;</span>)<span class="op">;</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s2 <span class="op">=</span> <span class="st">&quot;bar&quot;</span><span class="op">;</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a>        s1<span class="op">.</span>push_str(s2)<span class="op">;</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// {s2} is still valid, because it is a string slice.</span></span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s2}&quot;</span>)<span class="op">;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(<span class="ch">&#39;l&#39;</span>)<span class="op">;</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(<span class="ch">&#39;o&#39;</span>)<span class="op">;</span></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(<span class="ch">&#39;l&#39;</span>)<span class="op">;</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span>    <span class="co">// -&gt; lol</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> ch <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span></span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push(ch)<span class="op">;</span>         <span class="co">// {ch} is still valid, because it implements `Copy`</span></span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span>    <span class="co">// -&gt; A</span></span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{ch}&quot;</span>)<span class="op">;</span>   <span class="co">// -&gt; A</span></span>
<span id="cb105-27"><a href="#cb105-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Internally, a <strong><code>String</code></strong> is a wrapper over
a <strong><code>Vec&lt;u8&gt;</code></strong>.</li>
</ol>
<div class="sourceCode" id="cb106"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> hello <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hejo&quot;</span>)<span class="op">;</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> len <span class="op">=</span> hello<span class="op">.</span>len()<span class="op">;</span></span></code></pre></div>
<ul>
<li>In this case, <strong><em>len</em></strong> will be
<strong><code>4</code></strong>, which means the vector storing the
string <strong><em><code>"Hejo"</code></em></strong> is
<strong><code>4</code></strong> bytes long.</li>
</ul>
<p><br />
</p>
<ol start="7" type="1">
<li>Here we might think the following len is
<strong><code>12</code></strong>:</li>
</ol>
<div class="sourceCode" id="cb107"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> hello <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;</span>)<span class="op">;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> len <span class="op">=</span> hello<span class="op">.</span>len()<span class="op">;</span></span></code></pre></div>
<ul>
<li>But the Rust‚Äôs answer is <strong><code>24</code></strong>!</li>
<li>That‚Äôs the number of bytes it takes to encode
<strong><code>"–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ"</code></strong> in
<code>UTF-8</code>,<br />
because each Unicode scalar value in that string takes
<strong><code>2</code></strong> bytes of storage.</li>
</ul>
<p><br />
</p>
<ol start="8" type="1">
<li>Therefore, an index into the string‚Äôs bytes will not always
correlate to a valid Unicode scalar value.<br />
To demonstrate, consider this invalid Rust code:</li>
</ol>
<div class="sourceCode" id="cb108"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> hello <span class="op">=</span> <span class="st">&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;</span><span class="op">;</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> answer <span class="op">=</span> <span class="op">&amp;</span>hello[<span class="dv">0</span>]<span class="op">;</span></span></code></pre></div>
<ul>
<li>You already know that answer will not be
<strong><code>–ó</code></strong>, the first letter.<br />
</li>
<li>When encoded in <code>UTF-8</code>, the first byte of
<strong><code>–ó</code></strong> is <strong><code>208</code></strong> and
the second is <strong><code>151</code></strong>,<br />
so it would seem that answer should in fact be
<strong><code>208</code></strong>, but <strong><code>208</code></strong>
is not a valid character on its own.</li>
<li>Returning <strong><code>208</code></strong> is likely not what a
user would want if they asked for the first letter of this string.<br />
However, that‚Äôs the only data that Rust has at <strong><em>byte index
0</em></strong>.<br />
Users generally don‚Äôt want the byte value returned, even if the string
contains only Latin letters.</li>
</ul>
<p><br />
</p>
<ol start="9" type="1">
<li>Rather than indexing using <strong><code>[]</code></strong> with a
single number,<br />
you can use <strong><code>[]</code></strong> with a range to create a
string slice containing particular bytes:</li>
</ol>
<div class="sourceCode" id="cb109"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> hello <span class="op">=</span> <span class="st">&quot;–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ&quot;</span><span class="op">;</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> <span class="op">&amp;</span>hello[<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]<span class="op">;</span></span></code></pre></div>
<ul>
<li>Here, <strong><em>s</em></strong> will be a
<strong><code>&amp;str</code></strong> that contains the first four
bytes of the string.<br />
Earlier, we mentioned that each of these characters was two bytes, which
means s will be <strong><code>–ó–¥</code></strong>.</li>
</ul>
<p><br />
</p>
<ol start="10" type="1">
<li>Also, If we were to try to slice only part of a character‚Äôs bytes
with something like
<strong><code>&amp;hello[0..1]</code></strong>,<br />
Rust would <strong><em>panic at runtime</em></strong> in the same way as
if an invalid index were accessed in a vector.</li>
</ol>
<p><br />
</p>
<ol start="11" type="1">
<li>For individual Unicode scalar values, use the
<strong><code>chars()</code></strong> method.<br />
Calling it on <strong><code>"–ó–¥"</code></strong> separates out and
returns two values of type <strong><code>char</code></strong>, and you
can iterate over the result to access each element:</li>
</ol>
<div class="sourceCode" id="cb110"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ch <span class="kw">in</span> <span class="st">&quot;–ó–¥&quot;</span><span class="op">.</span>chars() <span class="op">{</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{ch}&quot;</span>)<span class="op">;</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; –ó</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; –¥</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="12" type="1">
<li>Alternatively, the <strong><code>bytes()</code></strong> method
returns each raw byte, which might be appropriate for your domain:</li>
</ol>
<div class="sourceCode" id="cb111"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> b <span class="kw">in</span> <span class="st">&quot;–ó–¥&quot;</span><span class="op">.</span>bytes() <span class="op">{</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{b}&quot;</span>)<span class="op">;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; 208</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; 151</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; 208</span></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; 180</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="hash-maps">Hash Maps</h3>
<ol type="1">
<li>The last of our common collections is the hash map.<br />
The type <strong><code>HashMap&lt;K, V&gt;</code></strong> stores a
mapping of <strong><em>keys</em></strong> of type <strong>K</strong> to
<strong><em>values</em></strong> of type <strong>V</strong> using a
hashing function.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Hash maps are useful when you want to look up data not by using an
index,<br />
as you can with vectors, but by using a <strong><em>key</em></strong>
that can be of any type.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>One way to create an empty hash map is to use
<strong><code>new()</code></strong> and to add elements with
<strong><code>insert()</code></strong>:</li>
</ol>
<div class="sourceCode" id="cb112"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> scores <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Yellow&quot;</span>)<span class="op">,</span> <span class="dv">50</span>)<span class="op">;</span></span></code></pre></div>
<ul>
<li>Like vectors, hash maps are homogeneous:<br />
all of the keys must have the <strong><em>same type</em></strong>, and
all of the values must have the <strong><em>same
type</em></strong>.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>We can get a value out of the hash map by providing its key to the
<strong><code>get( )</code></strong> method.</li>
</ol>
<div class="sourceCode" id="cb113"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> scores <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Yellow&quot;</span>)<span class="op">,</span> <span class="dv">50</span>)<span class="op">;</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> team_name <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">;</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> score <span class="op">=</span> scores</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>get(<span class="op">&amp;</span>team_name)    <span class="co">// : Option&lt;&amp;V&gt;</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>copied()           <span class="co">// : Option&lt;V&gt;</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>unwrap_or(<span class="dv">0</span>)<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>We can iterate over each <strong><em>key</em></strong> /
<strong><em>value</em></strong> pair in a hash map in a similar manner
as we do with vectors,<br />
using a <strong><code>for</code></strong> loop:</li>
</ol>
<div class="sourceCode" id="cb114"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> scores <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Yellow&quot;</span>)<span class="op">,</span> <span class="dv">50</span>)<span class="op">;</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// key: &amp;String</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// value: &amp;i32</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> (key<span class="op">,</span> value) <span class="kw">in</span> <span class="op">&amp;</span>scores <span class="op">{</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{key}: {value}&quot;</span>)<span class="op">;</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>For types that implement the <strong><code>Copy</code></strong>
trait, like <strong><code>i32</code></strong>, the values are
<strong><em>copied</em></strong> into the hash map.<br />
For owned values like <strong><code>String</code></strong>, the values
will be moved and the hash map will be the owner of those values.</li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>If we insert a <strong><em>key</em></strong> and a
<strong><em>value</em></strong> into a hash map and then insert that
<strong><em>same key</em></strong> with a <strong><em>different
value</em></strong>,<br />
the value associated with that key will be
<strong><em>replaced</em></strong>.</li>
</ol>
<div class="sourceCode" id="cb115"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> scores <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>        scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">25</span>)<span class="op">;</span></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> scores)<span class="op">;</span>   <span class="co">// -&gt; {&quot;Blue&quot;: 25}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>Hash maps have a special API called
<strong><code>entry( )</code></strong> that takes the
<strong><em>key</em></strong> you want to check as a parameter.<br />
The return value of the <strong><code>entry( )</code></strong> method is
an <strong><code>enum</code></strong> called
<strong><code>Entry</code></strong> that represents a value that might
or might not exist.</li>
</ol>
<div class="sourceCode" id="cb116"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> scores <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>            scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>            scores</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>entry(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Yellow&quot;</span>))</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>or_insert(<span class="dv">50</span>)<span class="op">;</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>            scores</span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>entry(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>))</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>or_insert(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> scores)<span class="op">;</span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// -&gt; {&quot;Blue&quot;: 10, &quot;Yellow&quot;: 50}</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>Another common use case for hash maps is to look up a key‚Äôs value
and then update it based on the old value.</li>
</ol>
<div class="sourceCode" id="cb117"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> text <span class="op">=</span> <span class="st">&quot;hello world wonderful world&quot;</span><span class="op">;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> map <span class="op">=</span> <span class="pp">HashMap::</span>new()<span class="op">;</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> word <span class="kw">in</span> text<span class="op">.</span>split_whitespace() <span class="op">{</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> count <span class="op">=</span> map</span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span>entry(word)</span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span>or_insert(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> map)<span class="op">;</span>      <span class="co">// -&gt; {&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</span></span>
<span id="cb117-16"><a href="#cb117-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>The <strong><code>or_insert()</code></strong> method returns a
mutable reference (<strong><code>&amp;mut V</code></strong>) to the
value for the specified key.</li>
</ul>
<p><br />
</p>
<ol start="10" type="1">
<li><p>By default, <strong><code>HashMap</code></strong> uses a hashing
function called <strong><code>SipHash()</code></strong><br />
that can provide resistance to denial-of-service (DoS) attacks involving
hash tables.</p>
<p>This is NOT the fastest hashing algorithm available,<br />
but the trade-off for better security that comes with the drop in
performance is worth it.</p>
<p>If you profile your code and find that the default hash function is
too slow for your purposes,<br />
you can switch to another function by specifying a different
<strong><em>hasher</em></strong>.<br />
A <strong><em>hasher</em></strong> is a type that implements the
<strong><code>BuildHasher</code></strong> trait.</p>
<p>We‚Äôll talk about traits and how to implement them in later
chapters!</p></li>
</ol>
<ul>
<li><strong><em>Cargo.toml</em></strong></li>
</ul>
<div class="sourceCode" id="cb118"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[dependencies]</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">fxhash</span> <span class="op">=</span> <span class="st">&quot;0.2&quot;</span></span></code></pre></div>
<ul>
<li><strong><em>./src/main.rs</em></strong></li>
</ul>
<div class="sourceCode" id="cb119"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">fxhash::</span>FxBuildHasher<span class="op">;</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> scores</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">:</span> HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> FxBuildHasher<span class="op">&gt;</span></span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">=</span> <span class="pp">HashMap::</span>with_hasher(<span class="pp">FxBuildHasher::</span><span class="kw">default</span>())<span class="op">;</span></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>            scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Blue&quot;</span>)<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>            scores<span class="op">.</span>insert(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Yellow&quot;</span>)<span class="op">,</span> <span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> (team<span class="op">,</span> score) <span class="kw">in</span> <span class="op">&amp;</span>scores <span class="op">{</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;{}: {}&quot;</span><span class="op">,</span> team<span class="op">,</span> score)<span class="op">;</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="error-handling">Error Handling</h3>
<ol type="1">
<li>Rust groups errors into two major categories:
<strong><em>recoverable</em></strong> and
<strong><em>unrecoverable</em></strong> errors.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>For a recoverable error, such as a <strong><em>file not
found</em></strong> error,<br />
we most likely just want to report the problem to the user and retry the
operation.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Unrecoverable errors are always symptoms of bugs,<br />
such as trying to access a location beyond the end of an array, and so
we want to immediately stop the program.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>Most languages don‚Äôt distinguish between these two kinds of
errors and handle both in the same way,<br />
using mechanisms such as exceptions.</p>
<p>Rust does NOT have exceptions.<br />
Instead, it has the type
<strong><code>Result&lt;T, E&gt;</code></strong> for recoverable
errors,<br />
and the <strong><code>panic!</code></strong> macro that stops execution
when the program encounters an unrecoverable error.</p></li>
</ol>
<hr/>
<h3 id="unrecoverable-errors-with-panic">Unrecoverable Errors with
<code>panic!</code></h3>
<ol type="1">
<li>There are <strong><code>2</code></strong> ways to cause a panic in
practice:
<ul>
<li>by taking an action that causes our code to panic (such as accessing
an array past the end).</li>
<li>by explicitly calling the <strong><code>panic!</code></strong> macro
directly.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>By default, these panics will print a failure message, unwind, clean
up the stack, and quit.<br />
Via an environment variable, you can also have Rust display the call
stack when a panic occurs to make it easier to track down the source of
the panic.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li><p>By default, when a panic occurs the program starts
unwinding,<br />
which means Rust walks back up the stack and cleans up the data from
each function it encounters.</p>
<p>However, walking back and cleaning up is a lot of work.<br />
Rust, therefore, allows you to choose the alternative of immediately
aborting, which ends the program without cleaning up.</p>
<p>Remember that the program was using will then need to be cleaned up
by the OS.<br />
If in your project you need to make the resultant binary as small as
possible,<br />
you can switch from unwinding to aborting upon a panic by adding
<strong><code>panic='abort'</code></strong> to the appropriate
<strong><code>[profile]</code></strong> sections in your
<strong><code>Cargo.toml</code></strong> file.</p>
<p>For example, if you want to abort on panic in
<strong><em>release</em></strong> mode, add this:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[profile.release]</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="dt">panic</span><span class="op">=</span><span class="st">&#39;</span><span class="vs">abort</span><span class="st">&#39;</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Let‚Äôs firstly try calling <strong><code>panic!</code></strong> in
a simple program:</p></li>
</ol>
<div class="sourceCode" id="cb121"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>            <span class="pp">panic!</span>(<span class="st">&quot;Crash and burn!&quot;</span>)<span class="op">;</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>We can set the <strong><code>RUST_BACKTRACE</code></strong>
environment variable to <strong><code>1</code></strong> to get a
<strong><em>backtrace</em></strong> of exactly what happened to cause
the error.<br />
A <strong><em>backtrace</em></strong> is a list of all the functions
that have been called to get to this point.</li>
</ol>
<div class="sourceCode" id="cb122"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>        <span class="bu">export</span> <span class="va">RUST_BACKTRACE</span><span class="op">=</span>1</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>        <span class="ex">cargo</span> run</span></code></pre></div>
<hr/>
<h3 id="recoverable-errors-with-resultt-e">Recoverable Errors with
<code>Result&lt;T, E&gt;</code></h3>
<ol type="1">
<li>The <strong><code>Result&lt;T, E&gt;</code></strong> enum is defined
as having two variants, <strong><code>Ok(T)</code></strong> and
<strong><code>Err(E)</code></strong>, as follows:</li>
</ol>
<div class="sourceCode" id="cb123"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> E<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(T)<span class="op">,</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(E)<span class="op">,</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>The <strong><code>T</code></strong> and
<strong><code>E</code></strong> are generic type parameters.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li>Example Usage <code>1</code>:</li>
</ol>
<div class="sourceCode" id="cb124"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file_result <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">;</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="cf">match</span> greeting_file_result <span class="op">{</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(file)    <span class="op">=&gt;</span> file<span class="op">,</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(error)  <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Problem while opening the file: {error:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file_result <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">;</span></span>
<span id="cb124-16"><a href="#cb124-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-17"><a href="#cb124-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="cf">match</span> greeting_file_result <span class="op">{</span></span>
<span id="cb124-18"><a href="#cb124-18" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(file) <span class="op">=&gt;</span> file<span class="op">,</span></span>
<span id="cb124-19"><a href="#cb124-19" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(error) <span class="op">=&gt;</span> <span class="cf">match</span> error<span class="op">.</span>kind() <span class="op">{</span></span>
<span id="cb124-20"><a href="#cb124-20" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ErrorKind::</span>NotFound <span class="op">=&gt;</span> <span class="cf">match</span> <span class="pp">File::</span>create(<span class="st">&quot;hello.txt&quot;</span>) <span class="op">{</span></span>
<span id="cb124-21"><a href="#cb124-21" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Ok</span>(fc) <span class="op">=&gt;</span> fc<span class="op">,</span></span>
<span id="cb124-22"><a href="#cb124-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="pp">panic!</span>(<span class="st">&quot;Problem creating the file: {e:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb124-23"><a href="#cb124-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb124-24"><a href="#cb124-24" aria-hidden="true" tabindex="-1"></a>                other_error <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb124-25"><a href="#cb124-25" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">panic!</span>(<span class="st">&quot;Problem opening the file: {other_error:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb124-26"><a href="#cb124-26" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb124-27"><a href="#cb124-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb124-28"><a href="#cb124-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb124-29"><a href="#cb124-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb124-30"><a href="#cb124-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-31"><a href="#cb124-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-32"><a href="#cb124-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb124-33"><a href="#cb124-33" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span></span>
<span id="cb124-34"><a href="#cb124-34" aria-hidden="true" tabindex="-1"></a>            <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>) <span class="op">.</span>unwrap_or_else(<span class="op">|</span>error<span class="op">|</span> <span class="op">{</span></span>
<span id="cb124-35"><a href="#cb124-35" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> error<span class="op">.</span>kind() <span class="op">==</span> <span class="pp">ErrorKind::</span>NotFound <span class="op">{</span></span>
<span id="cb124-36"><a href="#cb124-36" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">File::</span>create(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">.</span>unwrap_or_else(<span class="op">|</span>error<span class="op">|</span> <span class="op">{</span></span>
<span id="cb124-37"><a href="#cb124-37" aria-hidden="true" tabindex="-1"></a>                        <span class="pp">panic!</span>(<span class="st">&quot;Problem creating the file: {error:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb124-38"><a href="#cb124-38" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span>)</span>
<span id="cb124-39"><a href="#cb124-39" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb124-40"><a href="#cb124-40" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">panic!</span>(<span class="st">&quot;Problem opening the file: {error:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb124-41"><a href="#cb124-41" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb124-42"><a href="#cb124-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb124-43"><a href="#cb124-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li><p>Using <strong><code>match</code></strong> works well enough, but
it can be a bit verbose and does NOT always communicate intent well.</p>
<p>If the <strong><code>Result</code></strong> value is the
<strong><code>Ok</code></strong> variant,
<strong><code>unwrap()</code></strong> will return the value inside the
<strong><code>Ok</code></strong>.<br />
If the Result is the <strong><code>Err</code></strong> variant,
<strong><code>unwrap()</code></strong> will call the
<strong><code>panic!</code></strong> macro for us:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Similarly, the <strong><code>expect()</code></strong> method lets
us also choose the <strong><code>panic!</code></strong> error
message:</p></li>
</ol>
<div class="sourceCode" id="cb126"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">.</span>expect(<span class="st">&quot;hello.txt NOT found!&quot;</span>)<span class="op">;</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li><p>When a function‚Äôs implementation calls something that might
fail,<br />
instead of handling the error within the function itself you can return
the error to the calling code so that it can decide what to do.</p>
<p>This is known as <strong><em>propagating</em></strong> the error and
gives more control to the calling code,<br />
where there might be more information or logic that dictates how the
error should be handled than what you have available in the context of
your code.</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Read</span><span class="op">};</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> read_user_name_from_file() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> username_file <span class="op">=</span> <span class="cf">match</span> <span class="pp">File::</span>open(<span class="st">&quot;user.txt&quot;</span>) <span class="op">{</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(file) <span class="op">=&gt;</span> file<span class="op">,</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e)   <span class="op">=&gt;</span> <span class="cf">return</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> username <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> username_file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> username) <span class="op">{</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(_) <span class="op">=&gt;</span> <span class="cn">Ok</span>(username)<span class="op">,</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="cn">Err</span>(e)<span class="op">,</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>There is a shortcut for propagating errors via the (
<strong><code>?</code></strong> ) operator.:</p>
<ul>
<li>If the value is an <strong><code>Ok</code></strong>, the value
inside the <strong><code>Ok</code></strong> will get returned.<br />
</li>
<li>If the value is an <strong><code>Err</code></strong>, the
<strong><code>Err</code></strong> will be returned from the
function,<br />
as if we had used the <strong><code>return</code></strong> keyword so
the error value gets propagated to the calling code.</li>
</ul>
<div class="sourceCode" id="cb128"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Read</span><span class="op">};</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> read_user_name_from_file() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> username_file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;user.txt&quot;</span>)<span class="op">?;</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> username <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>        username_file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> username)<span class="op">?;</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(username)</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>There is a difference between what the
<strong><code>match</code></strong> expression does and what the (
<strong><code>?</code></strong> ) operator does.<br />
Error values that have the ( <strong><code>?</code></strong> ) operator
called on them go through the <strong><code>from()</code></strong>
function,<br />
defined in the <strong><code>From</code></strong> trait in the standard
library, which is used to convert values from one type into another.</p>
<p>When the ( <strong><code>?</code></strong> ) operator calls the
<strong><code>from()</code></strong> function,<br />
the error type received is converted into the error type defined in the
return type of the current function.<br />
This is useful when a function returns one error type to represent all
the ways a function might fail,<br />
even if parts might fail for many different reasons.</p>
<p>For example, we could change the
<code>read_username_from_file()</code> function to return a custom error
type named <code>OurError</code> that we define.<br />
If we also define
<strong><code>impl From&lt;io::Error&gt; for OurError</code></strong> to
construct an instance of <code>OurError</code> from an
<code>io::Error</code>.</p></li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>The ( <strong><code>?</code></strong> ) operator eliminates a lot of
boilerplate and makes this function‚Äôs implementation simpler.<br />
We could even shorten this code further by chaining method calls
immediately after the ( <strong><code>?</code></strong> ).</li>
</ol>
<div class="sourceCode" id="cb129"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Read</span><span class="op">};</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> read_user_name_from_file() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="pp">io::</span><span class="bu">Error</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> username <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">File::</span>open(<span class="st">&quot;user.txt&quot;</span>)<span class="op">?.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> username)<span class="op">?;</span></span>
<span id="cb129-8"><a href="#cb129-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-9"><a href="#cb129-9" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(username)</span>
<span id="cb129-10"><a href="#cb129-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>The ( <strong><code>?</code></strong> ) operator can only be used in
functions whose return type is compatible with the value the (
<strong><code>?</code></strong> ) is used on.<br />
Attempting to use the ( <strong><code>?</code></strong> ) in the main
function that returns <strong><code>()</code></strong> won‚Äôt
compile.</li>
</ol>
<div class="sourceCode" id="cb130"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;user.txt&quot;</span>)<span class="op">?</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                                            ^ cannot use the `?` operator in a function that returns `()`</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Luckily, main can also return a
<strong><code>Result&lt;(), E&gt;</code></strong>.</li>
</ul>
<div class="sourceCode" id="cb131"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::error::</span><span class="bu">Error</span><span class="op">;</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Error</span><span class="op">&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> greeting_file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;hello.txt&quot;</span>)<span class="op">?;</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(())</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The <strong><code>Box&lt;dyn Error&gt;</code></strong> type is a
<strong><em>trait object</em></strong>, which we‚Äôll talk about in later
chapters!</li>
<li>For now, you can read it as to mean <strong><em>any kind of
error</em></strong>.</li>
</ul>
<p><br />
</p>
<ol start="10" type="1">
<li>The error message also mentioned that (
<strong><code>?</code></strong> ) can be used with
<strong><code>Option&lt;T&gt;</code></strong> values as well.<br />
As with using ( <strong><code>?</code></strong> ) on
<strong><code>Result&lt;T, E&gt;</code></strong>,<br />
you can only use ( <strong><code>?</code></strong> ) on
<strong><code>Option&lt;T&gt;</code></strong> in a function that returns
an <strong><code>Option&lt;T&gt;</code></strong>.<br />
Here either the value inside <strong><code>Some(T)</code></strong> or
the <strong><code>None</code></strong> will be returned.</li>
</ol>
<div class="sourceCode" id="cb132"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> last_char_of_first_line(text<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>            text<span class="op">.</span>lines()<span class="op">.</span>next()<span class="op">?.</span>chars()<span class="op">.</span>last()</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="11" type="1">
<li>The <strong><code>main()</code></strong> function may return any
types that implement the
<strong><code>std::process::Termination</code></strong> trait,<br />
which contains a function <strong><code>report()</code></strong> that
returns an <strong><code>ExitCode</code></strong>.<br />
Consult the standard library documentation for more information on
implementing the trait for your own types.</li>
</ol>
<hr/>
<h3 id="generic-types-traits-and-lifetimes">Generic Types, Traits, and
Lifetimes</h3>
<ol type="1">
<li>Starting function:</li>
</ol>
<div class="sourceCode" id="cb133"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> largest_i32(list<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">i32</span>]) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> largest <span class="op">=</span> <span class="op">&amp;</span>list[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> item <span class="kw">in</span> list <span class="op">{</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> item <span class="op">&gt;</span> largest <span class="op">{</span></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>                    largest <span class="op">=</span> item<span class="op">;</span></span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>            largest</span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> largest_char(list<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">char</span>]) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">char</span> <span class="op">{</span></span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> largest <span class="op">=</span> <span class="op">&amp;</span>list[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> item <span class="kw">in</span> list <span class="op">{</span></span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> item <span class="op">&gt;</span> largest <span class="op">{</span></span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a>                    largest <span class="op">=</span> item<span class="op">;</span></span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a>            largest</span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> number_list <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">34</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">65</span>]<span class="op">;</span></span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> largest_i32(<span class="op">&amp;</span>number_list)<span class="op">;</span></span>
<span id="cb133-30"><a href="#cb133-30" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span></span>
<span id="cb133-31"><a href="#cb133-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-32"><a href="#cb133-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- --- --- ---</span></span>
<span id="cb133-33"><a href="#cb133-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-34"><a href="#cb133-34" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> number_list <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">102</span><span class="op">,</span> <span class="dv">34</span><span class="op">,</span> <span class="dv">6000</span><span class="op">,</span> <span class="dv">89</span><span class="op">,</span> <span class="dv">54</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">43</span><span class="op">,</span> <span class="dv">8</span>]<span class="op">;</span></span>
<span id="cb133-35"><a href="#cb133-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-36"><a href="#cb133-36" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> largest_i32(<span class="op">&amp;</span>number_list)<span class="op">;</span></span>
<span id="cb133-37"><a href="#cb133-37" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span></span>
<span id="cb133-38"><a href="#cb133-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Modify it to generic:</li>
</ol>
<div class="sourceCode" id="cb134"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> largest<span class="op">&lt;</span>T<span class="op">&gt;</span>(list<span class="op">:</span> <span class="op">&amp;</span>[T]) <span class="op">-&gt;</span> <span class="op">&amp;</span>T <span class="op">{</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> largest <span class="op">=</span> <span class="op">&amp;</span>list[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> item <span class="kw">in</span> list <span class="op">{</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> item <span class="op">&gt;</span> largest <span class="op">{</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>                    largest <span class="op">=</span> item<span class="op">;</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>            largest</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> number_list <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">34</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">65</span>]<span class="op">;</span></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> largest(<span class="op">&amp;</span>number_list)<span class="op">;</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span></span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --- --- --- ---</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> char_list <span class="op">=</span> <span class="pp">vec!</span>[<span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;x&#39;</span><span class="op">,</span> <span class="ch">&#39;q&#39;</span><span class="op">,</span> <span class="ch">&#39;p&#39;</span>]<span class="op">;</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> largest(<span class="op">&amp;</span>char_list)<span class="op">;</span></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{result}&quot;</span>)<span class="op">;</span></span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>But if we compile this code right now, we‚Äôll get this error:</li>
</ul>
<div class="sourceCode" id="cb135"><pre
class="sourceCode txt"><code class="sourceCode default"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>        error[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>        --&gt; src/main.rs:5:17</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>          |</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>        5 |         if item &gt; largest {</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>          |            ---- ^ ------- &amp;T</span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>          |            |</span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>          |            &amp;T</span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>          |</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>        help: consider restricting type parameter `T`</span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a>          |</span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a>        1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {</span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a>          |             ++++++++++++++++++++++</span></code></pre></div>
<ul>
<li><p>The help text mentions
<strong><code>std::cmp::PartialOrd</code></strong>, which is a
<strong><em>trait</em></strong>, and we‚Äôre going to talk about traits in
the next section.<br />
</p></li>
<li><p>For now, know that this error states that the body of
<strong><code>largest()</code></strong> won‚Äôt work for all possible
types that <strong>T</strong> could be.<br />
Because we want to compare values of type <strong>T</strong> in the
body, we can only use types whose values can be ordered.</p></li>
<li><p>To enable comparisons, the standard library has the
<strong><code>std::cmp::PartialOrd</code></strong> trait that you can
implement on types.<br />
By following the help text‚Äôs suggestion, we restrict the types valid for
<strong>T</strong> to only those that implement
<strong><code>PartialOrd</code></strong>,<br />
and this example will compile, because the standard library implements
<strong><code>PartialOrd</code></strong> on both
<strong><code>i32</code></strong> and
<strong><code>char</code></strong>.</p></li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>We can also define <strong><code>struct</code></strong> to use a
generic type parameter in one or more fields using the
<strong><code>&lt;&gt;</code></strong> syntax.</li>
</ol>
<div class="sourceCode" id="cb136"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Point<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> new(x<span class="op">:</span> T<span class="op">,</span> y<span class="op">:</span> T) <span class="op">-&gt;</span> Point<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>            Point <span class="op">{</span> x<span class="op">,</span> y <span class="op">}</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> test(x<span class="op">:</span> T) <span class="op">{}</span></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> do_sth(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> data<span class="op">:</span> T) <span class="op">{}</span></span>
<span id="cb136-14"><a href="#cb136-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-15"><a href="#cb136-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> do_that<span class="op">&lt;</span>U<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> data<span class="op">:</span> U) <span class="op">{}</span></span>
<span id="cb136-16"><a href="#cb136-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-17"><a href="#cb136-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> coordinate(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="op">&amp;</span>T<span class="op">,</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb136-18"><a href="#cb136-18" aria-hidden="true" tabindex="-1"></a>            (<span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>x<span class="op">,</span> <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>y)</span>
<span id="cb136-19"><a href="#cb136-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb136-20"><a href="#cb136-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-21"><a href="#cb136-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> convert_with<span class="op">&lt;</span>U<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> Point<span class="op">&lt;</span>U<span class="op">&gt;</span>) <span class="op">-&gt;</span> Point<span class="op">&lt;</span>U<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb136-22"><a href="#cb136-22" aria-hidden="true" tabindex="-1"></a>            Point <span class="op">{</span></span>
<span id="cb136-23"><a href="#cb136-23" aria-hidden="true" tabindex="-1"></a>                x<span class="op">:</span> other<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb136-24"><a href="#cb136-24" aria-hidden="true" tabindex="-1"></a>                y<span class="op">:</span> other<span class="op">.</span>y<span class="op">,</span></span>
<span id="cb136-25"><a href="#cb136-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb136-26"><a href="#cb136-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb136-27"><a href="#cb136-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-28"><a href="#cb136-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-29"><a href="#cb136-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">// implement methods only on Point&lt;f64&gt; instances</span></span>
<span id="cb136-30"><a href="#cb136-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Point<span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb136-31"><a href="#cb136-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> distance_from_origin(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb136-32"><a href="#cb136-32" aria-hidden="true" tabindex="-1"></a>            (<span class="kw">self</span><span class="op">.</span>x<span class="op">.</span>powi(<span class="dv">2</span>) <span class="op">+</span> <span class="kw">self</span><span class="op">.</span>y<span class="op">.</span>powi(<span class="dv">2</span>))</span>
<span id="cb136-33"><a href="#cb136-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span>sqrt()</span>
<span id="cb136-34"><a href="#cb136-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb136-35"><a href="#cb136-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-36"><a href="#cb136-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-37"><a href="#cb136-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_value<span class="op">&lt;</span>T<span class="op">&gt;</span>(value<span class="op">:</span> T) <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb136-38"><a href="#cb136-38" aria-hidden="true" tabindex="-1"></a>        value</span>
<span id="cb136-39"><a href="#cb136-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb136-40"><a href="#cb136-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-41"><a href="#cb136-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-42"><a href="#cb136-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-43"><a href="#cb136-43" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb136-44"><a href="#cb136-44" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p1 <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span><span class="dv">5</span><span class="op">,</span>   y<span class="op">:</span><span class="dv">10</span>  <span class="op">};</span>                <span class="co">// : Point&lt;i32&gt;</span></span>
<span id="cb136-45"><a href="#cb136-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p2<span class="op">:</span> Point<span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span> <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span><span class="dv">1.0</span><span class="op">,</span> y<span class="op">:</span><span class="dv">2.0</span> <span class="op">};</span>    <span class="co">// : Point&lt;f64&gt;</span></span>
<span id="cb136-46"><a href="#cb136-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-47"><a href="#cb136-47" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> coord1 <span class="op">=</span> p1<span class="op">.</span>coordinate()<span class="op">;</span></span>
<span id="cb136-48"><a href="#cb136-48" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;(x:{}, y:{})&quot;</span><span class="op">,</span> coord1<span class="op">.</span><span class="dv">0</span><span class="op">,</span> coord1<span class="op">.</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb136-49"><a href="#cb136-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-50"><a href="#cb136-50" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> coord2 <span class="op">=</span> p2<span class="op">.</span>coordinate()<span class="op">;</span></span>
<span id="cb136-51"><a href="#cb136-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-52"><a href="#cb136-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Only methods have its own generic parameter can be called this way:</span></span>
<span id="cb136-53"><a href="#cb136-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      let p = p1.convert_with::&lt;f64&gt;(p2);</span></span>
<span id="cb136-54"><a href="#cb136-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">// So, calling convert_with() this way above is ok,</span></span>
<span id="cb136-55"><a href="#cb136-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">// but you cannot call coordinate() this way, because it does not have its own generic param.</span></span>
<span id="cb136-56"><a href="#cb136-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p <span class="op">=</span> p1<span class="op">.</span>convert_with(p2)<span class="op">;</span></span>
<span id="cb136-57"><a href="#cb136-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-58"><a href="#cb136-58" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> get_value(<span class="dv">10u8</span>)<span class="op">;</span></span>
<span id="cb136-59"><a href="#cb136-59" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">get_value::</span><span class="op">&lt;</span><span class="dt">u8</span><span class="op">&gt;</span>(<span class="dv">10u8</span>)<span class="op">;</span></span>
<span id="cb136-60"><a href="#cb136-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-61"><a href="#cb136-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> get_value(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb136-62"><a href="#cb136-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">get_value::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb136-63"><a href="#cb136-63" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">get_value::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>(<span class="dv">3.14</span>)<span class="op">;</span></span>
<span id="cb136-64"><a href="#cb136-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-65"><a href="#cb136-65" aria-hidden="true" tabindex="-1"></a>        <span class="co">// will NOT compile!</span></span>
<span id="cb136-66"><a href="#cb136-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let p3 = Point { x:1, y:2.0 };</span></span>
<span id="cb136-67"><a href="#cb136-67" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p3 <span class="op">=</span> <span class="pp">Point::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span><span class="pp">::</span>new(<span class="dv">1f64</span><span class="op">,</span> <span class="dv">2.0</span>)<span class="op">;</span>          <span class="co">// : Point&lt;f64&gt;</span></span>
<span id="cb136-68"><a href="#cb136-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-69"><a href="#cb136-69" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Point::</span>test(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb136-70"><a href="#cb136-70" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Point::</span>test(<span class="dv">1i32</span>)<span class="op">;</span></span>
<span id="cb136-71"><a href="#cb136-71" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Point::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span><span class="pp">::</span>test(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb136-72"><a href="#cb136-72" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Point::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span><span class="pp">::</span>test(<span class="dv">1i32</span>)<span class="op">;</span></span>
<span id="cb136-73"><a href="#cb136-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-74"><a href="#cb136-74" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Cannot call with turbofish syntax here.</span></span>
<span id="cb136-75"><a href="#cb136-75" aria-hidden="true" tabindex="-1"></a>        p3<span class="op">.</span>do_sth(<span class="dv">1f64</span>)<span class="op">;</span></span>
<span id="cb136-76"><a href="#cb136-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-77"><a href="#cb136-77" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This you can.</span></span>
<span id="cb136-78"><a href="#cb136-78" aria-hidden="true" tabindex="-1"></a>        p3<span class="op">.</span>do_that(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb136-79"><a href="#cb136-79" aria-hidden="true" tabindex="-1"></a>        p3<span class="op">.</span>do_that(<span class="dv">1i32</span>)<span class="op">;</span></span>
<span id="cb136-80"><a href="#cb136-80" aria-hidden="true" tabindex="-1"></a>        p3<span class="op">.</span><span class="pp">do_that::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb136-81"><a href="#cb136-81" aria-hidden="true" tabindex="-1"></a>        p3<span class="op">.</span><span class="pp">do_that::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>(<span class="dv">1i32</span>)<span class="op">;</span></span>
<span id="cb136-82"><a href="#cb136-82" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="publicity-of-structure">Publicity of Structure</h3>
<ol type="1">
<li>When you declare a <strong><code>pub struct</code></strong>,<br />
the structure itself is <strong><em>public</em></strong> and can be
accessed from outside its defining module.<br />
However, its fields are still <strong><em>private</em></strong> by
default unless you make them <strong><code>pub</code></strong> as
well.</li>
</ol>
<div class="sourceCode" id="cb137"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> my_module <span class="op">{</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Private struct, only accessible within this module</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> PrivateStruct <span class="op">{</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>            x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>            y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Public struct, but its fields are private</span></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> PublicStruct <span class="op">{</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>            x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> <span class="co">// private field</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> <span class="co">// public field</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> create_structs() <span class="op">-&gt;</span> PublicStruct <span class="op">{</span></span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// PrivateStruct can be instantiated inside its own module</span></span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> _private <span class="op">=</span> PrivateStruct <span class="op">{</span> x<span class="op">:</span> <span class="dv">5</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">10</span> <span class="op">};</span></span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// PublicStruct can also be instantiated inside the module</span></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>            PublicStruct <span class="op">{</span> x<span class="op">:</span> <span class="dv">5</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">10</span> <span class="op">}</span></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `PrivateStruct` is not accessible outside the module</span></span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let p = my_module::PrivateStruct { x: 5, y: 10 }; // ERROR: struct is private</span></span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `PublicStruct` is accessible because it&#39;s `pub`</span></span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p <span class="op">=</span> <span class="pp">my_module::</span>PublicStruct <span class="op">{</span> y<span class="op">:</span> <span class="dv">10</span> <span class="op">};</span> <span class="co">// Can access `y` (public field)</span></span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// However, `x` is still private and cannot be accessed</span></span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let p = my_module::PublicStruct { x: 5, y: 10 }; // ERROR: field `x` is private</span></span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="traits-defining-shared-behavior">Traits: Defining Shared
Behavior</h3>
<ol type="1">
<li>A <strong><em>trait</em></strong> defines the functionality a
particular type has and can share with other types.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We can use <strong><em>trait bounds</em></strong> to specify that a
generic type can be any type that has certain behavior.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>We want to make a media aggregator library crate named
<strong><em>aggregator</em></strong> that can display summaries of data
that might be stored in a <strong><em>NewsArticle</em></strong> or
<strong><em>Tweet</em></strong> instance.<br />
To do this, we need a summary from each type, and we‚Äôll request that
summary by calling a summarize method on an instance.</li>
</ol>
<div class="sourceCode" id="cb138"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">trait</span> Summary <span class="op">{</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> summarize(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>Here, we declare a <strong><em>trait</em></strong> using the
<strong><code>trait</code></strong> keyword and then the trait‚Äôs name,
which is <strong><em>Summary</em></strong> in this case.</p></li>
<li><p>We also declare the trait as <strong><code>pub</code></strong> so
that crates depending on this crate can make use of this trait
too.</p></li>
<li><p>Inside the curly brackets, we declare the method signatures that
describe the behaviors of the types that implement this trait.</p></li>
<li><p>After the method signature, instead of providing an
implementation within curly brackets, we use a semicolon (
<strong><code>;</code></strong> ).</p></li>
<li><p>Each type implementing this trait must provide its own custom
behavior for the body of the method.</p></li>
<li><p>The compiler will enforce that any type that has the
<strong><em>Summary</em></strong> trait will have the method
<strong><code>summarize()</code></strong> defined with this signature
exactly.</p></li>
<li><p>A trait can have multiple methods in its body: the method
signatures are listed one per line, and each line ends in a
semicolon.</p></li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>To implement a <strong><em>trait</em></strong> on a type:</li>
</ol>
<div class="sourceCode" id="cb139"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> NewsArticle <span class="op">{</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> author<span class="op">:</span>   <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> content<span class="op">:</span>  <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> headline<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> location<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Summary <span class="cf">for</span> NewsArticle <span class="op">{</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> summarize(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}, by {} ({})</span><span class="sc">\n\t</span><span class="st">{}&quot;</span><span class="op">,</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">self</span><span class="op">.</span>headline<span class="op">,</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">self</span><span class="op">.</span>author<span class="op">,</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">self</span><span class="op">.</span>location<span class="op">,</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">self</span><span class="op">.</span>content)<span class="op">;</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> Tweet <span class="op">{</span></span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> username<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> content<span class="op">:</span>  <span class="dt">String</span><span class="op">,</span></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> reply<span class="op">:</span>    <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> retweet<span class="op">:</span>  <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb139-23"><a href="#cb139-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb139-24"><a href="#cb139-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-25"><a href="#cb139-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Summary <span class="cf">for</span> Tweet <span class="op">{</span></span>
<span id="cb139-26"><a href="#cb139-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> summarize(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb139-27"><a href="#cb139-27" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}: {}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>username<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>content)<span class="op">;</span></span>
<span id="cb139-28"><a href="#cb139-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb139-29"><a href="#cb139-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>To use them, in Rust, if you want to use the trait‚Äôs methods (like
<strong><code>summarize()</code></strong> from the
<strong><em>Summary</em></strong> trait in the example),<br />
you MUST also import the trait into the scope.</li>
</ol>
<div class="sourceCode" id="cb140"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">aggregator::</span><span class="op">{</span>Summary<span class="op">,</span> Tweet<span class="op">};</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> tweet <span class="op">=</span> Tweet <span class="op">{</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>                username<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;some_tweet_name&quot;</span>)<span class="op">,</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>                content<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;some_content&quot;</span>)<span class="op">,</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>                reply<span class="op">:</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>                retweet<span class="op">:</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;I tweeted: {}&quot;</span><span class="op">,</span> tweet<span class="op">.</span>summarize())<span class="op">;</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li><p>Other crates that depend on the
<strong><em>aggregator</em></strong> crate can also bring the
<strong><em>Summary</em></strong> trait into scope to implement
<strong><em>Summary</em></strong> on their own types.</p>
<p>One restriction to note is that we can implement a
<strong><em>trait</em></strong> on a type, only if either the trait or
the type, or both, are <strong><em>local</em></strong> to our crate.</p>
<p>For example,<br />
we can implement standard library traits like
<strong><code>Display</code></strong> on a custom type like
<strong><em>Tweet</em></strong> as part of our
<strong><em>aggregator</em></strong> crate functionality,<br />
because the type <strong><em>Tweet</em></strong> is local to our
<strong><em>aggregator</em></strong> crate.</p>
<p>We can also implement <strong><em>Summary</em></strong> on
<strong><code>Vec&lt;T&gt;</code></strong> in our
<strong><em>aggregator</em></strong> crate because the trait
<strong><em>Summary</em></strong> is local to our
<strong><em>aggregator</em></strong> crate.</p>
<p>But we can‚Äôt implement external traits on external types.</p>
<ul>
<li>For example, we can‚Äôt implement the
<strong><code>Display</code></strong> trait on
<strong><code>Vec&lt;T&gt;</code></strong> within our
<strong><em>aggregator</em></strong> crate.</li>
</ul>
<p>This restriction is part of a property called
<strong><em>coherence</em></strong>, and more specifically the
<strong><em>orphan rule</em></strong>.</p>
<ul>
<li>This rule ensures that other people‚Äôs code can‚Äôt break your code and
vice versa.<br />
</li>
<li>Without the rule, two crates could implement the same trait for the
same type,<br />
and Rust wouldn‚Äôt know which implementation to use.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>Trait can have default implementations, and be overriden
specifically.</li>
</ol>
<div class="sourceCode" id="cb141"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">trait</span> Summary <span class="op">{</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> summarize(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;(Read more...)&quot;</span>)<span class="op">;</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> NewsArticle <span class="op">{</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> author<span class="op">:</span>   <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> content<span class="op">:</span>  <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> headline<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> location<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// To use a default implementation.</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Summary <span class="cf">for</span> NewsArticle <span class="op">{}</span></span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> Tweet <span class="op">{</span></span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> username<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> content<span class="op">:</span>  <span class="dt">String</span><span class="op">,</span></span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> reply<span class="op">:</span>    <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a>            <span class="kw">pub</span> retweet<span class="op">:</span>  <span class="dt">bool</span><span class="op">,</span></span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// To use a custom implementation.</span></span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Summary <span class="cf">for</span> Tweet <span class="op">{</span></span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> summarize(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}: {}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>username<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>content)<span class="op">;</span></span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>Now that you know how to define and implement traits,<br />
we can explore how to use traits to define functions that accept many
different types.</li>
</ol>
<div class="sourceCode" id="cb142"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify(item<span class="op">:</span> <span class="op">&amp;</span><span class="kw">impl</span> Summary) <span class="op">{</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> item<span class="op">.</span>summarize())<span class="op">;</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Instead of a concrete type for the <strong><em>item</em></strong>
parameter, we specify the <strong><code>impl</code></strong> keyword and
the <strong><em>trait name</em></strong>.</li>
<li>This parameter accepts any type that implements the specified
trait.</li>
</ul>
<p><br />
</p>
<ol start="9" type="1">
<li>The <strong><code>impl</code></strong> Trait syntax works for
straightforward cases but is actually a <strong><em>syntax
sugar</em></strong> for a longer form known as a <strong><em>trait
bound</em></strong>,<br />
it looks like this:</li>
</ol>
<div class="sourceCode" id="cb143"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> notify<span class="op">&lt;</span>T<span class="op">:</span> Summary<span class="op">&gt;</span>(item<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> item<span class="op">.</span>summarize())<span class="op">;</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>In Rust, you can NOT have fields inside a
<strong><em>trait</em></strong>. <strong><em>Traits</em></strong> in
Rust are used to define shared behavior.</li>
</ol>
<p><br />
</p>
<ol start="11" type="1">
<li>We can also specify more than one <strong><em>trait
bound</em></strong>.<br />
Say we wanted notify to use display formatting as well as summarize on
item,<br />
we specify in the notify definition that item must implement both
<strong><code>Display</code></strong> and
<strong><code>Summary</code></strong>.<br />
We can do so using the <strong><code>+</code></strong> syntax:</li>
</ol>
<div class="sourceCode" id="cb144"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> notify(item<span class="op">:</span> <span class="op">&amp;</span>(<span class="kw">impl</span> Summary <span class="op">+</span> <span class="bu">Display</span>)) <span class="op">{}</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> notify<span class="op">&lt;</span>T<span class="op">:</span> Summary <span class="op">+</span> <span class="bu">Display</span><span class="op">&gt;</span>(item<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{}</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="12" type="1">
<li>Rust has also an alternate syntax for specifying <strong><em>trait
bounds</em></strong> inside a <strong><code>where</code></strong> clause
after the function signature.</li>
</ol>
<div class="sourceCode" id="cb145"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> some_func<span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Display</span> <span class="op">+</span> <span class="bu">Clone</span><span class="op">,</span> U<span class="op">:</span> <span class="bu">Debug</span> <span class="op">+</span> <span class="bu">Clone</span><span class="op">&gt;</span>(t<span class="op">:</span> <span class="op">&amp;</span>T<span class="op">,</span> u<span class="op">:</span> <span class="op">&amp;</span>U) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> some_func<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;</span>(t<span class="op">:</span> <span class="op">&amp;</span>T<span class="op">,</span> u<span class="op">:</span> <span class="op">&amp;</span>U) <span class="op">-&gt;</span> <span class="dt">i32</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a>            T<span class="op">:</span> <span class="bu">Display</span> <span class="op">+</span> <span class="bu">Clone</span><span class="op">,</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>            U<span class="op">:</span> <span class="bu">Debug</span> <span class="op">+</span> <span class="bu">Clone</span><span class="op">,</span></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="13" type="1">
<li>We can also use the <strong><code>impl</code></strong> trait syntax
in the return position to return a value of some type that implements a
trait.</li>
</ol>
<div class="sourceCode" id="cb146"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> return_summarizable() <span class="op">-&gt;</span> <span class="kw">impl</span> Summary <span class="op">{</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>        Tweet <span class="op">{</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>            username<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;some_tweet_name&quot;</span>)<span class="op">,</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>            content<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;some_content&quot;</span>)<span class="op">,</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>            reply<span class="op">:</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>            retweet<span class="op">:</span> <span class="cn">false</span><span class="op">,</span></span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="14" type="1">
<li>You can also use <strong><em>trait bounds</em></strong> to
conditionally implement methods.</li>
</ol>
<div class="sourceCode" id="cb147"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fmt::</span><span class="bu">Display</span><span class="op">;</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Pair<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> Pair<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> new(x<span class="op">:</span> T<span class="op">,</span> y<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Self</span> <span class="op">{</span> x<span class="op">,</span> y <span class="op">}</span></span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Display</span> <span class="op">+</span> <span class="bu">PartialOrd</span><span class="op">&gt;</span> Pair<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> cmp_display(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">&lt;</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">{</span></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>y)<span class="op">;</span></span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>x)<span class="op">;</span></span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb147-22"><a href="#cb147-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb147-23"><a href="#cb147-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-24"><a href="#cb147-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Pair<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb147-25"><a href="#cb147-25" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> display(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb147-26"><a href="#cb147-26" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}{}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>x<span class="op">,</span> <span class="kw">self</span><span class="op">.</span>y)<span class="op">;</span></span>
<span id="cb147-27"><a href="#cb147-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb147-28"><a href="#cb147-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="15" type="1">
<li><p>We can also conditionally implement a trait for any type that
implements another trait.<br />
Implementations of a trait on any type that satisfies the trait bounds
are called <strong>blanket implementations</strong> and are used
extensively in the Rust standard library.</p>
<p>For example, the standard library implements the
<code>ToString</code> trait on any type that implements the
<code>Display</code> trait.<br />
The <code>impl</code> block in the standard library looks similar to
this code:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Display</span><span class="op">&gt;</span> <span class="bu">ToString</span> <span class="cf">for</span> T <span class="op">{</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// --snip--</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<ul>
<li>Because the standard library has this blanket implementation,<br />
we can call the <code>to_string()</code> method defined by the
<code>ToString</code> trait on any type that implements the
<code>Display</code> trait.</li>
</ul>
<div class="sourceCode" id="cb149"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="dv">3</span><span class="op">.</span>to_string()<span class="op">;</span></span></code></pre></div>
<hr/>
<h3 id="validating-references-with-lifetimes">Validating References with
Lifetimes</h3>
<ol type="1">
<li><code>Lifetimes</code> are another kind of generic that we‚Äôve
already been using.<br />
Rather than ensuring that a type has the behavior we want, lifetimes
ensure that references are <em>valid</em> as long as we need them to
be.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p><em>Every reference</em> in Rust has a lifetime, which is the
scope for which that reference is valid.<br />
Most of the time, lifetimes are implicit and inferred, just like most of
the time, types are inferred.</p>
<p>We <strong>MUST</strong> annotate types only when multiple types are
possible.<br />
In a similar way,<br />
we <strong>MUST</strong> annotate lifetimes when the lifetimes of
references could be related in a few different ways.</p></li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>The main aim of lifetimes is to prevent dangling references,<br />
which cause a program to reference data other than the data it‚Äôs
intended to reference.<br />
Consider the following example. (Which will cause a compile-time
error).</li>
</ol>
<div class="sourceCode" id="cb150"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r<span class="op">;</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{r}&quot;</span>)<span class="op">;</span></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ol start="4" type="1">
<li>The Rust compiler has a <code>borrow checker</code> that compares
scopes to determine whether all borrows are.</li>
</ol>
<div class="sourceCode" id="cb151"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r<span class="op">;</span>              <span class="co">// ----------+-- &#39;a</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//           |</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>                   <span class="co">//           |</span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>     <span class="co">// -+-- &#39;b   |</span></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>            r <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>         <span class="co">//  |        |</span></span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>                   <span class="co">// -+        |</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//           |</span></span>
<span id="cb151-9"><a href="#cb151-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{r}&quot;</span>)<span class="op">;</span>    <span class="co">// ----------+</span></span>
<span id="cb151-10"><a href="#cb151-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>Here, we‚Äôve annotated the lifetime of <strong><em>r</em></strong>
with <code>'a</code> and the lifetime of <strong><em>x</em></strong>
with <code>'b</code>.<br />
As you can see, the inner <code>'b</code> block is much smaller than the
outer <code>'a</code> lifetime block.<br />
At compile time,<br />
Rust compares the size of the two lifetimes and sees that
<strong><em>r</em></strong> has a lifetime of <code>'a</code> but that
it refers to memory with a lifetime of <code>'b</code>. The program is
rejected because <code>'b</code> is <em>shorter</em> than
<code>'a</code>: the subject of the reference doesn‚Äôt live as long as
the reference.</p></li>
<li><p>The following code will work.</p></li>
</ul>
<div class="sourceCode" id="cb152"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>         <span class="co">// ----------+-- &#39;b</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//           |</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> r <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>         <span class="co">// -+-- &#39;a   |</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//  |        |</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{r}&quot;</span>)<span class="op">;</span>    <span class="co">//  |        |</span></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// -+        |</span></span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>                       <span class="co">// ----------+</span></span></code></pre></div>
<ul>
<li>Here, <strong><em>x</em></strong> has the lifetime <code>'b</code>,
which in this case is larger than <code>'a</code>.<br />
This means <strong><em>r</em></strong> can reference
<strong><em>x</em></strong> because Rust knows that the reference in
<strong><em>r</em></strong> will always be valid while
<strong><em>x</em></strong> is valid.</li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li>Consider the following example now.<br />
We‚Äôll write a function that returns the longer of two string
slices.<br />
But it will cause compiler error.</li>
</ol>
<div class="sourceCode" id="cb153"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> string1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;abcd&quot;</span>)<span class="op">;</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> string2 <span class="op">=</span> <span class="st">&quot;xyz&quot;</span><span class="op">;</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> longest(string1<span class="op">.</span>as_str()<span class="op">,</span> string2)<span class="op">;</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> longest(x<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> y<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span>a</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">//            ----     ----     ^ expected named lifetime parameter</span></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">.</span>len() <span class="op">&gt;</span> y<span class="op">.</span>len() <span class="op">{</span></span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>            s</span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>            y</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>We‚Äôll be working on to fix this problem from now on.</li>
</ul>
<p><br />
</p>
<ol start="6" type="1">
<li><p><code>Lifetime annotations</code> do NOT change how long any of
the references live.<br />
Rather, they describe the relationships of the lifetimes of multiple
references to each other without affecting the lifetimes.</p>
<p>Lifetime annotations have a slightly unusual syntax,<br />
the names of lifetime parameters must start with an apostrophe
(<code>'</code>) and are usually all lowercases and very short.<br />
Most people use the name <code>'a</code> for the first lifetime
annotation.<br />
We place lifetime parameter annotations after the <code>&amp;</code> of
a reference,<br />
using a space to separate the annotation from the reference‚Äôs type.</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span><span class="dt">i32</span>            <span class="co">// a reference</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">i32</span>         <span class="co">// a reference with an explicit lifetime</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="dt">i32</span>     <span class="co">// a mutable reference with an explicit lifetime</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>To use lifetime annotations in function signatures, we need to
declare the generic lifetime parameters inside angle brackets between
the function name and the parameter list, just as we did with generic
type parameters.</p></li>
</ol>
<div class="sourceCode" id="cb155"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> longest<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span> y<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">.</span>len() <span class="op">&gt;</span> y<span class="op">.</span>len() <span class="op">{</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>            x</span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>            y</span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb155-7"><a href="#cb155-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The function signature now tells Rust that for some lifetime
<code>'a</code>, the function takes two parameters,<br />
both of which are string slices that live at least as long as lifetime
<code>'a</code>. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime
<code>'a</code>. The returned value must adhere <em>exactly</em> to the
lifetime specified in the function signature. &gt; In practice, it means
that the lifetime of the reference returned by the
<code>longest()</code> function<br />
is the same as the <em>smaller</em> of the lifetimes of the values
referred to by the function arguments.</li>
</ul>
<p><br />
</p>
<ol start="8" type="1">
<li>Consider following example, it will raise a compiler error.</li>
</ol>
<div class="sourceCode" id="cb156"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> string1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;abcd&quot;</span>)<span class="op">;</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result<span class="op">;</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> string2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;xyz&quot;</span>)<span class="op">;</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">//  ------- binding `string2` declared here</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> longest(string1<span class="op">.</span>as_str()<span class="op">,</span> string2<span class="op">.</span>as_str())<span class="op">;</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">//                                  ^^^^^^^ borrowed value does not live enough</span></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">//             ------ borrow later used here</span></span>
<span id="cb156-12"><a href="#cb156-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>But this will compile:</code></pre>
<div class="sourceCode" id="cb158"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> string1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;abcd&quot;</span>)<span class="op">;</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result<span class="op">;</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> string2 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;xyz&quot;</span>)<span class="op">;</span></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>            result <span class="op">=</span> longest(string1<span class="op">.</span>as_str()<span class="op">,</span> string2<span class="op">.</span>as_str())<span class="op">;</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>So far, the <code>struct</code> we‚Äôve defined all hold owned
types.<br />
We can define <code>struct</code> to hold <em>references</em>, but in
that case we would need to add a lifetime annotation on every reference
in the struct‚Äôs definition.</li>
</ol>
<div class="sourceCode" id="cb159"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ImportantExcerpt<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>        part<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> novel <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;Here goes the story. Once upon a time...&quot;</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> first_sentence <span class="op">=</span> novel<span class="op">.</span>split(<span class="ch">&#39;.&#39;</span>)<span class="op">.</span>next()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> excerpt <span class="op">=</span> ImportantExcerpt <span class="op">{</span></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>            part<span class="op">:</span> first_sentence<span class="op">,</span></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>Lifetime Elision.</li>
</ol>
<div class="sourceCode" id="cb160"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> test<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{}</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> test(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{}</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="11" type="1">
<li>Lifetime names for <code>struct</code> fields always need to be
declared after the <code>impl</code> keyword<br />
and then used after the struct‚Äôs name because those lifetimes are part
of the struct‚Äôs type.</li>
</ol>
<div class="sourceCode" id="cb161"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> ImportantExcerpt<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> part(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>part</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> part_again(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>part</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> part_again_again(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>part</span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="12" type="1">
<li>One special lifetime we need to discuss is
<code>'static</code>,<br />
which denotes that the affected reference can live for the <em>entire
duration of the program</em>.<br />
All string literals have the <code>'static</code> lifetime, which we can
annotate as follows:</li>
</ol>
<div class="sourceCode" id="cb162"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;i have a static lifetime.&quot;</span><span class="op">;</span></span></code></pre></div>
<ul>
<li>You might see suggestions to use the <code>'static</code> lifetime
in error messages.</li>
<li>But before specifying <code>'static</code> for a reference,<br />
think about whether the reference you have actually lives the entire
lifetime of your program or not, and whether you want it to.</li>
</ul>
<p><br />
</p>
<ol start="13" type="1">
<li>Let‚Äôs briefly look at the syntax of specifying generic type
parameters, trait bounds,<br />
and lifetimes all in one function!</li>
</ol>
<div class="sourceCode" id="cb163"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::fmt::</span><span class="bu">Display</span><span class="op">;</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> longest_with_an_anouncement<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> (</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>        ann<span class="op">:</span> T<span class="op">,</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>        T<span class="op">:</span> <span class="bu">Display</span></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb163-11"><a href="#cb163-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Announcement: {}!&quot;</span><span class="op">,</span> ann)<span class="op">;</span></span>
<span id="cb163-12"><a href="#cb163-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-13"><a href="#cb163-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x<span class="op">.</span>len() <span class="op">&lt;</span> y<span class="op">.</span>len() <span class="op">{</span></span>
<span id="cb163-14"><a href="#cb163-14" aria-hidden="true" tabindex="-1"></a>            x</span>
<span id="cb163-15"><a href="#cb163-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb163-16"><a href="#cb163-16" aria-hidden="true" tabindex="-1"></a>            y</span>
<span id="cb163-17"><a href="#cb163-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb163-18"><a href="#cb163-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="14" type="1">
<li>Rust does support <strong>lifetime bounds</strong>.<br />
Lifetime bounds are used to specify how long a reference should live
relative to another reference or type.<br />
<code>'a: 'b</code> means that <code>'a</code> must live AT LEAST as
long as <code>'b</code>, which means <code>'a &gt;= 'b</code> in
lifetime. (<code>'a</code> outlives <code>'b</code>).</li>
</ol>
<div class="sourceCode" id="cb164"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">:</span> <span class="ot">&#39;a</span><span class="op">&gt;</span>(</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;b</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>        x</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test2<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">&gt;</span>(</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;b</span> <span class="dt">str</span><span class="op">,</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a>    ) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&#39;b</span> <span class="op">:</span> <span class="ot">&#39;a</span></span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a>        x</span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>We‚Äôll have more detailed explanations in the later chapters!</li>
</ul>
<hr/>
<h3 id="automated-tests">Automated Tests</h3>
<ol type="1">
<li><p>Tests are Rust functions that verify that the non-test code is
functioning in the expected manner.<br />
The bodies of test functions typically perform these three actions:</p>
<ol type="a">
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert that the results are what you expect.</li>
</ol></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>At its simplest, a test in Rust is a function that‚Äôs annotated with
the <code>test</code> attribute.<br />
Attributes are metadata about pieces of Rust code.<br />
One example is the <code>derive</code> attribute we used with
structs.<br />
To change a function into a test function, add <code>#[test]</code> on
the line before <code>fn</code>.<br />
When you run your tests with the <code>cargo test</code> command,<br />
Rust builds a <em>test runner binary</em> that runs the annotated
functions and reports on whether each test function passes or
fails.</li>
</ol>
<blockquote>
<ul>
<li>Setup project.</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb165"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new adder <span class="at">--lib</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Created</span> library <span class="kw">`</span><span class="ex">adder</span><span class="kw">`</span> project</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd adder/</span></code></pre></div>
<blockquote>
<ul>
<li>src/lib.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb166"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> add(lhs<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> rhs<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">+</span> rhs</span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> it_works() <span class="op">{</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> four <span class="op">=</span> add(<span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(four<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb166-14"><a href="#cb166-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<blockquote>
<ul>
<li>Run test.</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb167"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Compiling</span> adder v0.1.0 <span class="op">(fi</span>le:///projects/adder)</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>    Finished `test` profile [unoptimized + debuginfo] target(s) <span class="op">in 0.57s</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Running</span> unittests src/lib.rs <span class="op">(targe</span>t/debug/deps/adder-92948b65e88960b4)</span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    running 1 test</span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>    test tests::it_works ... ok</span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>        Doc-tests adder</span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>    running 0 tests</span>
<span id="cb167-14"><a href="#cb167-14" aria-hidden="true" tabindex="-1"></a>    test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s</span></code></pre></div>
<blockquote>
<ul>
<li>Adding a must fail test.</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb168"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">struct</span> Guess <span class="op">{</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Guess <span class="op">{</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> new(value<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> Guess <span class="op">{</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> value <span class="op">&lt;</span> <span class="dv">1</span> <span class="op">{</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a>                <span class="pp">panic!</span>(</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Guess value too small! Should be between 1 and 100! Got {value}&quot;</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>                )<span class="op">;</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> value <span class="op">&gt;</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a>                <span class="pp">panic!</span>(</span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&quot;Guess value too big! Should be between 1 and 100! Got {value}&quot;</span></span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a>                )<span class="op">;</span></span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a>            Guess <span class="op">{</span> value <span class="op">}</span></span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-20"><a href="#cb168-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-21"><a href="#cb168-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> add(lhs<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> rhs<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb168-22"><a href="#cb168-22" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">+</span> rhs</span>
<span id="cb168-23"><a href="#cb168-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-24"><a href="#cb168-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-25"><a href="#cb168-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb168-26"><a href="#cb168-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb168-27"><a href="#cb168-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb168-28"><a href="#cb168-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-29"><a href="#cb168-29" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb168-30"><a href="#cb168-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> it_works() <span class="op">{</span></span>
<span id="cb168-31"><a href="#cb168-31" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> four <span class="op">=</span> add(<span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb168-32"><a href="#cb168-32" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(four<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb168-33"><a href="#cb168-33" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert!</span>(four <span class="op">==</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb168-34"><a href="#cb168-34" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert!</span>(four <span class="op">==</span> <span class="dv">4</span><span class="op">,</span> <span class="st">&quot;Error message here!&quot;</span>)<span class="op">;</span></span>
<span id="cb168-35"><a href="#cb168-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-36"><a href="#cb168-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-37"><a href="#cb168-37" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb168-38"><a href="#cb168-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> it_also_works() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb168-39"><a href="#cb168-39" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> four <span class="op">=</span> add(<span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb168-40"><a href="#cb168-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-41"><a href="#cb168-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> result <span class="op">==</span> <span class="dv">4</span> <span class="op">{</span></span>
<span id="cb168-42"><a href="#cb168-42" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Ok</span>(())</span>
<span id="cb168-43"><a href="#cb168-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb168-44"><a href="#cb168-44" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Err</span>(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;two plus two does not equal four!&quot;</span>))</span>
<span id="cb168-45"><a href="#cb168-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb168-46"><a href="#cb168-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-47"><a href="#cb168-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-48"><a href="#cb168-48" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb168-49"><a href="#cb168-49" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> must_fail() <span class="op">{</span></span>
<span id="cb168-50"><a href="#cb168-50" aria-hidden="true" tabindex="-1"></a>            <span class="pp">panic!</span>(<span class="st">&quot;Anyway this fails...&quot;</span>)<span class="op">;</span></span>
<span id="cb168-51"><a href="#cb168-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-52"><a href="#cb168-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-53"><a href="#cb168-53" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb168-54"><a href="#cb168-54" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>should_panic<span class="at">]</span></span>
<span id="cb168-55"><a href="#cb168-55" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> too_large_guess() <span class="op">{</span></span>
<span id="cb168-56"><a href="#cb168-56" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Guess::</span>new(<span class="dv">10_000</span>)<span class="op">;</span></span>
<span id="cb168-57"><a href="#cb168-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-58"><a href="#cb168-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-59"><a href="#cb168-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `expected` parameter makes sure the panic message contains certain text.</span></span>
<span id="cb168-60"><a href="#cb168-60" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb168-61"><a href="#cb168-61" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>should_panic<span class="at">(</span>expected<span class="op">=</span><span class="st">&quot;too small!&quot;</span><span class="at">)]</span></span>
<span id="cb168-62"><a href="#cb168-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> too_small_guess() <span class="op">{</span></span>
<span id="cb168-63"><a href="#cb168-63" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Guess::</span>new(<span class="op">-</span><span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb168-64"><a href="#cb168-64" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb168-65"><a href="#cb168-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>When you run multiple tests, by default they run in parallel using
threads,<br />
to finish running faster and you get feedback quicker. &gt; However,
because the tests are running at the same time,<br />
you must make sure your tests don‚Äôt depend on each other or on any
shared state,<br />
including a shared environment, such as the current working directory or
environment variables. &gt; For example, say each of your tests runs
some code that creates a file on disk named <code>test-output.txt</code>
and writes some data to that file.<br />
Then each test reads the data in that file and asserts that the file
contains a particular value, which is different in each test.<br />
Because the tests run at the same time, one test might overwrite the
file in the time between another.<br />
The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in
parallel. &gt; One solution is to make sure each test writes to a
different file,<br />
another solution is to run the tests one at a time. &gt; If you don‚Äôt
want to run the tests in parallel or if you want more fine-grained
control over the number of threads used,<br />
you can send the <code>-- --test-threads</code> flag and the number of
threads you want to use to the test binary.<br />
Take a look at the following example:</li>
</ol>
<div class="sourceCode" id="cb169"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--</span> <span class="at">--test-threads</span><span class="op">=</span>1</span></code></pre></div>
<pre><code>We set the number of test threads to `1`, telling the program not to use any parallelism.\
Running the tests this way will take longer than running them in parallel,\
but the tests won‚Äôt interfere with each other if they share state.</code></pre>
<p><br />
</p>
<ol start="4" type="1">
<li>By default, if a test passes, Rust‚Äôs test library captures anything
printed to standard output.<br />
For example, if we call <code>println!</code> in a the function to be
tested or in the test and the test passes,<br />
we won‚Äôt see the <code>println!</code> output in the terminal, we‚Äôll see
only the line that indicates the test passed.<br />
If a test fails, we‚Äôll see whatever was printed to standard output with
the rest of the failure message. &gt; If we want to see printed values
for passing tests as well, we can tell Rust to also show the output of
successful tests with <code>-- --show-output</code>:</li>
</ol>
<div class="sourceCode" id="cb171"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--</span> <span class="at">--show-output</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Sometimes, running a full test suite can take a long time.<br />
If you‚Äôre working on code in a particular area, you might want to run
only the tests pertaining to that code.<br />
You can choose which tests to run by passing cargo test the name or
names of the test(s) you want to run as an argument.</li>
</ol>
<blockquote>
<ul>
<li>src/lib.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb172"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> add_two(a<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>        a <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> add_two_and_two() <span class="op">{</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> add_two(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> add_three_and_two() <span class="op">{</span></span>
<span id="cb172-17"><a href="#cb172-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> add_two(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb172-18"><a href="#cb172-18" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb172-19"><a href="#cb172-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb172-20"><a href="#cb172-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-21"><a href="#cb172-21" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb172-22"><a href="#cb172-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> one_hundred() <span class="op">{</span></span>
<span id="cb172-23"><a href="#cb172-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> add_two(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb172-24"><a href="#cb172-24" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="dv">102</span>)<span class="op">;</span></span>
<span id="cb172-25"><a href="#cb172-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb172-26"><a href="#cb172-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>To run one specific test only.</li>
</ul>
<div class="sourceCode" id="cb173"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test one_hundred</span></code></pre></div>
<ul>
<li>And since <code>add_two_and_two()</code> and
<code>add_three_and_two()</code> both have ‚Äúadd‚Äù in their names,<br />
</li>
<li>if you only pass <code>add</code> as test name, it will run all
tests contains <code>add</code> as part of their names. Thus perform
multiple tests.</li>
</ul>
<div class="sourceCode" id="cb174"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test add</span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>We can also ignore some tests unless specifically requested.<br />
After <code>#[test]</code>, we add the <code>#[ignore]</code> line to
the test we want to exclude.</li>
</ol>
<div class="sourceCode" id="cb175"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> add(left<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> right<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">{</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>        left <span class="op">+</span> right</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> it_works() <span class="op">{</span></span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> result <span class="op">=</span> add(<span class="dv">2</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>ignore<span class="at">]</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> expensive_test() <span class="op">{</span></span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">// code that takes an hour to run</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<blockquote>
<ul>
<li>Run without ignored test(s).</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb176"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test</span></code></pre></div>
<blockquote>
<ul>
<li>Run only ignored test(s).</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb177"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--</span> <span class="at">--ignored</span></span></code></pre></div>
<blockquote>
<ul>
<li>Run all test(s).</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb178"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--</span> <span class="at">--include-ignored</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>The purpose of <strong>unit tests</strong> is to test each unit of
code in isolation from the rest of the code to quickly pinpoint where
code is and isn‚Äôt working as expected. &gt; You‚Äôll put unit tests in the
<code>src/</code> directory in each file with the code that they‚Äôre
testing.<br />
The convention is to create a module named <code>mod tests</code> in
each file to contain the test functions and to annotate the module with
<code>#[cfg(test)]</code>. &gt; The <code>#[cfg(test)]</code> annotation
on the <code>mod tests</code> module tells Rust to compile and run the
test code only when you run <code>cargo test</code>, not when you run
<code>cargo build</code>. &gt; You‚Äôll see that because integration tests
go in a different directory, they don‚Äôt need the
<code>#[cfg(test)]</code> annotation. However, because unit tests go in
the same files as the code,<br />
you‚Äôll use <code>#[cfg(test)]</code> to specify that they shouldn‚Äôt be
included in the compiled result.</li>
</ol>
<hr/>
<h3 id="integration-test">Integration Test</h3>
<ol type="1">
<li>In Rust, integration tests are entirely external to your
library.<br />
They use your library in the same way any other code would,<br />
which means they can only call functions that are part of your library‚Äôs
public API.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Their purpose is to test whether many parts of your library work
together correctly.<br />
Units of code that work correctly on their own could have problems when
integrated,<br />
so test coverage of the integrated code is important as well.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To create integration tests, you first need a <code>tests/</code>
directory. Usually here:</li>
</ol>
<pre class="console"><code>    adder/
    |---------- Cargo.lock
    |---------- Cargo.toml
    |---------- src/
                |---------- lib.rs
    |---------- tests/
                |---------- integration_test.rs</code></pre>
<ul>
<li>We create a <code>tests/</code> directory at the top level of our
project directory, next to <code>src/</code>.</li>
<li>Cargo knows to look for integration test files in this
directory.<br />
We can then make as many test files as we want, and Cargo will compile
each of the files as an individual crate.</li>
</ul>
<blockquote>
<ul>
<li>tests/integration_test.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb180"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">adder::</span>add_two<span class="op">;</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> it_adds_two() <span class="op">{</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> add_two(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="dv">4</span>)<span class="op">;</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>We don‚Äôt need to annotate any code in
<code>tests/integration_test.rs</code> with <code>#[cfg(test)]</code>.
Cargo treats the tests directory specially and compiles files in this
directory only when we run <code>cargo test</code>.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>To run all the tests in a particular integration test file,<br />
use the <code>--test</code> argument of <code>cargo test</code> followed
by the name of the file</li>
</ol>
<div class="sourceCode" id="cb181"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--test</span> integration_test</span></code></pre></div>
<pre><code>Or more general:</code></pre>
<div class="sourceCode" id="cb183"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo test <span class="at">--test</span> <span class="op">&lt;</span>test-file-name<span class="op">&gt;</span> <span class="op">&lt;</span>test-func-name<span class="op">&gt;</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Files in subdirectories of the <code>tests/</code> directory don‚Äôt
get compiled as separate crates nor have sections in the test
output.</li>
</ol>
<hr/>
<h3
id="closures-anonymous-functions-that-capture-their-environment.">Closures:
Anonymous Functions that Capture Their Environment.</h3>
<ol type="1">
<li>Rust‚Äôs <code>closures</code> are <strong>anonymous
functions</strong> you can save in a variable or pass as arguments to
other functions.<br />
You can create the <code>closure</code> in one place and then call the
<code>closure</code> elsewhere to evaluate it in a different
context.<br />
Unlike functions, <code>closures</code> can capture values from the
scope in which they‚Äôre defined.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We‚Äôll first examine how we can use closures to capture values from
the environment they‚Äôre defined in for later use.</li>
</ol>
<div class="sourceCode" id="cb184"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Copy</span><span class="op">,</span> <span class="bu">Clone</span><span class="at">)]</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> ShirtColor <span class="op">{</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>        Red<span class="op">,</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a>        Blue<span class="op">,</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Inventory <span class="op">{</span></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>        shirts<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>ShirtColor<span class="op">&gt;,</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Inventory <span class="op">{</span></span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> give_away(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> preference<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>ShirtColor<span class="op">&gt;</span>) <span class="op">-&gt;</span> ShirtColor <span class="op">{</span></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>            preference<span class="op">.</span>unwrap_or_else(<span class="op">||</span> <span class="kw">self</span><span class="op">.</span>most_stocked())</span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> most_stocked(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> ShirtColor <span class="op">{</span></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> num_red <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> num_blu <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> color <span class="kw">in</span> <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>shirts <span class="op">{</span></span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">match</span> color <span class="op">{</span></span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">ShirtColor::</span>Red  <span class="op">=&gt;</span> num_red <span class="op">+=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">ShirtColor::</span>Blue <span class="op">=&gt;</span> num_blu <span class="op">+=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb184-25"><a href="#cb184-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-26"><a href="#cb184-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-27"><a href="#cb184-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> num_red <span class="op">&gt;</span> num_blu <span class="op">{</span></span>
<span id="cb184-28"><a href="#cb184-28" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Red</span>
<span id="cb184-29"><a href="#cb184-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb184-30"><a href="#cb184-30" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Blue</span>
<span id="cb184-31"><a href="#cb184-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb184-32"><a href="#cb184-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb184-33"><a href="#cb184-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb184-34"><a href="#cb184-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-35"><a href="#cb184-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb184-36"><a href="#cb184-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> inventory <span class="op">=</span> Inventory <span class="op">{</span></span>
<span id="cb184-37"><a href="#cb184-37" aria-hidden="true" tabindex="-1"></a>            shirts<span class="op">:</span> <span class="pp">vec!</span>[</span>
<span id="cb184-38"><a href="#cb184-38" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Blue<span class="op">,</span></span>
<span id="cb184-39"><a href="#cb184-39" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Blue<span class="op">,</span></span>
<span id="cb184-40"><a href="#cb184-40" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Red<span class="op">,</span></span>
<span id="cb184-41"><a href="#cb184-41" aria-hidden="true" tabindex="-1"></a>                <span class="pp">ShirtColor::</span>Blue<span class="op">,</span></span>
<span id="cb184-42"><a href="#cb184-42" aria-hidden="true" tabindex="-1"></a>            ]<span class="op">,</span></span>
<span id="cb184-43"><a href="#cb184-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb184-44"><a href="#cb184-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-45"><a href="#cb184-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> preference <span class="op">=</span> <span class="cn">Some</span>(<span class="pp">ShirtColor::</span>Blue)<span class="op">;</span></span>
<span id="cb184-46"><a href="#cb184-46" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shirt <span class="op">=</span> inventory<span class="op">.</span>give_away(preference)<span class="op">;</span></span>
<span id="cb184-47"><a href="#cb184-47" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(</span>
<span id="cb184-48"><a href="#cb184-48" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;The user who prefers {:?} gets {:?}.&quot;</span><span class="op">,</span></span>
<span id="cb184-49"><a href="#cb184-49" aria-hidden="true" tabindex="-1"></a>            preference<span class="op">,</span></span>
<span id="cb184-50"><a href="#cb184-50" aria-hidden="true" tabindex="-1"></a>            shirt<span class="op">,</span></span>
<span id="cb184-51"><a href="#cb184-51" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb184-52"><a href="#cb184-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-53"><a href="#cb184-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> preference <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb184-54"><a href="#cb184-54" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shirt <span class="op">=</span> inventory<span class="op">.</span>give_away(preference)<span class="op">;</span></span>
<span id="cb184-55"><a href="#cb184-55" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(</span>
<span id="cb184-56"><a href="#cb184-56" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;The user who prefers {:?} gets {:?}.&quot;</span><span class="op">,</span></span>
<span id="cb184-57"><a href="#cb184-57" aria-hidden="true" tabindex="-1"></a>            preference<span class="op">,</span></span>
<span id="cb184-58"><a href="#cb184-58" aria-hidden="true" tabindex="-1"></a>            shirt<span class="op">,</span></span>
<span id="cb184-59"><a href="#cb184-59" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb184-60"><a href="#cb184-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>You may wonder why here no need to <code>borrow</code> the value of
<code>Option&lt;ShirtColor&gt;</code> in <code>give_away()</code>,<br />
since <code>Option&lt;ShirtColor&gt;</code> holds a value of
<code>ShirtColor</code>, which implements <code>Copy</code>, the
<code>Option</code> also benefits from this behavior.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>Closures don‚Äôt usually require you to annotate the types of the
parameters or the return value like <code>fn</code> functions do.<br />
But as with variables, we can add type annotations if we want to
increase explicitness and clarity at the cost of being more verbose than
is strictly necessary.</li>
</ol>
<div class="sourceCode" id="cb185"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> add_one_v1    (x<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">}</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> add_one_v2 <span class="op">=</span> <span class="op">|</span>x<span class="op">:</span> <span class="dt">u32</span><span class="op">|</span> <span class="op">-&gt;</span> <span class="dt">u32</span> <span class="op">{</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> add_one_v3 <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span>             <span class="op">{</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">};</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> add_one_v4 <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span>               x <span class="op">+</span> <span class="dv">1</span>  <span class="op">;</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>For closures, if no explicit notation,<br />
the compiler will infer one concrete type for each parameters and for
return value when first time using them.</li>
</ol>
<div class="sourceCode" id="cb186"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> simple_closure <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span> x<span class="op">;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> s <span class="op">=</span> simple_closure(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;hello&quot;</span>))<span class="op">;</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> n <span class="op">=</span> simple_closure(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The code above will cause a compiler ERROR!</li>
<li>Because the first time we call <code>example_closure()</code> with
the <code>String</code> value,<br />
the compiler infers the type of <strong><em>x</em></strong> and the
return type of the closure to be <code>String</code>.</li>
<li>Those types are then <strong>locked into the closure</strong> in
<code>example_closure()</code>,<br />
and we get a type error when we next try to use a different type with
the same closure.</li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li><p>Closures can capture values from their environment in three
ways,<br />
which directly map to the three ways a function can take a
parameter.<br />
<code>Borrowing immutably</code>, <code>borrowing mutably</code>, and
<code>taking ownership</code>.</p>
<p>The closure will decide which of these to use based on what the body
of the function does with the captured values.</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Before defining closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> borrowed_immutably <span class="op">=</span> <span class="op">||</span> <span class="pp">println!</span>(<span class="st">&quot;From closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Before calling  closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>    borrowed_immutably()<span class="op">;</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;After  calling  closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">---- ---- ---- ----</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Before defining closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// A closure that mutates the environment (in this case, it modifies v)</span></span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// needs to be declared as `mut` when the closure itself is called.</span></span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> borrowed_mutably <span class="op">=</span> <span class="op">||</span> v<span class="op">.</span>push(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Before calling  closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-21"><a href="#cb187-21" aria-hidden="true" tabindex="-1"></a>    borrowed_mutably()<span class="op">;</span></span>
<span id="cb187-22"><a href="#cb187-22" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;After  calling  closure {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb187-23"><a href="#cb187-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb187-24"><a href="#cb187-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-25"><a href="#cb187-25" aria-hidden="true" tabindex="-1"></a><span class="co">// Before defining closure [1, 2, 3]</span></span>
<span id="cb187-26"><a href="#cb187-26" aria-hidden="true" tabindex="-1"></a><span class="co">// Before calling  closure [1, 2, 3]</span></span>
<span id="cb187-27"><a href="#cb187-27" aria-hidden="true" tabindex="-1"></a><span class="co">// From closure [1, 2, 3]</span></span>
<span id="cb187-28"><a href="#cb187-28" aria-hidden="true" tabindex="-1"></a><span class="co">// After  calling  closure [1, 2, 3]</span></span>
<span id="cb187-29"><a href="#cb187-29" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb187-30"><a href="#cb187-30" aria-hidden="true" tabindex="-1"></a><span class="co">// ---- ---- ---- ----</span></span>
<span id="cb187-31"><a href="#cb187-31" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb187-32"><a href="#cb187-32" aria-hidden="true" tabindex="-1"></a><span class="co">// Before defining closure [1, 2, 3]</span></span>
<span id="cb187-33"><a href="#cb187-33" aria-hidden="true" tabindex="-1"></a><span class="co">// Before calling  closure [1, 2, 3]</span></span>
<span id="cb187-34"><a href="#cb187-34" aria-hidden="true" tabindex="-1"></a><span class="co">// From closure [1, 2, 3, 10]</span></span>
<span id="cb187-35"><a href="#cb187-35" aria-hidden="true" tabindex="-1"></a><span class="co">// After  calling  closure [1, 2, 3, 10]</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>If you want to force the closure to take ownership of the values
it uses in the environment even though the body of the closure does NOT
strictly need ownership,<br />
you can use the <code>move</code> keyword before the parameter
list.</p></li>
</ol>
<div class="sourceCode" id="cb188"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">move</span> <span class="op">||</span> <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> v)</span>
<span id="cb188-8"><a href="#cb188-8" aria-hidden="true" tabindex="-1"></a>        )<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb188-9"><a href="#cb188-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li><p>The way a closure captures and handles values from the
environment affects which traits the closure implements,<br />
and traits are how <code>fn</code> and <code>struct</code> can specify
what kinds of closures they can use.</p>
<p>Closures will automatically implement one, two, or all three of these
<code>Fn</code> traits,<br />
in an additive fashion, depending on how the closure‚Äôs body handles the
values: &gt; <code>FnOnce</code> applies to closures that can be called
once.<br />
All closures implement at least this trait, because all closures can be
called.<br />
A closure that moves captured values out of its body will only implement
<code>FnOnce</code> and none of the other <code>Fn</code> traits,
because it can only be called once.<br />
(ownership taken) &gt; <code>FnMut</code> applies to closures that don‚Äôt
move captured values out of their body, but that might mutate the
captured values.<br />
These closures can be called more than once.<br />
(mutable borrow) &gt; <code>Fn</code> applies to closures that don‚Äôt
move captured values out of their body and also mutate captured values,
as well as closures that capture nothing from their environment.<br />
These closures can be called more than once without mutating their
environment, which is important in cases such as calling a closure
multiple times concurrently.<br />
(immutably borrow)</p></li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>Let‚Äôs look at the definition of the <code>unwrap_or_else()</code>
method on <code>Option&lt;T&gt;</code> that we used</li>
</ol>
<div class="sourceCode" id="cb189"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> unwrap_or_else<span class="op">&lt;</span>F<span class="op">&gt;</span>(<span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> F) <span class="op">-&gt;</span> T</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">where</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>            F<span class="op">:</span> <span class="bu">FnOnce</span>() <span class="op">-&gt;</span> T</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(x) <span class="op">=&gt;</span> x<span class="op">,</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>                <span class="cn">None</span> <span class="op">=&gt;</span> f()<span class="op">,</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The trait bound specified on the generic type <code>F</code> is
<code>FnOnce() -&gt; T</code>, which means <code>F</code> must be able
to be called once, take no arguments, and return a <code>T</code>. Using
<code>FnOnce</code> in the trait bound expresses the constraint that
<code>unwrap_or_else()</code> is only going to call
<strong><em>f</em></strong> at most one time.</li>
<li>In the body of <code>unwrap_or_else()</code>, we can see that if the
<code>Option</code> is <code>Some</code>, <strong><em>f</em></strong>
won‚Äôt be called.</li>
<li>If the <code>Option</code> is <code>None</code>,
<strong><em>f</em></strong> will be called once.</li>
<li>Because all closures implement <code>FnOnce</code>,
<code>unwrap_or_else()</code> accepts all three kinds of closures and is
as flexible as it can be.</li>
</ul>
<p><br />
</p>
<ol start="9" type="1">
<li>Note:<br />
Functions can implement all three of the <code>Fn</code> traits
too.<br />
If what we want to do doesn‚Äôt require capturing a value from the
environment,<br />
we can use the name of a function rather than a closure where we need
something that implements one of the <code>Fn</code> traits. For
example, on an <code>Option&lt;Vec&lt;T&gt;&gt;</code> value, we could
call <code>unwrap_or_else(Vec::new)</code> to get a new, empty vector if
the value is <code>None</code>.</li>
</ol>
<div class="sourceCode" id="cb190"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">}</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> do_twice<span class="op">&lt;</span>F<span class="op">&gt;</span>(f<span class="op">:</span> F<span class="op">,</span> arg<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span></span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a>        F<span class="op">:</span> <span class="bu">Fn</span>(<span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a>        f(arg) <span class="op">+</span> f(arg)</span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> do_twice(<span class="op">|</span>x<span class="op">|</span> x <span class="op">*</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span>                 <span class="co">// -&gt; 20</span></span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-14"><a href="#cb190-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> do_twice(add_one<span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb190-15"><a href="#cb190-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span>                 <span class="co">// -&gt; 12</span></span>
<span id="cb190-16"><a href="#cb190-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="iterators">Iterators</h3>
<ol type="1">
<li>An iterator is responsible for the logic of iterating over each item
and determining when the sequence has finished.<br />
When you use iterators, you don‚Äôt have to reimplement that logic
yourself.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>In Rust, iterators are <strong>lazy</strong>,<br />
meaning they have no effect until you call methods that consume the
iterator to use it up.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To create an iterator:</li>
</ol>
<div class="sourceCode" id="cb191"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v_iter <span class="op">=</span> v<span class="op">.</span>iter()<span class="op">;</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> v_iter <span class="op">{</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>        println(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>In languages that don‚Äôt have iterators provided by their standard
libraries, you would likely write this same functionality by starting a
variable at index <code>0</code>,<br />
using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total
number of items.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>All iterators implement a trait named <code>Iterator</code> that is
defined in the standard library.</li>
</ol>
<div class="sourceCode" id="cb192"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">Iterator</span> <span class="op">{</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">type</span> Item<span class="op">;</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;;</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// --snipet--</span></span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Some methods already with default implementation...</span></span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>NOTE this definition uses some new syntax, <code>type Item</code>
and <code>Self::Item</code>, which are defining an <strong>associated
type</strong> with this trait. We‚Äôll talk about <strong>associated
types</strong> in depth in later chapters!</p></li>
<li><p>For now, all you need to know is that implementing the
<code>Iterator</code> trait requires that you also define an
<code>Item</code> type, and this <code>Item</code> type is used in the
return type of the <code>next()</code> method. In other words, the
<code>Item</code> type will be the type returned from the
iterator.</p></li>
<li><p>The <code>Iterator</code> trait only requires to implement the
<code>next()</code> method, which returns one item of the iterator at a
time wrapped in <code>Some</code> and, when iteration is over, returns
<code>None</code>.</p></li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li>We can also call the <code>next()</code> method on iterators
directly.</li>
</ol>
<div class="sourceCode" id="cb193"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> iterator_test() <span class="op">{</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// You only need to make the iterator mutable if you are manually advancing the iterator.</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The `for in` loop automatically handles advancing the iterator.</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> v_iter <span class="op">=</span> v<span class="op">.</span>iter()<span class="op">;</span></span>
<span id="cb193-8"><a href="#cb193-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-9"><a href="#cb193-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(v_iter<span class="op">.</span>next()<span class="op">,</span> <span class="cn">Some</span>(<span class="op">&amp;</span><span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb193-10"><a href="#cb193-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(v_iter<span class="op">.</span>next()<span class="op">,</span> <span class="cn">Some</span>(<span class="op">&amp;</span><span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb193-11"><a href="#cb193-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(v_iter<span class="op">.</span>next()<span class="op">,</span> <span class="cn">Some</span>(<span class="op">&amp;</span><span class="dv">3</span>))<span class="op">;</span></span>
<span id="cb193-12"><a href="#cb193-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(v_iter<span class="op">.</span>next()<span class="op">,</span> <span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb193-13"><a href="#cb193-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>The <code>Iterator</code> trait has a number of different methods
with default implementations provided by the standard library, you can
find out about these methods by looking in the standard library API
documentation for the <code>Iterator</code> trait.<br />
Some of these methods call the <code>next()</code> method inside their
default implementation, which is why you‚Äôre required to implement the
<code>next()</code> method when implementing the <code>Iterator</code>
trait.</li>
</ol>
<div class="sourceCode" id="cb194"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> iter_test() <span class="op">{</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v_iter <span class="op">=</span> v<span class="op">.</span>iter()<span class="op">;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> summation<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> v_iter<span class="op">.</span>sum()<span class="op">;</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(summation<span class="op">,</span> <span class="dv">6</span>)<span class="op">;</span></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li><code>Iterator adaptors</code> are methods defined on the
<code>Iterator</code> trait that do NOT consume the iterator.<br />
Instead, they produce different iterators by changing some aspect of the
original iterator.</li>
</ol>
<div class="sourceCode" id="cb195"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> iter_adaptor_test() <span class="op">{</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> v</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>iter()</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>map(<span class="op">|</span>x<span class="op">|</span> x <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(v<span class="op">,</span> <span class="pp">vec!</span>[<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>])<span class="op">;</span></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>Many iterator adapters take closures as arguments,<br />
and commonly the closures we‚Äôll specify as arguments to iterator
adapters will be closures that capture their environment.</li>
</ol>
<div class="sourceCode" id="cb196"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">PartialEq</span><span class="op">,</span> <span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Shoe <span class="op">{</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>        size<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>        style<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> shoes_in_size(shoes<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Shoe<span class="op">&gt;,</span> shoe_size<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span>Shoe<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>        shoes<span class="op">.</span>into_iter()<span class="op">.</span>filter(<span class="op">|</span>shoe<span class="op">|</span> shoe<span class="op">.</span>size <span class="op">==</span> shoe_size)<span class="op">.</span>collect()</span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb196-14"><a href="#cb196-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-15"><a href="#cb196-15" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb196-16"><a href="#cb196-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> filter_by_size_test() <span class="op">{</span></span>
<span id="cb196-17"><a href="#cb196-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> shoes <span class="op">=</span> <span class="pp">vec!</span>[</span>
<span id="cb196-18"><a href="#cb196-18" aria-hidden="true" tabindex="-1"></a>                Shoe <span class="op">{</span></span>
<span id="cb196-19"><a href="#cb196-19" aria-hidden="true" tabindex="-1"></a>                    size<span class="op">:</span> <span class="dv">41</span><span class="op">,</span></span>
<span id="cb196-20"><a href="#cb196-20" aria-hidden="true" tabindex="-1"></a>                    style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Sneaker&quot;</span>)<span class="op">,</span></span>
<span id="cb196-21"><a href="#cb196-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb196-22"><a href="#cb196-22" aria-hidden="true" tabindex="-1"></a>                Shoe <span class="op">{</span></span>
<span id="cb196-23"><a href="#cb196-23" aria-hidden="true" tabindex="-1"></a>                    size<span class="op">:</span> <span class="dv">45</span><span class="op">,</span></span>
<span id="cb196-24"><a href="#cb196-24" aria-hidden="true" tabindex="-1"></a>                    style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Nike&quot;</span>)<span class="op">,</span></span>
<span id="cb196-25"><a href="#cb196-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb196-26"><a href="#cb196-26" aria-hidden="true" tabindex="-1"></a>                Shoe <span class="op">{</span></span>
<span id="cb196-27"><a href="#cb196-27" aria-hidden="true" tabindex="-1"></a>                    size<span class="op">:</span> <span class="dv">43</span><span class="op">,</span></span>
<span id="cb196-28"><a href="#cb196-28" aria-hidden="true" tabindex="-1"></a>                    style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Adidas&quot;</span>)<span class="op">,</span></span>
<span id="cb196-29"><a href="#cb196-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb196-30"><a href="#cb196-30" aria-hidden="true" tabindex="-1"></a>                Shoe <span class="op">{</span></span>
<span id="cb196-31"><a href="#cb196-31" aria-hidden="true" tabindex="-1"></a>                    size<span class="op">:</span> <span class="dv">41</span><span class="op">,</span></span>
<span id="cb196-32"><a href="#cb196-32" aria-hidden="true" tabindex="-1"></a>                    style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Fila&quot;</span>)<span class="op">,</span></span>
<span id="cb196-33"><a href="#cb196-33" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb196-34"><a href="#cb196-34" aria-hidden="true" tabindex="-1"></a>                Shoe <span class="op">{</span></span>
<span id="cb196-35"><a href="#cb196-35" aria-hidden="true" tabindex="-1"></a>                    size<span class="op">:</span> <span class="dv">41</span><span class="op">,</span></span>
<span id="cb196-36"><a href="#cb196-36" aria-hidden="true" tabindex="-1"></a>                    style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Fila&quot;</span>)<span class="op">,</span></span>
<span id="cb196-37"><a href="#cb196-37" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb196-38"><a href="#cb196-38" aria-hidden="true" tabindex="-1"></a>            ]<span class="op">;</span></span>
<span id="cb196-39"><a href="#cb196-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-40"><a href="#cb196-40" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> shoes_in_my_size <span class="op">=</span> shoes_in_size(shoes<span class="op">,</span> <span class="dv">45</span>)<span class="op">;</span></span>
<span id="cb196-41"><a href="#cb196-41" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(</span>
<span id="cb196-42"><a href="#cb196-42" aria-hidden="true" tabindex="-1"></a>                shoes_in_my_size<span class="op">,</span></span>
<span id="cb196-43"><a href="#cb196-43" aria-hidden="true" tabindex="-1"></a>                <span class="pp">vec!</span>[</span>
<span id="cb196-44"><a href="#cb196-44" aria-hidden="true" tabindex="-1"></a>                    Shoe <span class="op">{</span></span>
<span id="cb196-45"><a href="#cb196-45" aria-hidden="true" tabindex="-1"></a>                        size<span class="op">:</span> <span class="dv">45</span><span class="op">,</span></span>
<span id="cb196-46"><a href="#cb196-46" aria-hidden="true" tabindex="-1"></a>                        style<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Nike&quot;</span>)<span class="op">,</span></span>
<span id="cb196-47"><a href="#cb196-47" aria-hidden="true" tabindex="-1"></a>                    <span class="op">},</span></span>
<span id="cb196-48"><a href="#cb196-48" aria-hidden="true" tabindex="-1"></a>                ]</span>
<span id="cb196-49"><a href="#cb196-49" aria-hidden="true" tabindex="-1"></a>            )<span class="op">;</span></span>
<span id="cb196-50"><a href="#cb196-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb196-51"><a href="#cb196-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="more-about-cargo-and-crates.io">More about Cargo and
Crates.io</h3>
<ol type="1">
<li>In Rust, <strong><code>release</code></strong> profiles are
predefined and customizable profiles with different configurations that
allow a programmer to have more control over various options for
compiling code.<br />
Each profile is configured independently of the others.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><code>Cargo</code> has two main profiles, the <code>dev</code>
profile is when you run <code>cargo build</code> and the
<code>release</code> profile is when you run
<code>cargo build --release</code>.<br />
The <code>dev</code> profile is defined with good defaults for
development, and the <code>release</code> profile has good defaults for
release builds.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Cargo has default settings for each of the profiles that apply when
you haven‚Äôt explicitly added any <code>[profile.*]</code> sections in
the project‚Äôs <code>Cargo.toml</code> file.<br />
By adding <code>[profile.*]</code> sections for any profile you want to
customize, you override any subset of the default settings.</li>
</ol>
<ul>
<li><strong><code>Cargo.toml</code></strong></li>
</ul>
<div class="sourceCode" id="cb197"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The `opt-level` setting controls the number of optimizations</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Rust will apply to your code, with a range of 0 to 3.</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 3 is the best optimization and extends compiling time.</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[profile.dev]</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">opt-level</span> <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[profile.release]</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">opt-level</span> <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[profile.custom]</span></span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">opt-level</span> <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
<hr/>
<h3 id="publishing-a-crate-to-crates.io">Publishing a Crate to
Crates.io</h3>
<ol type="1">
<li>We<code>'</code>ve used packages from <code>crates.io</code> as
dependencies of our project,<br />
but you can also share your code with other people by publishing your
own packages.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The <strong>crate registry</strong> at <code>crates.io</code>
distributes the source code of your packages,<br />
so it primarily hosts code that is open source.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Accurately documenting your packages will help other users know how
and when to use them,<br />
Rust has a particular kind of comment for documentation
<code>///</code>, known conveniently as a documentation comment,<br />
that will generate HTML documentation.</li>
</ol>
<div class="sourceCode" id="cb198"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// Adds one to the number given.</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">///</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// # Examples</span></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This is simply three backquotes `,</span></span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// I wrote it this way beacuse markdown does not display it.</span></span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// \`\`\`</span></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// let arg = 5;</span></span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// let answer = my_crate::add_one(arg);</span></span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">///</span></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// assert_eq!(6, answer);</span></span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// \`\`\`</span></span>
<span id="cb198-12"><a href="#cb198-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> add_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb198-13"><a href="#cb198-13" aria-hidden="true" tabindex="-1"></a>            x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb198-14"><a href="#cb198-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>We can generate the HTML documentation from this documentation
comment by running <code>cargo doc</code>.</li>
<li>This command runs the <code>rustdoc</code> tool distributed with
Rust and puts the generated HTML documentation in the
<code>target/doc/</code> directory.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li>For convenience, running <code>cargo doc --open</code> will build
the HTML for your current crate‚Äôs documentation (as well as the
documentation for all of your crate‚Äôs dependencies) and open the result
in a web browser.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>We used the <code># Examples</code> Markdown heading to create a
section in the HTML with the title ‚ÄúExamples‚Äù Here are some other
sections that crate authors commonly use in their documentation:</p>
<ul>
<li><code>Panics</code>
<ul>
<li>The scenarios in which the function being documented could
panic.</li>
<li>Callers of the function who don‚Äôt want their programs to panic
should make sure they don‚Äôt call the function in these situations.</li>
</ul></li>
<li><code>Errors</code>
<ul>
<li>If the function returns a <code>Result</code>, describing the kinds
of errors that might occur and what conditions might cause those errors
to be returned can be helpful.</li>
</ul></li>
<li><code>Safety</code>
<ul>
<li>If the function is <code>unsafe</code> to call (talk about it
later),<br />
there should be a section explaining why the function is
<code>unsafe</code> and covering the invariants that the function
expects callers to uphold.</li>
</ul></li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Adding example code blocks in your documentation comments can help
demonstrate how to use your library,<br />
and doing so has an additional bonus: running <code>cargo test</code>
will run the code examples in your documentation as tests!</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li><p>The style of doc comment <code>//!</code> adds documentation to
the item that contains the comments rather than to the items following
the comments.<br />
We typically use these doc comments inside the crate root file
(<code>src/lib.rs</code> by convention) or inside a module to document
the crate or the module as a whole.</p>
<p>For example, to add documentation that describes the purpose of the
<strong>my_crate</strong> crate that contains the <code>add_one()</code>
function, we add documentation comments that start with <code>//!</code>
to the beginning of the <code>src/lib.rs</code> file,</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="co">//! # My Crate</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a><span class="co">//!</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a><span class="co">//! `my_crate` is a collection of utilities to make performing certain</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a><span class="co">//! calculations more convenient.</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a><span class="co">/// Adds one to the number given.</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a><span class="co">// --snipet--</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Before you can publish any crates, you need to create an account
on <code>crates.io</code> and get an API token.<br />
To do so, visit the home page at <code>crates.io</code> and log in via a
GitHub account.<br />
Once you‚Äôre logged in, visit your account settings at
https://crates.io/me/ and retrieve your API key.<br />
Then run the cargo login command and paste your API key when prompted,
like this:</p></li>
</ol>
<div class="sourceCode" id="cb200"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo login</span></code></pre></div>
<ul>
<li>This command will inform <code>Cargo</code> of your API token and
store it locally in <code>~/.cargo/credentials</code>.</li>
<li>Note that this token is a secret, do not share it with anyone
else!</li>
<li>If you do share it with anyone for any reason, you should revoke it
and generate a new token on <code>crates.io</code>.</li>
</ul>
<p><br />
</p>
<ol start="7" type="1">
<li>Let‚Äôs say you have a crate you want to publish.<br />
Before publishing, you‚Äôll need to add some metadata in the
<code>[package]</code> section of the crate‚Äôs <code>Cargo.toml</code>
file. &gt; Your crate will need a unique name.<br />
While you‚Äôre working on a crate locally, you can name a crate whatever
you‚Äôd like.<br />
However, crate names on <code>crates.io</code> are allocated on a
first-come, first-served basis.<br />
Once a crate name is taken, no one else can publish a crate with that
name. &gt; Before attempting to publish a crate, search for the name you
want to use.<br />
If the name has been used, you will need to find another name and edit
the name field in the <code>Cargo.toml</code> file under the
<code>[package]</code> section to use the new name for publishing, like
so:</li>
</ol>
<ul>
<li><strong><code>Cargo.toml</code></strong></li>
</ul>
<div class="sourceCode" id="cb201"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[package]</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;my_strange_game&quot;</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.1.0&quot;</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">edition</span> <span class="op">=</span> <span class="st">&quot;2024&quot;</span></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">description</span> <span class="op">=</span> <span class="st">&quot;A strange game.&quot;</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">license</span> <span class="op">=</span> <span class="st">&quot;MIT OR Apache-2.0&quot;</span></span></code></pre></div>
<ul>
<li>ONLY with a <code>name</code>, <code>version</code>,
<code>description</code> and <code>license</code> added, the
<code>cargo publish</code> will work!</li>
</ul>
<div class="sourceCode" id="cb202"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo publish</span></code></pre></div>
<ul>
<li>It uploads or updates your crate on <code>crate.io</code>.</li>
</ul>
<p><br />
</p>
<ol start="8" type="1">
<li>Although you can‚Äôt remove previous versions of a crate,<br />
you can prevent any future projects from adding them as a new
dependency.<br />
This is useful when a crate version is broken for one reason or
another.<br />
In such situations, Cargo supports <em>yanking</em> a crate
version.</li>
</ol>
<p><br />
</p>
<ol start="9" type="1">
<li>To yank a version of a crate, in the directory of the crate that
you‚Äôve previously published, run <code>cargo yank</code> and specify
which <strong>version</strong> you want to yank.<br />
For example, if we‚Äôve published a crate named
<code>guessing_game version 1.0.1</code> and we want to yank it.<br />
Any future <code>Cargo.lock</code> files generated will not use the
yanked version.</li>
</ol>
<div class="sourceCode" id="cb203"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo yank <span class="at">--vers</span> 1.0.1</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Updating</span> crates.io index</span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>            <span class="ex">Yank</span> guessing_game@1.0.1</span></code></pre></div>
<ul>
<li>By adding <code>--undo</code> to the command, you can also
<em>undo</em> a yank and allow projects to start depending on a version
again:</li>
</ul>
<div class="sourceCode" id="cb204"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo yank <span class="at">--vers</span> 1.0.1 <span class="at">--undo</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Updating</span> crates.io index</span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a>            <span class="ex">Unyank</span> guessing_game@1.0.1</span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>A yank does NOT delete any code.<br />
So do NOT upload your secrets there!</li>
</ol>
<hr/>
<h3 id="cargo-workspace">Cargo Workspace</h3>
<ol type="1">
<li><p>As your project develops, you might find that the library crate
continues to get bigger and you want to split your package further into
multiple library crates.</p>
<p>Cargo offers a feature called <code>workspaces</code> that can help
manage multiple related packages that are developed in tandem.</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>A <code>workspace</code> is a set of packages that share the same
<code>Cargo.lock</code> and <strong>output directory</strong>. Let‚Äôs
make a project using a workspace!</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>There are multiple ways to structure a workspace, so we‚Äôll just
show one common way.<br />
We‚Äôll have a workspace containing a binary and two libraries.<br />
The binary, which will provide the main functionality, will depend on
the two libraries.<br />
One library will provide an <code>add_one()</code> function, and a
second library an <code>add_two()</code> function.<br />
These three crates will be part of the same workspace.</p>
<p>We‚Äôll start by creating a new directory for the workspace:</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> mkdir add</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd add/</span></code></pre></div></li>
</ol>
<ul>
<li><p>Next, in the <code>add/</code> directory, we create the
<code>Cargo.toml</code> file that will configure the entire
workspace.</p></li>
<li><p>This file won‚Äôt have a <code>[package]</code> section.</p></li>
<li><p>Instead, it will start with a <code>[workspace]</code> section
that will allow us to add members to the workspace by specifying the
path to the package with our binary crate.</p>
<p>In this case, that path is <em>adder</em>:</p></li>
<li><p><strong><code>Cargo.toml</code></strong></p></li>
</ul>
<div class="sourceCode" id="cb206"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[workspace]</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">members</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;adder&quot;</span><span class="op">,</span></span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span></span></code></pre></div>
<ul>
<li>Next, we‚Äôll create the <em>adder binary crate</em> by running
<code>cargo new</code> within the <code>add/</code> directory:</li>
</ul>
<div class="sourceCode" id="cb207"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a>        <span class="ex">$</span> cargo new adder</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>            <span class="ex">Created</span> binary <span class="op">(application)</span> <span class="kw">`</span><span class="ex">adder</span><span class="kw">`</span> package</span></code></pre></div>
<ul>
<li>At this point, we can build the workspace by running
<code>cargo build</code>.</li>
<li>The files in your <code>add/</code> directory should look like
this:</li>
</ul>
<pre class="console"><code>        |---------- add/
                    |---------- Cargo.lock
                    |---------- Cargo.toml
                    |---------- adder/
                                |---------- Cargo.toml
                                |---------- src/
                                            |---------- main.rs
                    |---------- target/</code></pre>
<ul>
<li><p>The workspace has one <code>target/</code> directory at the top
level that the compiled artifacts will be placed into, the
<strong>adder</strong> package does NOT have its own
<code>target/</code> directory.</p></li>
<li><p>Even if we were to run <code>cargo build</code> from inside the
<code>adder/</code> directory, the compiled artifacts would still end up
in <code>add/target/</code> rather than
<code>add/adder/target/</code>.<br />
Cargo structures the <code>target/</code> directory in a workspace like
this because the crates in a workspace are meant to depend on each
other.</p></li>
<li><p>Next, let‚Äôs create another member package in the workspace and
call it <code>add_one()</code>.<br />
Change the top-level <code>Cargo.toml</code> to specify the
<code>add_one()</code> path in the <strong>members</strong>
list:</p></li>
<li><p><strong><code>Cargo.toml</code></strong></p></li>
</ul>
<div class="sourceCode" id="cb209"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[workspace]</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">members</span> <span class="op">=</span> <span class="op">[</span></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;adder&quot;</span><span class="op">,</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;add_one&quot;</span><span class="op">,</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">]</span></span></code></pre></div>
<ul>
<li>Then generate a new library crate named <code>add_one</code>:</li>
</ul>
<div class="sourceCode" id="cb210"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a>        <span class="ex">$</span> cargo new add_one <span class="at">--lib</span></span></code></pre></div>
<ul>
<li><strong><code>add_one/src/lib.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb211"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> add_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>            x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>Now we can have the <strong>adder</strong> package with our
binary depend on the <strong>add_one</strong> package that has our
library.</p></li>
<li><p>First, we‚Äôll need to add a <em>path dependency</em> on
<strong>add_one</strong> to <code>adder/Cargo.toml</code>.</p></li>
<li><p><strong><code>adder/Cargo.toml</code></strong></p></li>
</ul>
<div class="sourceCode" id="cb212"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">[dependencies]</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">add_one</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">path</span><span class="op">=</span><span class="st">&quot;../add_one&quot;</span><span class="op"> }</span></span></code></pre></div>
<ul>
<li><p>Cargo doesn‚Äôt assume that crates in a workspace will depend on
each other, so we need to be explicit about the dependency
relationships.</p></li>
<li><p>Next, let‚Äôs use the <code>add_one()</code> function (from the
<strong>add_one</strong> crate) in the <strong>adder</strong>
crate.</p></li>
<li><p>Open the <code>adder/src/main.rs</code> file and add a use line
at the top to bring the new <strong>add_one</strong> library crate into
scope.</p></li>
<li><p>Then change the <code>main()</code> function to call the
<code>add_one()</code> function.</p></li>
<li><p><strong><code>adder/src/main.rs</code></strong></p></li>
</ul>
<div class="sourceCode" id="cb213"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> add_one<span class="op">;</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">add_one::</span>add_one(n))<span class="op">;</span>    <span class="co">// -&gt; 11</span></span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>Then let‚Äôs build the workspace by running
<code>cargo build</code> in the top-level <code>add/</code>
directory!</p></li>
<li><p>To run the binary crate from the <code>add/</code> directory, we
can specify which package in the workspace we want to run by using the
<code>-p</code> argument and the package name with
<code>cargo run</code>:</p></li>
</ul>
<div class="sourceCode" id="cb214"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>        <span class="ex">$</span> cargo run <span class="at">-p</span> adder</span></code></pre></div>
<ul>
<li>If we add the external <code>rand</code> package to the
<code>adder/Cargo.toml</code> and <code>add_one/Cargo.toml</code> files,
and if the specified versions are compatible.</li>
<li>Cargo will resolve both of those to one version of <code>rand</code>
and record that in the one <code>Cargo.lock</code>. Otherwise Cargo will
resolve each of them, but will still try to resolve as few versions as
possible.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>For another enhancement,<br />
let‚Äôs add a test of the <code>add_one::add_one()</code> function within
the <code>add_one()</code> crate:</li>
</ol>
<ul>
<li><strong><code>add_one/src/lib.rs</code></strong></li>
</ul>
<div class="sourceCode" id="cb215"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> add_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>            x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>            <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> it_works() <span class="op">{</span></span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a>                <span class="pp">assert_eq!</span>(<span class="dv">3</span><span class="op">,</span> add_one(<span class="dv">2</span>))<span class="op">;</span></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb215-13"><a href="#cb215-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li><p>Running <code>cargo test</code> in a workspace will run the tests
for all the crates in the workspace.</p></li>
<li><p>We can also run tests for one particular crate in a workspace
from the top-level directory by using the <code>-p</code> flag and
specifying the name of the crate we want to test:</p></li>
</ul>
<div class="sourceCode" id="cb216"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>        <span class="ex">$</span> cargo test <span class="at">-p</span> add_one</span></code></pre></div>
<ul>
<li>For additional practice, add an <code>add_two</code> crate to this
workspace in a similar way as the <code>add_one</code> crate! Not
implementing it here!</li>
</ul>
<hr/>
<h3 id="install-binaries-with-cargo-install">Install Binaries with
<code>cargo install</code></h3>
<ol type="1">
<li>The <code>cargo install</code> command allows you to install and use
binary crates locally.<br />
This isn‚Äôt intended to replace system packages, it‚Äôs meant to be a
convenient way for Rust developers to install tools that others have
shared on <code>crates.io</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Note that you can only install packages that have binary
targets.<br />
A binary target is the runnable program that is created if the crate has
a <code>src/main.rs</code> file or another file specified as a
binary,<br />
as opposed to a library target that isn‚Äôt runnable on its own but is
suitable for including within other programs.<br />
Usually, crates have information in the <code>README</code> file about
whether a crate is a library, has a binary target, or both.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>All binaries installed with <code>cargo install</code> are stored in
the installation root‚Äôs <code>bin/</code> folder.<br />
If you installed Rust using <code>rustup.rs</code> and don‚Äôt have any
custom configurations, this directory will be
<code>$HOME/.cargo/bin</code>.<br />
Ensure that directory is in your <code>$PATH</code> to be able to run
programs you‚Äôve installed with cargo install.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>For example, we know that there‚Äôs a Rust implementation of the
<code>grep</code> tool called <code>ripgrep</code> for searching
files.<br />
To install <code>ripgrep</code>, we can run the following:</li>
</ol>
<div class="sourceCode" id="cb217"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a>        <span class="ex">$</span> cargo install ripgrep</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Updating</span> crates.io index</span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Downloaded</span> ripgrep v13.0.0</span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Downloaded</span> 1 crate <span class="pp">(</span><span class="ss">243.3 KB</span><span class="pp">)</span> in 0.88s</span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Installing</span> ripgrep v13.0.0</span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>        <span class="ex">--snip--</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Compiling</span> ripgrep v13.0.0</span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Finished</span> release <span class="pp">[</span><span class="st">optimized + debuginfo</span><span class="pp">]</span> target<span class="op">(s)</span> in 3m 10s</span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Installing</span> ~/.cargo/bin/rg</span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>        <span class="ex">Installed</span> package <span class="kw">`</span><span class="ex">ripgrep</span> v13.0.0<span class="kw">`</span> <span class="op">(ex</span>ecutable <span class="kw">`</span><span class="ex">rg</span><span class="kw">`</span>)</span></code></pre></div>
<ul>
<li>The second-to-last line of the output shows the location and the
name of the installed binary, which in this case is
<code>rg</code>.</li>
<li>As long as the installation directory is in your <code>$PATH</code>,
as mentioned previously, you can then run <code>rg --help</code> and
start using a faster, rustier tool for searching files!</li>
</ul>
<hr/>
<h3 id="smart-pointers">Smart Pointers</h3>
<ol type="1">
<li><p>We‚Äôve already encountered a few smart pointers in this book,
including <code>String</code> and <code>Vec&lt;T&gt;</code>.<br />
Both these types count as smart pointers because they own some memory
and allow you to manipulate it.<br />
They also have metadata and extra capabilities or guarantees.</p>
<p><code>String</code>, for example, stores its capacity as metadata and
has the extra ability to ensure its data will always be valid
UTF-8.</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Smart pointers are usually implemented using structs.<br />
Unlike an ordinary struct, smart pointers implement the
<code>Deref</code> and <code>Drop</code> traits.<br />
The <code>Deref</code> trait allows an instance of the smart pointer
struct to behave like a reference so you can write your code to work
with either references or smart pointers.<br />
The <code>Drop</code> trait allows you to customize the code that‚Äôs run
when an instance of the smart pointer goes out of scope.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>This chapter won‚Äôt cover every existing smart pointer.<br />
Many libraries have their own smart pointers, and you can even write
your own.<br />
We‚Äôll cover the most common smart pointers in the standard library:</p>
<p><code>Box&lt;T&gt;</code>, for allocating values on the heap.</p>
<p><code>Rc&lt;T&gt;</code>, a reference counting type that enables
multiple ownership.</p>
<p><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed
thru <code>RefCell&lt;T&gt;</code>,<br />
a type that enforces the borrowing rules at runtime instead of compile
time.</p></li>
</ol>
<h2 id="box">Box<T></h2>
<ol type="1">
<li>The most straightforward smart pointer is a box, whose type is
written <code>Box&lt;T&gt;</code>.<br />
Which allows you to store data on the heap rather than the stack.<br />
What remains on the stack is the pointer to the heap data.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Boxes don‚Äôt have performance overhead, other than storing their data
on the heap instead of on the stack.<br />
But they don‚Äôt have many extra capabilities either.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>You‚Äôll use them most often in these situations:</p>
<ol type="a">
<li>When you have a type whose size can‚Äôt be known at compile
time,<br />
and you want to use a value of that type in a context that requires an
exact size.</li>
<li>When you have a large amount of data and you want to transfer
ownership<br />
but ensure the data won‚Äôt be copied when you do so.</li>
<li>When you want to own a value and you care only that it‚Äôs a type that
implements a particular trait<br />
rather than being of a specific type.</li>
</ol></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Storing an <strong><code>i32</code></strong> value on the heap using
a box.</li>
</ol>
<div class="sourceCode" id="cb218"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> b <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Auto-dereferencing behavior, wouldn&#39;t be wrong if you wrote `*b` here.</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> b)<span class="op">;</span>      <span class="co">// -&gt; 5</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>We define the variable <strong><em>b</em></strong> to have the value
of a <code>Box</code> that points to the value <code>5</code>, which is
allocated on the heap.</li>
<li>In this case, we can access the data in the box similar to how we
would if this data were on the stack.</li>
<li>Just like any owned value, when a box goes out of scope, as
<strong><em>b</em></strong> does at the end of <code>main()</code>, it
will be deallocated.</li>
<li>The deallocation happens both for the box (stored on the stack) and
the data it points to (stored on the heap).</li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li>Enabling Recursive Types with Boxes.<br />
Consider the following code which causes compiler ERROR:</li>
</ol>
<div class="sourceCode" id="cb219"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> LinkedList <span class="op">{</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>            Data(<span class="dt">i32</span><span class="op">,</span> LinkedList)<span class="op">,</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">//            ---------- recursive without indirection.</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Nil</span><span class="op">,</span></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> my_linkedlist <span class="op">=</span> Data(<span class="dv">1</span><span class="op">,</span> Data(<span class="dv">2</span><span class="op">,</span> Data(<span class="dv">3</span><span class="op">,</span> <span class="cn">Nil</span>)))<span class="op">;</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>To eliminate the compiler ERROR:</li>
</ul>
<div class="sourceCode" id="cb220"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> LinkedList <span class="op">{</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>            Data(<span class="dt">i32</span><span class="op">,</span> <span class="dt">Box</span><span class="op">&lt;</span>LinkedList<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Nil</span><span class="op">,</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::LinkedList::</span><span class="op">{</span>Data<span class="op">,</span> <span class="cn">Nil</span><span class="op">};</span></span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> my_linkedlist <span class="op">=</span> Data(<span class="dv">1</span><span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(Data(<span class="dv">2</span><span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(Data(<span class="dv">3</span><span class="op">,</span> <span class="dt">Box</span><span class="pp">::</span>new(<span class="cn">Nil</span>))))))<span class="op">;</span></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="the-deref-trait">The <code>Deref</code> Trait</h3>
<ol type="1">
<li>Implementing the <strong><code>Deref</code></strong> trait allows
you to customize the behavior of the dereference operator (
<code>*</code> ).<br />
By implementing <strong><code>Deref</code></strong> in such a way that a
smart pointer can be treated like a regular reference,<br />
you can write code that operates on references and use that code with
smart pointers too.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>A regular reference is a type of pointer,<br />
and one way to think of a pointer is as an arrow to a value stored
somewhere else.</li>
</ol>
<div class="sourceCode" id="cb221"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> y <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> <span class="op">*</span>y)<span class="op">;</span></span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>The variable <strong><em>x</em></strong> holds an
<strong><code>i32</code></strong> value <code>5</code>. We set
<strong><em>y</em></strong> equal to a reference to
<strong><em>x</em></strong>.<br />
</li>
<li>We can assert that <strong><em>x</em></strong> is equal to
<code>5</code>. However, if we want to make an assertion about the value
in <strong><em>y</em></strong>,<br />
we have to use <code>*y</code> to follow the reference to the value it‚Äôs
pointing to (hence dereference),<br />
so the compiler can compare the actual value.</li>
<li>Once we dereference <strong><em>y</em></strong>, we have access to
the integer value <strong><em>y</em></strong> is pointing to that we can
compare with <code>5</code>.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>We can rewrite the code to use a
<strong><code>Box&lt;T&gt;</code></strong> instead of a reference,<br />
the dereference operator used on the
<strong><code>Box&lt;T&gt;</code></strong> is the same way as the
dereference operator used on the reference.</li>
</ol>
<div class="sourceCode" id="cb222"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> y <span class="op">=</span> <span class="dt">Box</span><span class="pp">::</span>new(x)<span class="op">;</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> <span class="op">*</span>y)<span class="op">;</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>Defining Our Own Smart Pointer.</li>
</ol>
<div class="sourceCode" id="cb223"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Deref</span><span class="op">;</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> CustomBox<span class="op">&lt;</span>T<span class="op">&gt;</span>(T)<span class="op">;</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> CustomBox<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> new(x<span class="op">:</span> T) <span class="op">-&gt;</span> CustomBox<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>                CustomBox(x)</span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">Deref</span> <span class="cf">for</span> CustomBox<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> deref(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">Self</span><span class="pp">::</span>Target <span class="op">{</span></span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span><span class="dv">0</span></span>
<span id="cb223-16"><a href="#cb223-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb223-17"><a href="#cb223-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-18"><a href="#cb223-18" aria-hidden="true" tabindex="-1"></a>            <span class="co">/* Could also be</span></span>
<span id="cb223-19"><a href="#cb223-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-20"><a href="#cb223-20" aria-hidden="true" tabindex="-1"></a><span class="co">            fn deref(&amp;self) -&gt; &amp;CustomBox&lt;T&gt;::Target {</span></span>
<span id="cb223-21"><a href="#cb223-21" aria-hidden="true" tabindex="-1"></a><span class="co">                &amp;self.0</span></span>
<span id="cb223-22"><a href="#cb223-22" aria-hidden="true" tabindex="-1"></a><span class="co">            }</span></span>
<span id="cb223-23"><a href="#cb223-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-24"><a href="#cb223-24" aria-hidden="true" tabindex="-1"></a><span class="co">            */</span></span>
<span id="cb223-25"><a href="#cb223-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb223-26"><a href="#cb223-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-27"><a href="#cb223-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="bu">DerefMut</span> <span class="cf">for</span> CustomBox<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb223-28"><a href="#cb223-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">type</span> Target <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb223-29"><a href="#cb223-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-30"><a href="#cb223-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> deref_mut(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">Self</span><span class="pp">::</span>Target <span class="op">{</span></span>
<span id="cb223-31"><a href="#cb223-31" aria-hidden="true" tabindex="-1"></a>                <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span></span>
<span id="cb223-32"><a href="#cb223-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb223-33"><a href="#cb223-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb223-34"><a href="#cb223-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-35"><a href="#cb223-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb223-36"><a href="#cb223-36" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb223-37"><a href="#cb223-37" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> y <span class="op">=</span> <span class="pp">CustomBox::</span>new(x)<span class="op">;</span></span>
<span id="cb223-38"><a href="#cb223-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-39"><a href="#cb223-39" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb223-40"><a href="#cb223-40" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> <span class="op">*</span>y)<span class="op">;</span></span>
<span id="cb223-41"><a href="#cb223-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-42"><a href="#cb223-42" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="op">&amp;</span><span class="dv">5</span><span class="op">,</span> y<span class="op">.</span>deref())<span class="op">;</span></span>
<span id="cb223-43"><a href="#cb223-43" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(<span class="dv">5</span><span class="op">,</span> <span class="op">*</span>(y<span class="op">.</span>deref()))<span class="op">;</span></span>
<span id="cb223-44"><a href="#cb223-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-45"><a href="#cb223-45" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Actually `*y` is shorthand for `*(y.deref())`</span></span>
<span id="cb223-46"><a href="#cb223-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li><strong>Deref coercion</strong> converts a reference to a type that
implements the <code>Deref</code> trait into a reference to another
type.<br />
For example, deref coercion can convert <code>&amp;String</code> to
<code>&amp;str</code> because <code>String</code> implements the
<code>Deref</code> trait such that it returns
<code>&amp;str</code>.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li><strong>Deref coercion</strong> is a convenience Rust performs on
arguments to functions and methods, and works on types that implement
the <code>Deref</code> trait.<br />
And also works ONLY on references, not owned values!<br />
It happens automatically when we pass a reference to a particular type‚Äôs
value as an argument to a function or method that doesn‚Äôt match the
parameter type in the function or method definition. &gt; A sequence of
calls to the <code>deref()</code> method converts the type we provided
into the type the parameter needs. &gt; <strong>Deref coercion</strong>
was added to Rust so that programmers writing function and method calls
don‚Äôt need to add as many explicit references and dereferences with
<code>&amp;</code> and <code>*</code>.</li>
</ol>
<div class="sourceCode" id="cb224"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> name <span class="op">=</span> <span class="pp">CustomBox::</span>new(<span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Rust&quot;</span>))<span class="op">;</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>            hello(<span class="op">&amp;</span>name)<span class="op">;</span></span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a>            <span class="co">// OR</span></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>            <span class="co">// hello(name.deref());</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>            <span class="co">// OR</span></span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// hello(&amp;(*name)[..]);</span></span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> hello(name<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Hello, {name}!&quot;</span>)<span class="op">;</span></span>
<span id="cb224-12"><a href="#cb224-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>Here we‚Äôre calling the <code>hello()</code> function with the
argument <code>&amp;name</code>, which is a reference to a
<code>CustomBox&lt;String&gt;</code> value.</li>
<li>Because we implemented the <code>Deref</code> trait on
<code>CustomBox&lt;T&gt;</code>, Rust can turn
<code>&amp;CustomBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref()</code>.</li>
<li>The standard library provides an implementation of
<code>Deref</code> on <code>String</code> that returns a string slice,
and this is in the API documentation for <code>Deref</code>.</li>
<li>Rust calls <code>deref()</code> again to turn the
<code>&amp;String</code> into <code>&amp;str</code>, which matches the
<code>hello()</code> function‚Äôs definition.</li>
</ul>
<p><br />
</p>
<ol start="7" type="1">
<li><p>Similar to how you use the <code>Deref</code> trait to override
the <code>*</code> operator on <strong>immutable
references</strong>,<br />
you can use the <code>DerefMut</code> trait to override the
<code>*</code> operator on <strong>mutable references</strong>.</p>
<p>Rust does <strong>deref coercion</strong> when it finds types and
trait implementations in three cases:</p>
<p>From <strong><code>&amp;T</code></strong> to
<strong><code>&amp;U</code></strong> when
<strong><code>T: Deref&lt;Target=U&gt;</code></strong></p>
<p>From <strong><code>&amp;mut T</code></strong> to
<strong><code>&amp;mut U</code></strong> when
<strong><code>T: DerefMut&lt;Target=U&gt;</code></strong></p>
<p>From <strong><code>&amp;mut T</code></strong> to
<strong><code>&amp;U</code></strong> when
<strong><code>T: Deref&lt;Target=U&gt;</code></strong></p></li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>In Rust, when you have a borrowed
<strong><code>struct</code></strong> (either immutable or
mutable),<br />
you can typically access its fields directly without needing to
dereference it with ( <code>*</code> ).<br />
Rust automatically dereferences references when accessing fields, thanks
to a feature called <strong>auto-dereferencing</strong>.</li>
</ol>
<div class="sourceCode" id="cb225"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_A(a<span class="op">:</span> <span class="op">&amp;</span>A) <span class="op">{</span></span>
<span id="cb225-6"><a href="#cb225-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> a<span class="op">.</span>value)<span class="op">;</span></span>
<span id="cb225-7"><a href="#cb225-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> (<span class="op">*</span>a)<span class="op">.</span>value)<span class="op">;</span></span>
<span id="cb225-8"><a href="#cb225-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb225-9"><a href="#cb225-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-10"><a href="#cb225-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> modify_A(a<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> A) <span class="op">{</span></span>
<span id="cb225-11"><a href="#cb225-11" aria-hidden="true" tabindex="-1"></a>        a<span class="op">.</span>value <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;aaaA&quot;</span>)<span class="op">;</span></span>
<span id="cb225-12"><a href="#cb225-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// (*a).value = String::from(&quot;aaaA&quot;);</span></span>
<span id="cb225-13"><a href="#cb225-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb225-14"><a href="#cb225-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb225-15"><a href="#cb225-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb225-16"><a href="#cb225-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a <span class="op">=</span> A <span class="op">{</span></span>
<span id="cb225-17"><a href="#cb225-17" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Aaaa&quot;</span>)<span class="op">,</span></span>
<span id="cb225-18"><a href="#cb225-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb225-19"><a href="#cb225-19" aria-hidden="true" tabindex="-1"></a>        print_A(<span class="op">&amp;</span>a)<span class="op">;</span></span>
<span id="cb225-20"><a href="#cb225-20" aria-hidden="true" tabindex="-1"></a>        modify_A(<span class="op">&amp;</span>a)<span class="op">;</span></span>
<span id="cb225-21"><a href="#cb225-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="the-drop-trait">The <code>Drop</code> Trait</h3>
<ol type="1">
<li>The second trait important to the smart pointer pattern is
<code>Drop</code>,<br />
which lets you customize what happens when a value is about to go out of
scope.<br />
You can provide an implementation for the <code>Drop</code> trait on any
type.</li>
</ol>
<div class="sourceCode" id="cb226"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> CustomPointer <span class="op">{</span></span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a>            data<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> <span class="bu">Drop</span> <span class="cf">for</span> CustomPointer <span class="op">{</span></span>
<span id="cb226-6"><a href="#cb226-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> drop(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb226-7"><a href="#cb226-7" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Dropping custom pointer with data: {}!&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>data)<span class="op">;</span></span>
<span id="cb226-8"><a href="#cb226-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb226-9"><a href="#cb226-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb226-10"><a href="#cb226-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-11"><a href="#cb226-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb226-12"><a href="#cb226-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> p1 <span class="op">=</span> CustomPointer <span class="op">{</span></span>
<span id="cb226-13"><a href="#cb226-13" aria-hidden="true" tabindex="-1"></a>                data<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;A&quot;</span>)<span class="op">,</span></span>
<span id="cb226-14"><a href="#cb226-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb226-15"><a href="#cb226-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> p2 <span class="op">=</span> CustomPointer <span class="op">{</span></span>
<span id="cb226-16"><a href="#cb226-16" aria-hidden="true" tabindex="-1"></a>                data<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;B&quot;</span>)<span class="op">,</span></span>
<span id="cb226-17"><a href="#cb226-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb226-18"><a href="#cb226-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb226-19"><a href="#cb226-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-20"><a href="#cb226-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; B</span></span>
<span id="cb226-21"><a href="#cb226-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; A</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Explicitly calling <code>.drop()</code> is not possible.<br />
So try dropping a value early with <code>std::mem::drop()</code>.</li>
</ol>
<div class="sourceCode" id="cb227"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::mem::</span>drop<span class="op">;</span></span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> p1 <span class="op">=</span> CustomPointer <span class="op">{</span></span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a>                data<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;A&quot;</span>)<span class="op">,</span></span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> p2 <span class="op">=</span> CustomPointer <span class="op">{</span></span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>                data<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;B&quot;</span>)<span class="op">,</span></span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">};</span></span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a>            drop(p1)<span class="op">;</span></span>
<span id="cb227-12"><a href="#cb227-12" aria-hidden="true" tabindex="-1"></a>            drop(p2)<span class="op">;</span></span>
<span id="cb227-13"><a href="#cb227-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb227-14"><a href="#cb227-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-15"><a href="#cb227-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; A</span></span>
<span id="cb227-16"><a href="#cb227-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; B</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>You cannot call <code>std::mem::drop()</code> on types that
implement the <code>Copy</code> trait because types that implement
<code>Copy</code> are implicitly copied rather than moved.</li>
</ol>
<hr/>
<h3
id="rct-the-reference-counted-smart-pointer."><code>Rc&lt;T&gt;</code>,
the Reference Counted Smart Pointer.</h3>
<ol type="1">
<li>You could enable multiple ownership explicitly by using the Rust
type <code>Rc&lt;T&gt;</code>, <strong>reference
counting</strong>.<br />
The <code>Rc&lt;T&gt;</code> type keeps track of the number of
references to a value to determine whether or not the value is still in
use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Note that <code>Rc&lt;T&gt;</code> is only for use in
<strong>single-threaded</strong> scenarios.<br />
When we discuss concurrency in later chapters, we‚Äôll cover how to do
reference counting in multithreaded programs.</li>
</ol>
<div class="sourceCode" id="cb228"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>        <span class="kw">enum</span> LinkedList <span class="op">{</span></span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>            Data(<span class="dt">i32</span><span class="op">,</span> Rc<span class="op">&lt;</span>LinkedList<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Nil</span><span class="op">,</span></span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::LinkedList::</span><span class="op">{</span>Data<span class="op">,</span> <span class="cn">Nil</span><span class="op">};</span></span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-9"><a href="#cb228-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb228-10"><a href="#cb228-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> a <span class="op">=</span> <span class="pp">Rc::</span>new(Data(<span class="dv">1</span><span class="op">,</span> <span class="pp">Rc::</span>new(Data(<span class="dv">2</span><span class="op">,</span> <span class="pp">Rc::</span>new(<span class="cn">Nil</span>)))))<span class="op">;</span></span>
<span id="cb228-11"><a href="#cb228-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> b <span class="op">=</span> Data(<span class="dv">3</span><span class="op">,</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))<span class="op">;</span></span>
<span id="cb228-12"><a href="#cb228-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> c <span class="op">=</span> Data(<span class="dv">4</span><span class="op">,</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))<span class="op">;</span></span>
<span id="cb228-13"><a href="#cb228-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-14"><a href="#cb228-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb228-15"><a href="#cb228-15" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> d <span class="op">=</span> Data(<span class="dv">5</span><span class="op">,</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))<span class="op">;</span></span>
<span id="cb228-16"><a href="#cb228-16" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>a))<span class="op">;</span>   <span class="co">// -&gt; 4</span></span>
<span id="cb228-17"><a href="#cb228-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb228-18"><a href="#cb228-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-19"><a href="#cb228-19" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>a))<span class="op">;</span>       <span class="co">// -&gt; 3</span></span>
<span id="cb228-20"><a href="#cb228-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span></code></pre></div>
<ul>
<li>We could have called <code>a.clone()</code> rather than
<code>Rc::clone(&amp;a)</code>, but Rust‚Äôs convention is to use
<code>Rc::clone()</code> in this case.</li>
<li>The implementation of <code>Rc::clone()</code> doesn‚Äôt make a deep
copy of all the data like most types‚Äô implementations of
<code>clone()</code> do.</li>
<li>The call to <code>Rc::clone()</code> only increments the reference
count, which doesn‚Äôt take much time.</li>
<li>Deep copies of data can take a lot of time. By using
<code>Rc::clone()</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of
clones that increase the reference count.</li>
<li>When looking for performance problems in the code, we only need to
consider the deep-copy clones and can disregard calls to
<code>Rc::clone()</code>.</li>
</ul>
<hr/>
<h3
id="refcellt-and-the-interior-mutability-pattern"><code>RefCell&lt;T&gt;</code>
and the Interior Mutability Pattern</h3>
<ol type="1">
<li><p><strong>Interior mutability</strong> is a design pattern in Rust
that allows you to mutate data even when there are immutable references
to that data.</p>
<p>Normally, this action is disallowed by the borrowing rules.<br />
To mutate data, the pattern uses <code>unsafe</code> code inside a data
structure to bend Rust‚Äôs usual rules that govern mutation and borrowing.
Unsafe code indicates to the compiler that we‚Äôre checking the rules
manually instead of relying on the compiler to check them for
us.</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We can use types that use the <strong>interior mutability</strong>
pattern only when we can ensure that the borrowing rules will be
followed at runtime, even though the compiler can‚Äôt guarantee that. The
<code>unsafe</code> code involved is then wrapped in a safe API, and the
outer type is still immutable.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code>
type represents single ownership over the data it holds.<br />
Remember that at any given time, you can have either (but not both) one
mutable reference or any number of immutable references. References must
always be valid.<br />
With references and <code>Box&lt;T&gt;</code>, the borrowing rules‚Äô
invariants are enforced at <strong>compile time</strong>.<br />
With <code>RefCell&lt;T&gt;</code>, these invariants are enforced at
<strong>runtime</strong>.<br />
With references, if you break these rules, you‚Äôll get a <strong>compiler
error</strong>.<br />
With <code>RefCell&lt;T&gt;</code>, if you break these rules, your
program will <strong>panic and exit</strong>.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Because some analysis is impossible, if the Rust compiler can‚Äôt be
sure the code complies with the ownership rules, it might reject a
correct program, in this way, it‚Äôs conservative.<br />
If Rust accepted an incorrect program, users wouldn‚Äôt be able to trust
in the guarantees Rust makes.<br />
However, if Rust rejects a correct program, the programmer will be
inconvenienced, but nothing catastrophic can occur. The
<code>RefCell&lt;T&gt;</code> type is useful when you‚Äôre sure your code
follows the borrowing rules but the compiler is unable to understand and
guarantee that.</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code>
is only for use in <strong>single-threaded</strong> scenarios and will
give you a compile-time error if you try using it in a multithreaded
context.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li><p>Here is a recap of the reasons to choose
<code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or
<code>RefCell&lt;T&gt;</code>:</p>
<p><code>Rc&lt;T&gt;</code> enables <em>multiple owners</em> of the same
data. <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code> have
<em>single owners</em>.</p>
<p><code>Box&lt;T&gt;</code> allows <em>immutable</em> or <em>mutable
borrows</em> checked at <strong>compile time</strong>.
<code>Rc&lt;T&gt;</code> allows only <em>immutable borrows</em> checked
at <strong>compile time</strong>. <code>RefCell&lt;T&gt;</code> allows
<em>immutable</em> or <em>mutable borrows</em> checked at
<strong>runtime</strong>.</p>
<p>Because <code>RefCell&lt;T&gt;</code> allows <em>mutable borrows</em>
checked at <strong>runtime</strong>, you can mutate the value inside the
<code>RefCell&lt;T&gt;</code> even when the
<code>RefCell&lt;T&gt;</code> is <em>immutable</em>.</p></li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li><p>A Use Case for Interior Mutability: <strong>Mock
Objects</strong>.<br />
Sometimes during testing a programmer will use a type in place of
another type,<br />
in order to observe particular behavior and assert it‚Äôs implemented
correctly. This placeholder type is called a <strong>test
double</strong>. <strong>Mock objects</strong> are specific types of
test doubles that record what happens during a test so you can assert
that the correct actions took place.</p>
<p>Example for this test doubles mock object:</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Define a trait for the database connection behavior</span></span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Database <span class="op">{</span></span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> query(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> query<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">&gt;;</span></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Real implementation of DatabaseConnection</span></span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a><span class="co">// In a real-world scenario, this would actually connect to a database.</span></span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> DatabaseConnection<span class="op">;</span></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Database <span class="cf">for</span> DatabaseConnection <span class="op">{</span></span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> query(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> query<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Here you&#39;d normally connect to the actual database</span></span>
<span id="cb229-13"><a href="#cb229-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// For the sake of the example, this is just a placeholder</span></span>
<span id="cb229-14"><a href="#cb229-14" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(<span class="st">&quot;Real data from database&quot;</span><span class="op">.</span>to_string())</span>
<span id="cb229-15"><a href="#cb229-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-16"><a href="#cb229-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb229-17"><a href="#cb229-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-18"><a href="#cb229-18" aria-hidden="true" tabindex="-1"></a><span class="co">// (Test double) Mock implementation of DatabaseConnection</span></span>
<span id="cb229-19"><a href="#cb229-19" aria-hidden="true" tabindex="-1"></a><span class="co">// This is used for testing, returning mock data instead of real database interaction.</span></span>
<span id="cb229-20"><a href="#cb229-20" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MockDatabaseConnection<span class="op">;</span></span>
<span id="cb229-21"><a href="#cb229-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-22"><a href="#cb229-22" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Database <span class="cf">for</span> MockDatabaseConnection <span class="op">{</span></span>
<span id="cb229-23"><a href="#cb229-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> query(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> query<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb229-24"><a href="#cb229-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> query <span class="op">==</span> <span class="st">&quot;SELECT * FROM users;&quot;</span> <span class="op">{</span></span>
<span id="cb229-25"><a href="#cb229-25" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(<span class="st">&quot;Mock data&quot;</span><span class="op">.</span>to_string()) <span class="co">// Return mock data</span></span>
<span id="cb229-26"><a href="#cb229-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb229-27"><a href="#cb229-27" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(<span class="st">&quot;Query failed&quot;</span>) <span class="co">// Simulate a failure for other queries</span></span>
<span id="cb229-28"><a href="#cb229-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb229-29"><a href="#cb229-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb229-30"><a href="#cb229-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb229-31"><a href="#cb229-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-32"><a href="#cb229-32" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb229-33"><a href="#cb229-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Using the real database connection</span></span>
<span id="cb229-34"><a href="#cb229-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> real_db <span class="op">=</span> DatabaseConnection<span class="op">;</span></span>
<span id="cb229-35"><a href="#cb229-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> result <span class="op">=</span> real_db<span class="op">.</span>query(<span class="st">&quot;SELECT * FROM users;&quot;</span>)<span class="op">;</span></span>
<span id="cb229-36"><a href="#cb229-36" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Real DB result: {:?}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb229-37"><a href="#cb229-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-38"><a href="#cb229-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Using the mock database connection for testing</span></span>
<span id="cb229-39"><a href="#cb229-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mock_db <span class="op">=</span> MockDatabaseConnection<span class="op">;</span></span>
<span id="cb229-40"><a href="#cb229-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> mock_result <span class="op">=</span> mock_db<span class="op">.</span>query(<span class="st">&quot;SELECT * FROM users;&quot;</span>)<span class="op">;</span></span>
<span id="cb229-41"><a href="#cb229-41" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Mock DB result: {:?}&quot;</span><span class="op">,</span> mock_result)<span class="op">;</span></span>
<span id="cb229-42"><a href="#cb229-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>Now consider the following scenario.</p></li>
</ol>
<blockquote>
<ul>
<li>src/lib.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb230"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">trait</span> Messenger <span class="op">{</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> send(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> msg<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">struct</span> LimitTracker<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">:</span> Messenger<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a>        messenger<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> T<span class="op">,</span></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>        max<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> LimitTracker<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span></span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a>        T<span class="op">:</span> Messenger<span class="op">,</span></span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> new(messenger<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> T<span class="op">,</span> max<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> LimitTracker<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a>            LimitTracker <span class="op">{</span></span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a>                messenger<span class="op">,</span></span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>                value<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>                max<span class="op">,</span></span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-22"><a href="#cb230-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-23"><a href="#cb230-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">fn</span> set_value(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> value<span class="op">:</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb230-24"><a href="#cb230-24" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>value <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb230-25"><a href="#cb230-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-26"><a href="#cb230-26" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> percentage_of_max <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>value <span class="kw">as</span> <span class="dt">f64</span> <span class="op">/</span> <span class="kw">self</span><span class="op">.</span>max <span class="kw">as</span> <span class="dt">f64</span><span class="op">;</span></span>
<span id="cb230-27"><a href="#cb230-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-28"><a href="#cb230-28" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> percentage_of_max <span class="op">&gt;=</span> <span class="dv">1.0</span> <span class="op">{</span></span>
<span id="cb230-29"><a href="#cb230-29" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span></span>
<span id="cb230-30"><a href="#cb230-30" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>messenger</span>
<span id="cb230-31"><a href="#cb230-31" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>send(<span class="st">&quot;Error: You are over your quota!&quot;</span>)<span class="op">;</span></span>
<span id="cb230-32"><a href="#cb230-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> percentage_of_max <span class="op">&gt;=</span> <span class="dv">0.9</span> <span class="op">{</span></span>
<span id="cb230-33"><a href="#cb230-33" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span></span>
<span id="cb230-34"><a href="#cb230-34" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>messenger</span>
<span id="cb230-35"><a href="#cb230-35" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>send(<span class="st">&quot;Urgent warning: You&#39;ve used up over 90% of your quota!&quot;</span>)<span class="op">;</span></span>
<span id="cb230-36"><a href="#cb230-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> percentage_of_max <span class="op">&gt;=</span> <span class="dv">0.75</span> <span class="op">{</span></span>
<span id="cb230-37"><a href="#cb230-37" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span></span>
<span id="cb230-38"><a href="#cb230-38" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>messenger</span>
<span id="cb230-39"><a href="#cb230-39" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>send(<span class="st">&quot;Warning: You&#39;ve used up over 75% of your quota!&quot;</span>)<span class="op">;</span></span>
<span id="cb230-40"><a href="#cb230-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb230-41"><a href="#cb230-41" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span></span>
<span id="cb230-42"><a href="#cb230-42" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>messenger</span>
<span id="cb230-43"><a href="#cb230-43" aria-hidden="true" tabindex="-1"></a>                    <span class="op">.</span>send(<span class="st">&quot;Info: You&#39;ve used less than 75% of your quota!&quot;</span>)<span class="op">;</span></span>
<span id="cb230-44"><a href="#cb230-44" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb230-45"><a href="#cb230-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-46"><a href="#cb230-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb230-47"><a href="#cb230-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-48"><a href="#cb230-48" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb230-49"><a href="#cb230-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb230-50"><a href="#cb230-50" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb230-51"><a href="#cb230-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-52"><a href="#cb230-52" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> MockMessenger <span class="op">{</span></span>
<span id="cb230-53"><a href="#cb230-53" aria-hidden="true" tabindex="-1"></a>            messages<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;,</span></span>
<span id="cb230-54"><a href="#cb230-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-55"><a href="#cb230-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-56"><a href="#cb230-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> MockMessenger <span class="op">{</span></span>
<span id="cb230-57"><a href="#cb230-57" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> new() <span class="op">-&gt;</span> MockMessenger <span class="op">{</span></span>
<span id="cb230-58"><a href="#cb230-58" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb230-59"><a href="#cb230-59" aria-hidden="true" tabindex="-1"></a>                    messages<span class="op">:</span> <span class="pp">vec!</span>[]<span class="op">,</span></span>
<span id="cb230-60"><a href="#cb230-60" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb230-61"><a href="#cb230-61" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb230-62"><a href="#cb230-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-63"><a href="#cb230-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-64"><a href="#cb230-64" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Messenger <span class="cf">for</span> MockMessenger <span class="op">{</span></span>
<span id="cb230-65"><a href="#cb230-65" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> send(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb230-66"><a href="#cb230-66" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span><span class="op">.</span>messages<span class="op">.</span>push(<span class="dt">String</span><span class="pp">::</span>from(message))<span class="op">;</span></span>
<span id="cb230-67"><a href="#cb230-67" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb230-68"><a href="#cb230-68" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-69"><a href="#cb230-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-70"><a href="#cb230-70" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb230-71"><a href="#cb230-71" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> over_75_percent_warning_test() <span class="op">{</span></span>
<span id="cb230-72"><a href="#cb230-72" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> mock_messenger <span class="op">=</span> <span class="pp">MockMessenger::</span>new()<span class="op">;</span></span>
<span id="cb230-73"><a href="#cb230-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-74"><a href="#cb230-74" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> limit_tracker <span class="op">=</span> <span class="pp">LimitTracker::</span>new(<span class="op">&amp;</span>mock_messenger<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb230-75"><a href="#cb230-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-76"><a href="#cb230-76" aria-hidden="true" tabindex="-1"></a>            limit_tracker<span class="op">.</span>set_value(<span class="dv">80</span>)<span class="op">;</span></span>
<span id="cb230-77"><a href="#cb230-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-78"><a href="#cb230-78" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(mock_messenger<span class="op">.</span>messages<span class="op">.</span>len()<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb230-79"><a href="#cb230-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb230-80"><a href="#cb230-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>However, there‚Äôs one problem with this test, as shown here:</li>
</ul>
<div class="sourceCode" id="cb231"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Messenger <span class="cf">for</span> MockMessenger <span class="op">{</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> send(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>messages<span class="op">.</span>push(<span class="dt">String</span><span class="pp">::</span>from(message))<span class="op">;</span></span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      ^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable.</span></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Clearly we can solve the problem via
<code>fn send(&amp;mut self, msg: &amp;str);</code> changing its
signature, but here it won‚Äôt work.</li>
<li>Because then the signature of <code>send()</code> wouldn‚Äôt match the
signature in the <code>Messenger</code> trait definition. &gt;</li>
<li>This is a situation in which interior mutability can help!</li>
</ul>
<div class="sourceCode" id="cb232"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> MockMessenger <span class="op">{</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a>            messages<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;&gt;,</span></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> MockMessenger <span class="op">{</span></span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> new() <span class="op">-&gt;</span> MockMessenger <span class="op">{</span></span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a>                    messages<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">vec!</span>[])<span class="op">,</span></span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb232-15"><a href="#cb232-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb232-16"><a href="#cb232-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb232-17"><a href="#cb232-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-18"><a href="#cb232-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> Messenger <span class="cf">for</span> MockMessenger <span class="op">{</span></span>
<span id="cb232-19"><a href="#cb232-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> send(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb232-20"><a href="#cb232-20" aria-hidden="true" tabindex="-1"></a>                <span class="kw">self</span><span class="op">.</span>messages<span class="op">.</span>borrow_mut()<span class="op">.</span>push(<span class="dt">String</span><span class="pp">::</span>from(message))<span class="op">;</span></span>
<span id="cb232-21"><a href="#cb232-21" aria-hidden="true" tabindex="-1"></a>                <span class="co">// EXPLICITY DEREF</span></span>
<span id="cb232-22"><a href="#cb232-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">// *(self.messages.borrow_mut()).push(String::from(message));</span></span>
<span id="cb232-23"><a href="#cb232-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb232-24"><a href="#cb232-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb232-25"><a href="#cb232-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-26"><a href="#cb232-26" aria-hidden="true" tabindex="-1"></a>        <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb232-27"><a href="#cb232-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> over_75_percent_warning_test() <span class="op">{</span></span>
<span id="cb232-28"><a href="#cb232-28" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> mock_messenger <span class="op">=</span> <span class="pp">MockMessenger::</span>new()<span class="op">;</span></span>
<span id="cb232-29"><a href="#cb232-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-30"><a href="#cb232-30" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> limit_tracker <span class="op">=</span> <span class="pp">LimitTracker::</span>new(<span class="op">&amp;</span>mock_messenger<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb232-31"><a href="#cb232-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-32"><a href="#cb232-32" aria-hidden="true" tabindex="-1"></a>            limit_tracker<span class="op">.</span>set_value(<span class="dv">80</span>)<span class="op">;</span></span>
<span id="cb232-33"><a href="#cb232-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-34"><a href="#cb232-34" aria-hidden="true" tabindex="-1"></a>            <span class="pp">assert_eq!</span>(mock_messenger<span class="op">.</span>messages<span class="op">.</span>borrow()<span class="op">.</span>len()<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb232-35"><a href="#cb232-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb232-36"><a href="#cb232-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li><p>When creating immutable and mutable references, we use the
<code>&amp;</code> and <code>&amp;mut</code> syntax, respectively.<br />
With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow()</code> and
<code>borrow_mut()</code> methods, which are part of the safe API that
belongs to it.<br />
The <code>borrow()</code> method returns the smart pointer type
<code>Ref&lt;T&gt;</code>, and <code>borrow_mut()</code> returns the
smart pointer type <code>RefMut&lt;T&gt;</code>.<br />
Both types implement <code>Deref</code>, so we can treat them like
regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many
<code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active.<br />
Every time we call <code>borrow()</code>, the
<code>RefCell&lt;T&gt;</code> increases its count of how many immutable
borrows are active.<br />
When a <code>Ref&lt;T&gt;</code> value goes out of scope, the count of
immutable borrows goes down by one.<br />
Just like the compile-time borrowing rules,
<code>RefCell&lt;T&gt;</code> lets us have <strong>many</strong>
immutable borrows or <strong>one</strong> mutable borrow at any point in
time.</p>
<p>Like this program will panic at runtime:</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Messenger <span class="cf">for</span> MockMessenger <span class="op">{</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> send(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> message<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> one_borrow <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>sent_messages<span class="op">.</span>borrow_mut()<span class="op">;</span></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> two_borrow <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>sent_messages<span class="op">.</span>borrow_mut()<span class="op">;</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a>        one_borrow<span class="op">.</span>push(<span class="dt">String</span><span class="pp">::</span>from(message))<span class="op">;</span></span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a>        two_borrow<span class="op">.</span>push(<span class="dt">String</span><span class="pp">::</span>from(message))<span class="op">;</span></span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<ul>
<li>Because it has two mutable borrows at the same time, namely
<code>one_borrow</code> and <code>two_borrow</code>!</li>
</ul>
<p><br />
</p>
<ol start="10" type="1">
<li>Having Multiple Owners of Mutable Data by Combining
<code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>.</li>
</ol>
<div class="sourceCode" id="cb234"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> LinkedList <span class="op">{</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>        Data(Rc<span class="op">&lt;</span>RefCell<span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;&gt;,</span> Rc<span class="op">&lt;</span>LinkedList<span class="op">&gt;</span>)<span class="op">,</span></span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Nil</span><span class="op">,</span></span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-7"><a href="#cb234-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::LinkedList::</span><span class="op">{</span>Data<span class="op">,</span> <span class="cn">Nil</span><span class="op">};</span></span>
<span id="cb234-8"><a href="#cb234-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb234-9"><a href="#cb234-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb234-10"><a href="#cb234-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-11"><a href="#cb234-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb234-12"><a href="#cb234-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> value <span class="op">=</span> <span class="pp">Rc::</span>new(<span class="pp">RefCell::</span>new(<span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb234-13"><a href="#cb234-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-14"><a href="#cb234-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a <span class="op">=</span> <span class="pp">Rc::</span>new( Data(<span class="pp">Rc::</span>clone(<span class="op">&amp;</span>value)<span class="op">,</span> <span class="pp">Rc::</span>new(<span class="cn">Nil</span>)) )<span class="op">;</span></span>
<span id="cb234-15"><a href="#cb234-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-16"><a href="#cb234-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> b <span class="op">=</span> Data(<span class="pp">Rc::</span>new(<span class="pp">RefCell::</span>new(<span class="dv">1</span>))<span class="op">,</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))<span class="op">;</span></span>
<span id="cb234-17"><a href="#cb234-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-18"><a href="#cb234-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> c <span class="op">=</span> Data(<span class="pp">Rc::</span>new(<span class="pp">RefCell::</span>new(<span class="dv">2</span>))<span class="op">,</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))<span class="op">;</span></span>
<span id="cb234-19"><a href="#cb234-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-20"><a href="#cb234-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// DO NOT USE value.borrow_mut() += 10;</span></span>
<span id="cb234-21"><a href="#cb234-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// here value.borrow_mut() returns a RefMut&lt;i32&gt;,</span></span>
<span id="cb234-22"><a href="#cb234-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// RefMut is a smart pointer,</span></span>
<span id="cb234-23"><a href="#cb234-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Rust‚Äôs auto-dereferencing behavior kicks in when you‚Äôre calling ``methods`` on types wrapped in smart pointers,</span></span>
<span id="cb234-24"><a href="#cb234-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// but operations like `+=` has to be derefed to call.</span></span>
<span id="cb234-25"><a href="#cb234-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>value<span class="op">.</span>borrow_mut() <span class="op">+=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb234-26"><a href="#cb234-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb234-27"><a href="#cb234-27" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{a:?}&quot;</span>)<span class="op">;</span>  <span class="co">// -&gt; Data(RefCell { value: 15 }, Nil)</span></span>
<span id="cb234-28"><a href="#cb234-28" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{b:?}&quot;</span>)<span class="op">;</span>  <span class="co">// -&gt; Data(RefCell { value: 1 }, Data(RefCell { value: 15 }, Nil))</span></span>
<span id="cb234-29"><a href="#cb234-29" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{c:?}&quot;</span>)<span class="op">;</span>  <span class="co">// -&gt; Data(RefCell { value: 2 }, Data(RefCell { value: 15 }, Nil))</span></span>
<span id="cb234-30"><a href="#cb234-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="reference-cycles-can-leak-memory">Reference Cycles Can Leak
Memory</h3>
<ol type="1">
<li>Rust‚Äôs memory safety guarantees make it difficult, but not
impossible, to accidentally create memory that is never cleaned up
(known as a memory leak).<br />
Preventing memory leaks entirely is not one of Rust‚Äôs guarantees,
meaning memory leaks are memory safe in Rust.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>We can see that Rust allows memory leaks by using
<code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>,<br />
it‚Äôs possible to create references where items refer to each other in a
cycle.<br />
This creates memory leaks because the reference count of each item in
the cycle will never reach <code>0</code>, and the values will never be
dropped.</li>
</ol>
<div class="sourceCode" id="cb235"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::LinkedList::</span><span class="op">{</span>Data<span class="op">,</span> <span class="cn">Nil</span><span class="op">};</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::rc::</span>Rc<span class="op">;</span></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> LinkedList <span class="op">{</span></span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>        Data(<span class="dt">i32</span><span class="op">,</span> RefCell<span class="op">&lt;</span>Rc<span class="op">&lt;</span>LinkedList<span class="op">&gt;&gt;</span>)<span class="op">,</span></span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Nil</span><span class="op">,</span></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> LinkedList <span class="op">{</span></span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> tail(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;&amp;</span>RefCell<span class="op">&lt;</span>Rc<span class="op">&lt;</span>List<span class="op">&gt;&gt;&gt;</span> <span class="op">{</span></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a>                Data(_<span class="op">,</span> item) <span class="op">=&gt;</span> <span class="cn">Some</span>(item)<span class="op">,</span></span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Nil</span> <span class="op">=&gt;</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb235-16"><a href="#cb235-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb235-17"><a href="#cb235-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-18"><a href="#cb235-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb235-19"><a href="#cb235-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-20"><a href="#cb235-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// In case if you wonder why Option above has to be a reference inside type.</span></span>
<span id="cb235-21"><a href="#cb235-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This struct could explain a lot!</span></span>
<span id="cb235-22"><a href="#cb235-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb235-23"><a href="#cb235-23" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb235-24"><a href="#cb235-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb235-25"><a href="#cb235-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-26"><a href="#cb235-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> A <span class="op">{</span></span>
<span id="cb235-27"><a href="#cb235-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> tail(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb235-28"><a href="#cb235-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>value</span>
<span id="cb235-29"><a href="#cb235-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-30"><a href="#cb235-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-31"><a href="#cb235-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> tail2(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb235-32"><a href="#cb235-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="kw">self</span> <span class="op">{</span></span>
<span id="cb235-33"><a href="#cb235-33" aria-hidden="true" tabindex="-1"></a>                <span class="co">// ALSO WORKS</span></span>
<span id="cb235-34"><a href="#cb235-34" aria-hidden="true" tabindex="-1"></a>                <span class="co">// A { value } =&gt; value,</span></span>
<span id="cb235-35"><a href="#cb235-35" aria-hidden="true" tabindex="-1"></a>                A <span class="op">{</span> value<span class="op">,</span> <span class="op">..</span> <span class="op">}</span> <span class="op">=&gt;</span> value<span class="op">,</span></span>
<span id="cb235-36"><a href="#cb235-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb235-37"><a href="#cb235-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-38"><a href="#cb235-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb235-39"><a href="#cb235-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-40"><a href="#cb235-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb235-41"><a href="#cb235-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> a <span class="op">=</span> <span class="pp">Rc::</span>new(Data(<span class="dv">10</span><span class="op">,</span> <span class="pp">RefCell::</span>new(<span class="pp">Rc::</span>new(<span class="cn">Nil</span>))))<span class="op">;</span></span>
<span id="cb235-42"><a href="#cb235-42" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>a))<span class="op">;</span>   <span class="co">// -&gt; 1</span></span>
<span id="cb235-43"><a href="#cb235-43" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> a<span class="op">.</span>tail())<span class="op">;;</span>            <span class="co">// -&gt; Some(RefCell { value: Nil })</span></span>
<span id="cb235-44"><a href="#cb235-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-45"><a href="#cb235-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> b <span class="op">=</span> <span class="pp">Rc::</span>new(Data(<span class="dv">20</span><span class="op">,</span> <span class="pp">RefCell::</span>new(<span class="pp">Rc::</span>clone(<span class="op">&amp;</span>a))))<span class="op">;</span></span>
<span id="cb235-46"><a href="#cb235-46" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>a))<span class="op">;</span>   <span class="co">// -&gt; 2</span></span>
<span id="cb235-47"><a href="#cb235-47" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>b))<span class="op">;</span>   <span class="co">// -&gt; 1</span></span>
<span id="cb235-48"><a href="#cb235-48" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> b<span class="op">.</span>tail())<span class="op">;;</span>            <span class="co">// -&gt; Some(RefCell { value: Data(10, RefCell: { value: Nil }) })</span></span>
<span id="cb235-49"><a href="#cb235-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-50"><a href="#cb235-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(item) <span class="op">=</span> a<span class="op">.</span>tail() <span class="op">{</span></span>
<span id="cb235-51"><a href="#cb235-51" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>item<span class="op">.</span>borrow_mut() <span class="op">=</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>b)<span class="op">;</span></span>
<span id="cb235-52"><a href="#cb235-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb235-53"><a href="#cb235-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-54"><a href="#cb235-54" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>a))<span class="op">;</span>   <span class="co">// -&gt; 2</span></span>
<span id="cb235-55"><a href="#cb235-55" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>b))<span class="op">;</span>   <span class="co">// -&gt; 2</span></span>
<span id="cb235-56"><a href="#cb235-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-57"><a href="#cb235-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Uncomment the next line to see that we have a cycle, it will overflow the stack.</span></span>
<span id="cb235-58"><a href="#cb235-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">// println!(&quot;{:?}&quot;, a.tail());</span></span>
<span id="cb235-59"><a href="#cb235-59" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3
id="preventing-reference-cycles-turning-an-rct-into-a-weakt.">Preventing
Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a
<code>Weak&lt;T&gt;</code>.</h3>
<ol type="1">
<li>So far, we‚Äôve demonstrated that calling <code>Rc::clone()</code>
increases the <code>strong_count()</code> of an <code>Rc&lt;T&gt;</code>
instance,<br />
and an <code>Rc&lt;T&gt;</code> instance is only cleaned up if its
<code>strong_count()</code> is <code>0</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>However, You can also create a <strong>weak reference</strong> to
the value within an <code>Rc&lt;T&gt;</code> instance by calling
<code>Rc::downgrade()</code> and passing a reference to the
<code>Rc&lt;T&gt;</code>.<br />
<strong>Strong references</strong> are how you can share ownership of an
<code>Rc&lt;T&gt;</code> instance.<br />
<strong>Weak references</strong> don‚Äôt express an ownership
relationship, and their count doesn‚Äôt affect when an
<code>Rc&lt;T&gt;</code> instance is cleaned up. They won‚Äôt cause a
reference cycle because any cycle involving some weak references will be
broken once the strong reference count of values involved is
<code>0</code>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>When you call <code>Rc::downgrade()</code>, you get a smart pointer
of type <code>Weak&lt;T&gt;</code>.<br />
Instead of increasing the <code>strong_count()</code> in the
<code>Rc&lt;T&gt;</code> instance by <code>1</code>, calling
<code>Rc::downgrade()</code> increases the <code>weak_count()</code> by
<code>1</code>. The <code>Rc&lt;T&gt;</code> type uses
<code>weak_count()</code> to keep track of how many
<code>Weak&lt;T&gt;</code> references exist.<br />
The difference is the <code>weak_count()</code> doesn‚Äôt need to be
<code>0</code> for the <code>Rc&lt;T&gt;</code> instance to be cleaned
up.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Because the value that <code>Weak&lt;T&gt;</code> references might
have been dropped, so before doing anything with the value that a
<code>Weak&lt;T&gt;</code> is pointing to, you must make sure the value
still exists.<br />
Do this by calling the <code>upgrade()</code> method on a
<code>Weak&lt;T&gt;()</code> instance, which will return an
<code>Option&lt;Rc&lt;T&gt;&gt;</code>.<br />
You‚Äôll get a result of <code>Some</code> if the <code>Rc&lt;T&gt;</code>
value has not been dropped yet and a result of <code>None</code> if it
has been dropped.<br />
Because <code>upgrade()</code> returns an
<code>Option&lt;Rc&lt;T&gt;&gt;</code>, Rust will ensure that the
<code>Some</code> case and the <code>None</code> case are handled, and
there won‚Äôt be an invalid pointer.</li>
</ol>
<div class="sourceCode" id="cb236"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::cell::</span>RefCell<span class="op">;</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::rc::</span><span class="op">{</span>Rc<span class="op">,</span> Weak<span class="op">};</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Node <span class="op">{</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">:</span> RefCell<span class="op">&lt;</span>Weak<span class="op">&lt;</span>Node<span class="op">&gt;&gt;,</span></span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>        children<span class="op">:</span> RefCell<span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>Rc<span class="op">&lt;</span>Node<span class="op">&gt;&gt;&gt;,</span></span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb236-10"><a href="#cb236-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-11"><a href="#cb236-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb236-12"><a href="#cb236-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> leaf <span class="op">=</span> <span class="pp">Rc::</span>new(Node <span class="op">{</span></span>
<span id="cb236-13"><a href="#cb236-13" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb236-14"><a href="#cb236-14" aria-hidden="true" tabindex="-1"></a>            parent<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">Weak::</span>new())<span class="op">,</span></span>
<span id="cb236-15"><a href="#cb236-15" aria-hidden="true" tabindex="-1"></a>            children<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">vec!</span>[])<span class="op">,</span></span>
<span id="cb236-16"><a href="#cb236-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb236-17"><a href="#cb236-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-18"><a href="#cb236-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> leaf<span class="op">.</span>parent<span class="op">.</span>borrow()<span class="op">.</span>upgrade())<span class="op">;</span>   <span class="co">// -&gt; None</span></span>
<span id="cb236-19"><a href="#cb236-19" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> leaf)<span class="op">;</span>                             <span class="co">// -&gt;</span></span>
<span id="cb236-20"><a href="#cb236-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Node {</span></span>
<span id="cb236-21"><a href="#cb236-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      value: 10,</span></span>
<span id="cb236-22"><a href="#cb236-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      parent: RefCell {</span></span>
<span id="cb236-23"><a href="#cb236-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          value: (Weak),</span></span>
<span id="cb236-24"><a href="#cb236-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      },</span></span>
<span id="cb236-25"><a href="#cb236-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      children: RefCell {</span></span>
<span id="cb236-26"><a href="#cb236-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          value: [],</span></span>
<span id="cb236-27"><a href="#cb236-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      },</span></span>
<span id="cb236-28"><a href="#cb236-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  }</span></span>
<span id="cb236-29"><a href="#cb236-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-30"><a href="#cb236-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> branch <span class="op">=</span> <span class="pp">Rc::</span>new(Node <span class="op">{</span></span>
<span id="cb236-31"><a href="#cb236-31" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb236-32"><a href="#cb236-32" aria-hidden="true" tabindex="-1"></a>            parent<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">Weak::</span>new())<span class="op">,</span></span>
<span id="cb236-33"><a href="#cb236-33" aria-hidden="true" tabindex="-1"></a>            children<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">vec!</span>[<span class="pp">Rc::</span>clone(<span class="op">&amp;</span>leaf)])<span class="op">,</span></span>
<span id="cb236-34"><a href="#cb236-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb236-35"><a href="#cb236-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-36"><a href="#cb236-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>leaf<span class="op">.</span>parent<span class="op">.</span>borrow_mut() <span class="op">=</span> <span class="pp">Rc::</span>downgrade(<span class="op">&amp;</span>branch)<span class="op">;</span></span>
<span id="cb236-37"><a href="#cb236-37" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> leaf<span class="op">.</span>parent<span class="op">.</span>borrow()<span class="op">.</span>upgrade())<span class="op">;</span>   <span class="co">// -&gt;</span></span>
<span id="cb236-38"><a href="#cb236-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Some(</span></span>
<span id="cb236-39"><a href="#cb236-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  Node {</span></span>
<span id="cb236-40"><a href="#cb236-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      value: 5,</span></span>
<span id="cb236-41"><a href="#cb236-41" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      parent: RefCell { value: (Weak) },</span></span>
<span id="cb236-42"><a href="#cb236-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      children: RefCell {</span></span>
<span id="cb236-43"><a href="#cb236-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          value: [</span></span>
<span id="cb236-44"><a href="#cb236-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">//              Node {</span></span>
<span id="cb236-45"><a href="#cb236-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                  value: 10,</span></span>
<span id="cb236-46"><a href="#cb236-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                  parent: RefCell { value: (Weak) },</span></span>
<span id="cb236-47"><a href="#cb236-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">//                  children: RefCell { value: [] } }</span></span>
<span id="cb236-48"><a href="#cb236-48" aria-hidden="true" tabindex="-1"></a>        <span class="co">//          ]                                               -- value</span></span>
<span id="cb236-49"><a href="#cb236-49" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      }                                                   -- children: RefCell</span></span>
<span id="cb236-50"><a href="#cb236-50" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  }                                                       -- Node</span></span>
<span id="cb236-51"><a href="#cb236-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">// )                                                        -- Some</span></span>
<span id="cb236-52"><a href="#cb236-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-53"><a href="#cb236-53" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> leaf)<span class="op">;</span>                             <span class="co">// -&gt;</span></span>
<span id="cb236-54"><a href="#cb236-54" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Node {</span></span>
<span id="cb236-55"><a href="#cb236-55" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  value: 10,</span></span>
<span id="cb236-56"><a href="#cb236-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  parent: RefCell {</span></span>
<span id="cb236-57"><a href="#cb236-57" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      value: (Weak),</span></span>
<span id="cb236-58"><a href="#cb236-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  },</span></span>
<span id="cb236-59"><a href="#cb236-59" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  children: RefCell {</span></span>
<span id="cb236-60"><a href="#cb236-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">//      value: [],</span></span>
<span id="cb236-61"><a href="#cb236-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  },</span></span>
<span id="cb236-62"><a href="#cb236-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Visualizing Changes to <code>strong_count()</code> and
<code>weak_count()</code>.</li>
</ol>
<div class="sourceCode" id="cb237"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> leaf <span class="op">=</span> <span class="pp">Rc::</span>new(Node <span class="op">{</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>            value<span class="op">:</span> <span class="dv">3</span><span class="op">,</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a>            parent<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">Weak::</span>new())<span class="op">,</span></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>            children<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">vec!</span>[])<span class="op">,</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(</span>
<span id="cb237-9"><a href="#cb237-9" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;leaf strong = {}, weak = {}&quot;</span><span class="op">,</span>          <span class="co">// -&gt; leaf strong = 1, weak = 0</span></span>
<span id="cb237-10"><a href="#cb237-10" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-11"><a href="#cb237-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Rc::</span>weak_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-12"><a href="#cb237-12" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb237-13"><a href="#cb237-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-14"><a href="#cb237-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb237-15"><a href="#cb237-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> branch <span class="op">=</span> <span class="pp">Rc::</span>new(Node <span class="op">{</span></span>
<span id="cb237-16"><a href="#cb237-16" aria-hidden="true" tabindex="-1"></a>                value<span class="op">:</span> <span class="dv">5</span><span class="op">,</span></span>
<span id="cb237-17"><a href="#cb237-17" aria-hidden="true" tabindex="-1"></a>                parent<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">Weak::</span>new())<span class="op">,</span></span>
<span id="cb237-18"><a href="#cb237-18" aria-hidden="true" tabindex="-1"></a>                children<span class="op">:</span> <span class="pp">RefCell::</span>new(<span class="pp">vec!</span>[<span class="pp">Rc::</span>clone(<span class="op">&amp;</span>leaf)])<span class="op">,</span></span>
<span id="cb237-19"><a href="#cb237-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb237-20"><a href="#cb237-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-21"><a href="#cb237-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>leaf<span class="op">.</span>parent<span class="op">.</span>borrow_mut() <span class="op">=</span> <span class="pp">Rc::</span>downgrade(<span class="op">&amp;</span>branch)<span class="op">;</span></span>
<span id="cb237-22"><a href="#cb237-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-23"><a href="#cb237-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(</span>
<span id="cb237-24"><a href="#cb237-24" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;branch strong = {}, weak = {}&quot;</span><span class="op">,</span>    <span class="co">// -&gt; branch strong = 1, weak = 1</span></span>
<span id="cb237-25"><a href="#cb237-25" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>branch)<span class="op">,</span></span>
<span id="cb237-26"><a href="#cb237-26" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Rc::</span>weak_count(<span class="op">&amp;</span>branch)<span class="op">,</span></span>
<span id="cb237-27"><a href="#cb237-27" aria-hidden="true" tabindex="-1"></a>            )<span class="op">;</span></span>
<span id="cb237-28"><a href="#cb237-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-29"><a href="#cb237-29" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(</span>
<span id="cb237-30"><a href="#cb237-30" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;leaf strong = {}, weak = {}&quot;</span><span class="op">,</span>      <span class="co">// -&gt; leaf strong = 2, weak = 0</span></span>
<span id="cb237-31"><a href="#cb237-31" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-32"><a href="#cb237-32" aria-hidden="true" tabindex="-1"></a>                <span class="pp">Rc::</span>weak_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-33"><a href="#cb237-33" aria-hidden="true" tabindex="-1"></a>            )<span class="op">;</span></span>
<span id="cb237-34"><a href="#cb237-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb237-35"><a href="#cb237-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-36"><a href="#cb237-36" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;leaf parent = {:?}&quot;</span><span class="op">,</span> leaf<span class="op">.</span>parent<span class="op">.</span>borrow()<span class="op">.</span>upgrade())<span class="op">;</span> <span class="co">// -&gt; leaf parent = None</span></span>
<span id="cb237-37"><a href="#cb237-37" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(</span>
<span id="cb237-38"><a href="#cb237-38" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;leaf strong = {}, weak = {}&quot;</span><span class="op">,</span>          <span class="co">// -&gt; leaf strong = 1, weak = 0</span></span>
<span id="cb237-39"><a href="#cb237-39" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Rc::</span>strong_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-40"><a href="#cb237-40" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Rc::</span>weak_count(<span class="op">&amp;</span>leaf)<span class="op">,</span></span>
<span id="cb237-41"><a href="#cb237-41" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb237-42"><a href="#cb237-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="fearless-concurrency">Fearless Concurrency</h3>
<ol type="1">
<li>Programming languages implement threads in a few different
ways,<br />
and many operating systems provide an API the language can call for
creating new threads.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The Rust standard library uses a 1:1 model of thread
implementation,<br />
whereby a program uses one operating system thread per one language
thread.<br />
There are crates that implement other models of threading that make
different tradeoffs to the 1:1 model.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To create a new thread, we call the <code>thread::spawn()</code>
function<br />
and pass it a closure containing the code we want to run in the new
thread.</li>
</ol>
<div class="sourceCode" id="cb238"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::time::</span>Duration<span class="op">;</span></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;From thread: {}&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>                <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">;</span></span>
<span id="cb238-9"><a href="#cb238-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb238-10"><a href="#cb238-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb238-11"><a href="#cb238-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-12"><a href="#cb238-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span><span class="dv">5</span> <span class="op">{</span></span>
<span id="cb238-13"><a href="#cb238-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;From main: {}&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb238-14"><a href="#cb238-14" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">;</span></span>
<span id="cb238-15"><a href="#cb238-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb238-16"><a href="#cb238-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb238-17"><a href="#cb238-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-18"><a href="#cb238-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Possible output:</span></span>
<span id="cb238-19"><a href="#cb238-19" aria-hidden="true" tabindex="-1"></a><span class="co">        From main: 1</span></span>
<span id="cb238-20"><a href="#cb238-20" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 1</span></span>
<span id="cb238-21"><a href="#cb238-21" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 2</span></span>
<span id="cb238-22"><a href="#cb238-22" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 3</span></span>
<span id="cb238-23"><a href="#cb238-23" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 4</span></span>
<span id="cb238-24"><a href="#cb238-24" aria-hidden="true" tabindex="-1"></a><span class="co">        From main: 2</span></span>
<span id="cb238-25"><a href="#cb238-25" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 5</span></span>
<span id="cb238-26"><a href="#cb238-26" aria-hidden="true" tabindex="-1"></a><span class="co">        From main: 3</span></span>
<span id="cb238-27"><a href="#cb238-27" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 6</span></span>
<span id="cb238-28"><a href="#cb238-28" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 7</span></span>
<span id="cb238-29"><a href="#cb238-29" aria-hidden="true" tabindex="-1"></a><span class="co">        From main: 4</span></span>
<span id="cb238-30"><a href="#cb238-30" aria-hidden="true" tabindex="-1"></a><span class="co">        From thread: 8</span></span>
<span id="cb238-31"><a href="#cb238-31" aria-hidden="true" tabindex="-1"></a><span class="co">        From main: 5</span></span>
<span id="cb238-32"><a href="#cb238-32" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb238-33"><a href="#cb238-33" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb238-34"><a href="#cb238-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// From thread: 9</span></span>
<span id="cb238-35"><a href="#cb238-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">// From thread: 10</span></span>
<span id="cb238-36"><a href="#cb238-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">//</span></span>
<span id="cb238-37"><a href="#cb238-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">// are not printed because the main thread has been shutdown.</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>The return type of <code>thread::spawn()</code> is
<code>JoinHandle</code>.<br />
A <code>JoinHandle</code> is an owned value that, when we call the
<code>join()</code> method on it, will wait for its thread to
finish.</li>
</ol>
<div class="sourceCode" id="cb239"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::time::</span>Duration<span class="op">;</span></span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb239-7"><a href="#cb239-7" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;From thread: {}&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb239-8"><a href="#cb239-8" aria-hidden="true" tabindex="-1"></a>                <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">;</span></span>
<span id="cb239-9"><a href="#cb239-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb239-10"><a href="#cb239-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb239-11"><a href="#cb239-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-12"><a href="#cb239-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">1</span><span class="op">..=</span><span class="dv">5</span> <span class="op">{</span></span>
<span id="cb239-13"><a href="#cb239-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;From main: {}&quot;</span><span class="op">,</span> i)<span class="op">;</span></span>
<span id="cb239-14"><a href="#cb239-14" aria-hidden="true" tabindex="-1"></a>            <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_millis(<span class="dv">1000</span>))<span class="op">;</span></span>
<span id="cb239-15"><a href="#cb239-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb239-16"><a href="#cb239-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb239-17"><a href="#cb239-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// .unwrap() is used with Result&lt;T, E&gt; or Option&lt;T&gt;,</span></span>
<span id="cb239-18"><a href="#cb239-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// if the result is valid, it unwraps it, otherwise it directly panics the program.</span></span>
<span id="cb239-19"><a href="#cb239-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// So only use it when you are completely sure the program returns a valid result.</span></span>
<span id="cb239-20"><a href="#cb239-20" aria-hidden="true" tabindex="-1"></a>        handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb239-21"><a href="#cb239-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>We‚Äôll often use <code>move</code> with closures passed to
<code>thread::spawn()</code> because the closure will then take
ownership of the values it uses from the environment,<br />
thus transferring ownership of those values from one thread to another.
&gt; Consider the following example which will not compile:</li>
</ol>
<div class="sourceCode" id="cb240"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="op">||</span> <span class="op">{</span></span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Here&#39;s the vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a>        drop(v)<span class="op">;</span> <span class="co">// Oh NO!</span></span>
<span id="cb240-11"><a href="#cb240-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-12"><a href="#cb240-12" aria-hidden="true" tabindex="-1"></a>        handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb240-13"><a href="#cb240-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>Thus try to use `move` to transfer the ownership:</code></pre>
<div class="sourceCode" id="cb242"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Here&#39;s the vector: {:?}&quot;</span><span class="op">,</span> v)<span class="op">;</span></span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a>        handle<span class="op">.</span>join<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The <code>move</code> keyword overrides Rust‚Äôs conservative default
of borrowing,<br />
it doesn‚Äôt let us violate the ownership rules!</li>
</ul>
<p><br />
</p>
<ol start="6" type="1">
<li>One increasingly popular approach to ensuring safe concurrency is
<strong>message passing</strong>,<br />
where threads or actors communicate by sending each other messages
containing data.</li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li><p>To accomplish message-sending concurrency, Rust‚Äôs standard
library provides an implementation of <strong>channels</strong>.<br />
A <strong>channel</strong> is a general programming concept by which
data is sent from one thread to another.</p>
<p>You can imagine a <strong>channel</strong> in programming as being
like a directional channel of water, such as a stream or a river.<br />
If you put something like a rubber duck into a river, it will travel
downstream to the end of the waterway.</p></li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>A channel has two halves: a <strong>transmitter</strong> and a
<strong>receiver</strong>.<br />
The <strong>transmitter</strong> half is the upstream location where you
put rubber ducks into the river, and the <strong>receiver</strong> half
is where the rubber duck ends up downstream.<br />
One part of your code calls methods on the <strong>transmitter</strong>
with the <em>data you want to send</em>, and another part checks the
<strong>receiver</strong> end for <em>arriving messages</em>.<br />
A channel is said to be <strong>closed</strong> if <em>either</em> the
transmitter or receiver half is dropped.</li>
</ol>
<p><br />
</p>
<ol start="9" type="1">
<li>Here, we‚Äôll work up to a program that has one thread to generate
values and send them down a channel,<br />
and another thread that will receive the values and print them out.</li>
</ol>
<div class="sourceCode" id="cb243"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// multiple producer, single consumer (mpsc)</span></span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span>mpsc<span class="op">;</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb243-6"><a href="#cb243-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (tx<span class="op">,</span> rx) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb243-7"><a href="#cb243-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-8"><a href="#cb243-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb243-9"><a href="#cb243-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> hi <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hi&quot;</span>)<span class="op">;</span></span>
<span id="cb243-10"><a href="#cb243-10" aria-hidden="true" tabindex="-1"></a>            tx</span>
<span id="cb243-11"><a href="#cb243-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>send(hi)           <span class="co">// :Result&lt;T, E&gt;</span></span>
<span id="cb243-12"><a href="#cb243-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb243-13"><a href="#cb243-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb243-14"><a href="#cb243-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb243-15"><a href="#cb243-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> received <span class="op">=</span> rx</span>
<span id="cb243-16"><a href="#cb243-16" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>recv()     <span class="co">// :Result&lt;T, E&gt;</span></span>
<span id="cb243-17"><a href="#cb243-17" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb243-18"><a href="#cb243-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Got: {}&quot;</span><span class="op">,</span> received)<span class="op">;</span></span>
<span id="cb243-19"><a href="#cb243-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Rust‚Äôs standard library channel means a channel can have
<code>multiple sending</code> ends that produce values but only
<code>one receiving</code> end that consumes those values. &gt;</li>
<li>The <code>mpsc::channel()</code> function returns a tuple, the first
element of which is the sending end ‚Äì the transmitter, and the second
element is the receiving end ‚Äì the receiver. &gt;</li>
<li>The transmitter has a <code>send()</code> method that takes the
value we want to send. &gt;</li>
<li>The receiver has two useful methods: <code>recv()</code> and
<code>try_recv()</code>.
<ul>
<li><code>recv()</code>
<ul>
<li>Will block the calling thread‚Äôs execution and wait until a value is
sent down the channel.</li>
<li>When the transmitter closes, <code>recv()</code> will return an
<code>Err(E)</code> to signal that no more values will be coming.</li>
</ul></li>
<li><code>try_recv()</code>
<ul>
<li>Does NOT block, but will instead return a
<code>Result&lt;T, E&gt;</code> immediately.</li>
<li>An <code>Ok(T)</code> holding a message if one is available or an
<code>Err(E)</code> if there aren‚Äôt any messages this time.</li>
</ul></li>
</ul></li>
</ul>
<p><br />
</p>
<ol start="10" type="1">
<li>Sending Multiple Values and Seeing the Receiver Waiting.</li>
</ol>
<div class="sourceCode" id="cb244"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span>mpsc<span class="op">;</span></span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::time::</span>Duration<span class="op">;</span></span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (tx<span class="op">,</span> rx) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[</span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;A&quot;</span>)<span class="op">,</span></span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;B&quot;</span>)<span class="op">,</span></span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;C&quot;</span>)<span class="op">,</span></span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;D&quot;</span>)<span class="op">,</span></span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true" tabindex="-1"></a>            ]<span class="op">;</span></span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> v <span class="op">{</span></span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true" tabindex="-1"></a>                tx<span class="op">.</span>send(s)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true" tabindex="-1"></a>                <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb244-20"><a href="#cb244-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb244-21"><a href="#cb244-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-22"><a href="#cb244-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> received <span class="kw">in</span> tx <span class="op">{</span></span>
<span id="cb244-23"><a href="#cb244-23" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Got: {received}&quot;</span>)<span class="op">;</span></span>
<span id="cb244-24"><a href="#cb244-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb244-25"><a href="#cb244-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="11" type="1">
<li>Creating Multiple Producers by Cloning the Transmitter.</li>
</ol>
<div class="sourceCode" id="cb245"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span>mpsc<span class="op">;</span></span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::time::</span>Duration<span class="op">;</span></span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (tx<span class="op">,</span> rx) <span class="op">=</span> <span class="pp">mpsc::</span>channel()<span class="op">;</span></span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-8"><a href="#cb245-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tx1 <span class="op">=</span> tx<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb245-9"><a href="#cb245-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb245-10"><a href="#cb245-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[</span>
<span id="cb245-11"><a href="#cb245-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;A&quot;</span>)<span class="op">,</span></span>
<span id="cb245-12"><a href="#cb245-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;B&quot;</span>)<span class="op">,</span></span>
<span id="cb245-13"><a href="#cb245-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;C&quot;</span>)<span class="op">,</span></span>
<span id="cb245-14"><a href="#cb245-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;D&quot;</span>)<span class="op">,</span></span>
<span id="cb245-15"><a href="#cb245-15" aria-hidden="true" tabindex="-1"></a>            ]<span class="op">;</span></span>
<span id="cb245-16"><a href="#cb245-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-17"><a href="#cb245-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> v <span class="op">{</span></span>
<span id="cb245-18"><a href="#cb245-18" aria-hidden="true" tabindex="-1"></a>                tx1<span class="op">.</span>send(s)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb245-19"><a href="#cb245-19" aria-hidden="true" tabindex="-1"></a>                <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb245-20"><a href="#cb245-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb245-21"><a href="#cb245-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb245-22"><a href="#cb245-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-23"><a href="#cb245-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tx2 <span class="op">=</span> tx<span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb245-24"><a href="#cb245-24" aria-hidden="true" tabindex="-1"></a>        <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb245-25"><a href="#cb245-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[</span>
<span id="cb245-26"><a href="#cb245-26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;X&quot;</span>)<span class="op">,</span></span>
<span id="cb245-27"><a href="#cb245-27" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Y&quot;</span>)<span class="op">,</span></span>
<span id="cb245-28"><a href="#cb245-28" aria-hidden="true" tabindex="-1"></a>                <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Z&quot;</span>)<span class="op">,</span></span>
<span id="cb245-29"><a href="#cb245-29" aria-hidden="true" tabindex="-1"></a>            ]<span class="op">;</span></span>
<span id="cb245-30"><a href="#cb245-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-31"><a href="#cb245-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> s <span class="kw">in</span> v <span class="op">{</span></span>
<span id="cb245-32"><a href="#cb245-32" aria-hidden="true" tabindex="-1"></a>                tx2<span class="op">.</span>send(s)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb245-33"><a href="#cb245-33" aria-hidden="true" tabindex="-1"></a>                <span class="pp">thread::</span>sleep(<span class="pp">Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb245-34"><a href="#cb245-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb245-35"><a href="#cb245-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb245-36"><a href="#cb245-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb245-37"><a href="#cb245-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> received <span class="kw">in</span> tx <span class="op">{</span></span>
<span id="cb245-38"><a href="#cb245-38" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Got: {received}&quot;</span>)<span class="op">;</span></span>
<span id="cb245-39"><a href="#cb245-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb245-40"><a href="#cb245-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="shared-state-concurrency">Shared-State Concurrency</h3>
<ol type="1">
<li><p><strong>Message passing</strong> is a fine way of handling
concurrency, but it‚Äôs not the only one.<br />
Consider this part of the slogan from the <strong><em>Go</em></strong>
language documentation: ‚ÄúDo not communicate by sharing memory; instead,
share memory by communicating‚Äù</p>
<p>What would communicating by sharing memory look like?<br />
In addition, why would message-passing enthusiasts caution not to use
memory sharing?</p></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>In a way, channels in any programming language are similar to single
ownership,<br />
because once you transfer a value down a channel, you should no longer
use that value.<br />
Shared memory concurrency is like multiple ownership,<br />
multiple threads can access the same memory location at the same
time.<br />
As you saw in before, where smart pointers made multiple ownership
possible,<br />
multiple ownership can add complexity because these different owners
need managing.<br />
Rust‚Äôs type system and ownership rules greatly assist in getting this
management correct.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>For an example, let‚Äôs look at mutexes, one of the more common
concurrency primitives for shared memory.<br />
<code>Mutex</code> is an abbreviation for <strong>mutual
exclusion</strong>,<br />
as in, a <code>mutex</code> allows only ONE thread to access some data
at any given time.<br />
To access the data in a <code>mutex</code>, a thread must first signal
that it wants access by asking to acquire the mutex‚Äôs <code>lock</code>.
Therefore, the <code>mutex</code> is described as <code>guarding</code>
the data it holds via the locking system.</li>
</ol>
<div class="sourceCode" id="cb246"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> m <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>            <span class="co">// This call will block the calling thread until it‚Äôs our turn to have the lock.</span></span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>            <span class="co">// The call to lock would fail if another thread holding the lock panicked.</span></span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// In that case, no one would ever be able to get the lock,</span></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// so we‚Äôve chosen to unwrap and have this thread panic if we‚Äôre in that situation.</span></span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> n <span class="op">=</span> m<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>n <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;:?&quot;</span><span class="op">,</span> m)<span class="op">;</span>  <span class="co">// -&gt;</span></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// Mutex {</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//  data: 20,</span></span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//  poisoned: false,</span></span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true" tabindex="-1"></a>                            <span class="co">//  ..</span></span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true" tabindex="-1"></a>                            <span class="co">// }</span></span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The type of <strong><em>m</em></strong> is
<code>Mutex&lt;i32&gt;</code>, and the call to <code>lock()</code>
returns a smart pointer called <code>MutexGuard&lt;T&gt;</code>,<br />
wrapped in a <code>LockResult&lt;T, E&gt;</code> that we handled with
the call to <code>unwrap()</code>.<br />
The <code>MutexGuard</code> is a smart pointer implements
<code>Deref</code> and <code>Drop</code>.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple
Threads.<br />
Consider the following example, which has a compiler ERROR:</li>
</ol>
<div class="sourceCode" id="cb247"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span>Mutex<span class="op">;</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Mutex::</span>new(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> handles <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Rc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb247-10"><a href="#cb247-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">threda::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb247-11"><a href="#cb247-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">//                                 ^^^^ required by a bound in `spawn`.</span></span>
<span id="cb247-12"><a href="#cb247-12" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> <span class="kw">mut</span> n <span class="op">=</span> counter<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb247-13"><a href="#cb247-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>n <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb247-14"><a href="#cb247-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb247-15"><a href="#cb247-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">//      ^ `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely.</span></span>
<span id="cb247-16"><a href="#cb247-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//        The trait `Send` is not implemented for `Rc&lt;Mutex&lt;i32&gt;&gt;`.</span></span>
<span id="cb247-17"><a href="#cb247-17" aria-hidden="true" tabindex="-1"></a>            handles<span class="op">.</span>push(hanle)<span class="op">;</span></span>
<span id="cb247-18"><a href="#cb247-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb247-19"><a href="#cb247-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-20"><a href="#cb247-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb247-21"><a href="#cb247-21" aria-hidden="true" tabindex="-1"></a>            handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb247-22"><a href="#cb247-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb247-23"><a href="#cb247-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-24"><a href="#cb247-24" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The result: {}&quot;</span><span class="op">,</span> <span class="op">*</span>counter<span class="op">.</span>lock()<span class="op">.</span>unwrap())<span class="op">;</span></span>
<span id="cb247-25"><a href="#cb247-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Wow, that error message is very wordy!</li>
<li>Here‚Äôs the important part to focus on:
<code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> cannot be sent between threads
safely.</li>
<li>The compiler is also telling us the reason why: the trait
<code>Send</code> is not implemented for
<code>Rc&lt;Mutex&lt;i32&gt;&gt;</code> .</li>
<li>We‚Äôll talk about <code>Send</code> in the next section, it‚Äôs one of
the traits that ensures the types we use with threads are meant for use
in concurrent situations. &gt;</li>
<li>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across
threads.</li>
<li>When <code>Rc&lt;T&gt;</code> manages the reference count, it adds
to the count for each call to <code>clone()</code> and subtracts from
the count when each clone is dropped.</li>
<li>But it doesn‚Äôt use any concurrency primitives to make sure that
changes to the count can‚Äôt be interrupted by other thread.</li>
<li>What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one
that makes changes to the reference count in a
<strong>thread-safe</strong> way.</li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li>Fortunately, Arc<T> is a type like Rc<T> that is safe to use in
concurrent situations. The ‚ÄòA‚Äô stands for Atomic.<br />
Atomics are an additional kind of concurrency primitive that we won‚Äôt
cover in detail here, see the standard library documentation
<code>std::sync::atomic</code> for more details.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li>You might then wonder why all primitive types aren‚Äôt atomic and why
standard library types aren‚Äôt implemented to use
<code>Arc&lt;T&gt;</code> by default.<br />
The reason is that thread safety comes with a performance penalty that
you only want to pay when you really need to.<br />
If you‚Äôre just performing operations on values within a single thread,
your code can run faster if it doesn‚Äôt have to enforce the guarantees
atomics provide.</li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>Let‚Äôs return to our example: <code>Arc&lt;T&gt;</code> and
<code>Rc&lt;T&gt;</code> have the same API.</li>
</ol>
<div class="sourceCode" id="cb248"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::sync::</span><span class="op">{</span>Arc<span class="op">,</span> Mutex<span class="op">};</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::</span>thread<span class="op">;</span></span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>new(<span class="pp">Mutex::</span>new(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> handles <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _ <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> counter <span class="op">=</span> <span class="pp">Arc::</span>clone(<span class="op">&amp;</span>counter)<span class="op">;</span></span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb248-11"><a href="#cb248-11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> <span class="kw">mut</span> n <span class="op">=</span> counter<span class="op">.</span>lock()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb248-12"><a href="#cb248-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>n <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb248-13"><a href="#cb248-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb248-14"><a href="#cb248-14" aria-hidden="true" tabindex="-1"></a>            handles<span class="op">.</span>push(handle)<span class="op">;</span></span>
<span id="cb248-15"><a href="#cb248-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb248-16"><a href="#cb248-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-17"><a href="#cb248-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb248-18"><a href="#cb248-18" aria-hidden="true" tabindex="-1"></a>            handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb248-19"><a href="#cb248-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb248-20"><a href="#cb248-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-21"><a href="#cb248-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Result: {}&quot;</span><span class="op">,</span> <span class="op">*</span>counter<span class="op">.</span>lock()<span class="op">.</span>unwrap())<span class="op">;</span> <span class="co">// -&gt; Result: 10</span></span>
<span id="cb248-22"><a href="#cb248-22" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Result: {}&quot;</span><span class="op">,</span> counter<span class="op">.</span>lock()<span class="op">.</span>unwrap())<span class="op">;</span></span>
<span id="cb248-23"><a href="#cb248-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* -&gt;</span></span>
<span id="cb248-24"><a href="#cb248-24" aria-hidden="true" tabindex="-1"></a><span class="co">         * Result: MutexGuard { lock: 1 }</span></span>
<span id="cb248-25"><a href="#cb248-25" aria-hidden="true" tabindex="-1"></a><span class="co">         * */</span></span>
<span id="cb248-26"><a href="#cb248-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>When spawning a new thread,<br />
Rust enforces that the closure captures the values it uses by moving
them into the thread‚Äôs scope.<br />
So even a reference usage would be an ownership capture in concurrency
context.</li>
</ol>
<hr/>
<h3 id="extensible-concurrency-with-the-sync-and-send-traits">Extensible
Concurrency with the Sync and Send Traits</h3>
<ol type="1">
<li>Interestingly, the Rust language has very few concurrency
features.<br />
Almost every concurrency feature we‚Äôve talked about so far in this
chapter has been part of the standard library, not the language. Your
options for handling concurrency are not limited to the language or the
standard library,<br />
you can write your own concurrency features or use those written by
others.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Also, two concurrency concepts are embedded in the language: the
<code>std::marker</code> traits <code>Sync</code> and
<code>Send</code>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>The <code>std::marker::Send</code> trait indicates that ownership
of values of the type implementing <code>Send</code> can be transferred
between threads. Almost every Rust type is <code>Send</code>, but there
are some exceptions, including <code>Rc&lt;T&gt;</code>,<br />
it cannot be <code>Send</code> because if you cloned an
<code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the
clone to another thread, both threads might update the reference count
at the same time.<br />
Therefore, Rust‚Äôs type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads
unsafely.</p>
<p>Any type composed entirely of <code>Send</code> types is
automatically marked as <code>Send</code> as well.<br />
Almost all primitive types are <code>Send</code>, aside from raw
pointers, which we‚Äôll discuss in later chapters.</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyStruct <span class="op">{</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span>  <span class="co">// `i32` is `Send`</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span>  <span class="co">// `f64` is `Send`</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a><span class="co">// `MyStruct` is automatically `Send` because both `i32` and `f64` are `Send`.</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>The <code>std::marker::Sync</code> trait indicates that it is
safe for the type implementing <code>Sync</code> to be referenced from
multiple threads. In other words, any type <code>T</code> which is
<code>Sync</code> if <code>&amp;T</code> (an immutable reference to
<code>T</code>) is <code>Send</code>,<br />
meaning the reference can be sent safely to another thread.<br />
Similar to <code>Send</code>, primitive types are <code>Sync</code>, and
types composed entirely of types that are <code>Sync</code> are also
<code>Sync</code>.</p>
<p>If a type <code>T</code> is <code>Sync</code>, then
<code>&amp;T</code> (an immutable reference) can be safely shared
between threads.<br />
Mot directly applicable to mutable references <code>&amp;mut T</code>.
You‚Äôll use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for mutating
then.<br />
But the <code>T</code> inside <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>
does not need to implement <code>Sync</code> because the
<code>Mutex</code> itself ensures that only one thread can access the
data at a time.<br />
But the the <code>T</code> inside <code>Arc&lt;T&gt;</code> must
implement <code>Sync</code> in order to be shared across threads.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not
<code>Sync</code> for the same reasons that it‚Äôs not
<code>Send</code>.<br />
The <code>RefCell&lt;T&gt;</code> type and the family of related
<code>Cell&lt;T&gt;</code> types are not <code>Sync</code>.<br />
The implementation of borrow checking that <code>RefCell&lt;T&gt;</code>
does at runtime is not <strong>thread-safe</strong>.<br />
The smart pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and
can be used to share access with multiple threads.</p></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li><p>Because types that are made up of <code>Send</code> and
<code>Sync</code> traits are automatically also <code>Send</code> and
<code>Sync</code>, we don‚Äôt have to implement those traits
manually.<br />
As marker traits, they don‚Äôt even have any methods to implement.<br />
They‚Äôre just useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing
<code>unsafe</code> Rust code.<br />
We‚Äôll talk about using unsafe Rust code in later chapters!<br />
For now, the important information is that building new concurrent types
not made up of <code>Send</code> and <code>Sync</code> parts requires
careful thought to uphold the safety guarantees.</p></li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li>Example of <code>Send</code> trait.</li>
</ol>
<div class="sourceCode" id="cb250"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> send_example() <span class="op">{</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `i32` is `Send`</span></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">std::thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;x in another thread: {}&quot;</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>But here actually <strong><em>x</em></strong> will be copied rather
than moved, because it implements the <code>Copy</code> trait also.</li>
</ul>
<p><br />
</p>
<ol start="7" type="1">
<li>Example of <code>Sync</code> trait.</li>
</ol>
<div class="sourceCode" id="cb251"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// `i32` is both `Send` and `Sync`</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> num<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create an immutable reference to `num`</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> num_ref <span class="op">=</span> <span class="op">&amp;</span>num<span class="op">;</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create a vector to hold thread handles</span></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> handles <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">3</span> <span class="op">{</span></span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Each thread gets an immutable reference to `num_ref`</span></span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> handle <span class="op">=</span> <span class="pp">thread::</span>spawn(<span class="kw">move</span> <span class="op">||</span> <span class="op">{</span></span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Thread {} sees num: {}&quot;</span><span class="op">,</span> i<span class="op">,</span> num_ref)<span class="op">;</span></span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a>            handles<span class="op">.</span>push(handle)<span class="op">;</span></span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb251-18"><a href="#cb251-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-19"><a href="#cb251-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Wait for all threads to finish</span></span>
<span id="cb251-20"><a href="#cb251-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> handle <span class="kw">in</span> handles <span class="op">{</span></span>
<span id="cb251-21"><a href="#cb251-21" aria-hidden="true" tabindex="-1"></a>            handle<span class="op">.</span>join()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb251-22"><a href="#cb251-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb251-23"><a href="#cb251-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-24"><a href="#cb251-24" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Main thread sees num: {}&quot;</span><span class="op">,</span> num)<span class="op">;</span></span>
<span id="cb251-25"><a href="#cb251-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>Modifying data across threads:<br />
If you want to read/modify the data across threads, <code>T</code> does
not need to implement <code>Sync</code> directly.<br />
Instead, you can wrap <code>T</code> in a <code>Mutex&lt;T&gt;</code>,
which provides thread-safe mutable access.<br />
In this case, it‚Äôs <code>Mutex&lt;T&gt;</code> that guarantees the
thread safety.</li>
</ol>
<hr/>
<h3 id="object-oriented-programming-features-of-rust">Object-Oriented
Programming Features of Rust</h3>
<ol type="1">
<li>One aspect commonly associated with OOP is the idea of
<strong>encapsulation</strong>,<br />
which means that the implementation details of an object aren‚Äôt
accessible to code using that object.</li>
</ol>
<div class="sourceCode" id="cb252"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">struct</span> AveragedCollection <span class="op">{</span></span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a>        list<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;,</span></span>
<span id="cb252-3"><a href="#cb252-3" aria-hidden="true" tabindex="-1"></a>        average<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb252-4"><a href="#cb252-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Inheritance is a mechanism whereby an object can inherit elements
from another object‚Äôs definition,<br />
thus gaining the parent object‚Äôs data and behavior without you having to
define them again.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To many people, polymorphism is synonymous with inheritance.<br />
But it‚Äôs actually a more general concept that refers to code that can
work with data of multiple types.<br />
For inheritance, those types are generally subclasses.</li>
</ol>
<hr/>
<h3 id="patterns-and-matching">Patterns and Matching</h3>
<ol type="1">
<li>Patterns are a special syntax in Rust for matching against the
structure of types.<br />
A pattern consists of some combination of the following:
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Formally, <code>match</code> expressions are defined as the keyword
<code>match</code>, a value to match on,<br />
and one or more match arms that consist of a pattern and an expression
to run if the value matches that arm‚Äôs pattern, like this:</li>
</ol>
<div class="sourceCode" id="cb253"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Some</span>(i) <span class="op">=&gt;</span> <span class="cn">Some</span>(i <span class="op">+</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a>        <span class="cn">None</span> <span class="op">=&gt;</span> <span class="cn">None</span><span class="op">,</span></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The particular pattern <code>_</code> will match anything, but it
never binds to a variable, so it‚Äôs often used in the last match
arm.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li><code>if let</code> expressions mainly as a shorter way to write the
equivalent of a <code>match</code> that only matches one case.<br />
No need for examples, just look previous chapters!</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Similar in construction to <code>if let</code>,<br />
the <code>while let</code> conditional loop allows a <code>while</code>
loop to run for as long as a pattern continues to match.</li>
</ol>
<div class="sourceCode" id="cb254"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> stack <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">.</span>push(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">.</span>push(<span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">.</span>push(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">let</span> <span class="cn">Some</span>(top) <span class="op">=</span> stack<span class="op">.</span>pop() <span class="op">{</span></span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> top)<span class="op">;</span></span>
<span id="cb254-9"><a href="#cb254-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>In a <code>for</code> loop, the value that directly follows the
keyword <code>for</code> is a pattern.<br />
For example, in <code>for x in y</code> the <code>x</code> is the
pattern.</li>
</ol>
<div class="sourceCode" id="cb255"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;b&#39;</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span>]<span class="op">;</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (index<span class="op">,</span> value) <span class="kw">in</span> v<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{index}: {value}&quot;</span>)<span class="op">;</span></span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Function parameters can also be patterns.</li>
</ol>
<div class="sourceCode" id="cb256"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> foo(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-8"><a href="#cb256-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-9"><a href="#cb256-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_coordinates(<span class="op">&amp;</span>(x<span class="op">,</span> y)<span class="op">:</span> <span class="op">&amp;</span>(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)) <span class="op">{</span></span>
<span id="cb256-10"><a href="#cb256-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Coordinate: ({x}, {y})&quot;</span>)<span class="op">;</span></span>
<span id="cb256-11"><a href="#cb256-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-12"><a href="#cb256-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-13"><a href="#cb256-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_point(Point <span class="op">{</span>x<span class="op">,</span> y<span class="op">}:</span> Point) <span class="op">{</span></span>
<span id="cb256-14"><a href="#cb256-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Point: ({x}, {y})&quot;</span>)<span class="op">;</span></span>
<span id="cb256-15"><a href="#cb256-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-16"><a href="#cb256-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_point2(Point <span class="op">{</span> x<span class="op">:</span> a<span class="op">,</span> y<span class="op">:</span> b <span class="op">}:</span> Point) <span class="op">{</span></span>
<span id="cb256-17"><a href="#cb256-17" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Point coordinates are: ({a}, {b})&quot;</span>)<span class="op">;</span></span>
<span id="cb256-18"><a href="#cb256-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-19"><a href="#cb256-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_point3(Point <span class="op">{</span> x<span class="op">:</span> a<span class="op">,</span> y<span class="op">:</span> b <span class="op">}:</span> <span class="op">&amp;</span>Point) <span class="op">{</span></span>
<span id="cb256-20"><a href="#cb256-20" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Point coordinates are: ({a}, {b})&quot;</span>)<span class="op">;</span></span>
<span id="cb256-21"><a href="#cb256-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb256-22"><a href="#cb256-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-23"><a href="#cb256-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb256-24"><a href="#cb256-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> point <span class="op">=</span> (<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb256-25"><a href="#cb256-25" aria-hidden="true" tabindex="-1"></a>        print_coordinates(<span class="op">&amp;</span>point)<span class="op">;</span></span>
<span id="cb256-26"><a href="#cb256-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>We can also use patterns in closure parameter lists in the same way
as in function parameter lists,<br />
because closures are similar to functions.</li>
</ol>
<p><br />
</p>
<ol start="8" type="1">
<li>More advanced usage of <code>let</code>.</li>
</ol>
<div class="sourceCode" id="cb257"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If `x` failed to de-compose in the `if` branch,</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// its ownership will not be transfered, and goes to the next conditional branch for judge.</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="cn">Some</span>(i) <span class="op">=</span> x <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{x:?} was gone!&quot;</span>)<span class="op">;</span></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">;</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>In match expressions, you can <code>match</code> multiple patterns
using the <code>|</code> syntax, which is the pattern <code>or</code>
operator.</li>
</ol>
<div class="sourceCode" id="cb258"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;ONE or TWO&quot;</span>)<span class="op">,</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a>        <span class="dv">3</span>     <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;THREE&quot;</span>)<span class="op">,</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>        _     <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Anything Else&quot;</span>)<span class="op">,</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="10" type="1">
<li>Matching Ranges of Values with <code>..</code> or
<code>..=</code></li>
</ol>
<div class="sourceCode" id="cb259"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="op">..</span><span class="dv">10</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;ONE digit&quot;</span>)<span class="op">,</span></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">10</span><span class="op">..</span><span class="dv">100</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;TWO digits&quot;</span>)<span class="op">,</span></span>
<span id="cb259-5"><a href="#cb259-5" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Too large!&quot;</span>)<span class="op">,</span></span>
<span id="cb259-6"><a href="#cb259-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb259-7"><a href="#cb259-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-8"><a href="#cb259-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ch <span class="op">=</span> <span class="ch">&#39;c&#39;</span><span class="op">;</span></span>
<span id="cb259-9"><a href="#cb259-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> ch <span class="op">{</span></span>
<span id="cb259-10"><a href="#cb259-10" aria-hidden="true" tabindex="-1"></a>        <span class="ch">&#39;a&#39;</span><span class="op">..=</span><span class="ch">&#39;z&#39;</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Upper&quot;</span>)<span class="op">,</span></span>
<span id="cb259-11"><a href="#cb259-11" aria-hidden="true" tabindex="-1"></a>        <span class="ch">&#39;A&#39;</span><span class="op">..=</span><span class="ch">&#39;Z&#39;</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Lower&quot;</span>)<span class="op">,</span></span>
<span id="cb259-12"><a href="#cb259-12" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Unknown&quot;</span>)<span class="op">,</span></span>
<span id="cb259-13"><a href="#cb259-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="11" type="1">
<li>Destructuring Structs.</li>
</ol>
<div class="sourceCode" id="cb260"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Messenger <span class="op">{</span></span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>        message<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb260-11"><a href="#cb260-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// This does not transfer ownership, only copies.</span></span>
<span id="cb260-12"><a href="#cb260-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span><span class="dv">10</span><span class="op">,</span> y<span class="op">:</span><span class="dv">20</span> <span class="op">};</span></span>
<span id="cb260-13"><a href="#cb260-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Point <span class="op">{</span> x<span class="op">,</span> y <span class="op">}</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb260-14"><a href="#cb260-14" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(x<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb260-15"><a href="#cb260-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(y<span class="op">,</span> <span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb260-16"><a href="#cb260-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Point <span class="op">{</span> x<span class="op">:</span> a<span class="op">,</span> y<span class="op">:</span> b <span class="op">}</span> <span class="op">=</span> p<span class="op">;</span></span>
<span id="cb260-17"><a href="#cb260-17" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(a<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb260-18"><a href="#cb260-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(b<span class="op">,</span> <span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb260-19"><a href="#cb260-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-20"><a href="#cb260-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// This transfers ownership.</span></span>
<span id="cb260-21"><a href="#cb260-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> messenger <span class="op">=</span> Messenger <span class="op">{</span></span>
<span id="cb260-22"><a href="#cb260-22" aria-hidden="true" tabindex="-1"></a>                            message<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;MSG&quot;</span>)</span>
<span id="cb260-23"><a href="#cb260-23" aria-hidden="true" tabindex="-1"></a>                        <span class="op">};</span></span>
<span id="cb260-24"><a href="#cb260-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Messenger <span class="op">{</span> message<span class="op">:</span> msg <span class="op">}</span> <span class="op">=</span> messenger<span class="op">;</span></span>
<span id="cb260-25"><a href="#cb260-25" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(msg<span class="op">,</span> <span class="st">&quot;MSG&quot;</span>)<span class="op">;</span></span>
<span id="cb260-26"><a href="#cb260-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Uncommenting the following line would cause a compiler ERROR,</span></span>
<span id="cb260-27"><a href="#cb260-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// beacuse the ownership was already moved.</span></span>
<span id="cb260-28"><a href="#cb260-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let Messenger { message: msg } = messenger;</span></span>
<span id="cb260-29"><a href="#cb260-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-30"><a href="#cb260-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">/// This borrows the field(s).</span></span>
<span id="cb260-31"><a href="#cb260-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> messenger <span class="op">=</span> Messenger <span class="op">{</span></span>
<span id="cb260-32"><a href="#cb260-32" aria-hidden="true" tabindex="-1"></a>                            message<span class="op">:</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;MSG&quot;</span>)</span>
<span id="cb260-33"><a href="#cb260-33" aria-hidden="true" tabindex="-1"></a>                        <span class="op">};</span></span>
<span id="cb260-34"><a href="#cb260-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Messenger <span class="op">{</span> <span class="kw">ref</span> message<span class="op">:</span> msg <span class="op">}</span> <span class="op">=</span> messenger<span class="op">;</span></span>
<span id="cb260-35"><a href="#cb260-35" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(msg<span class="op">,</span> <span class="st">&quot;MSG&quot;</span>)<span class="op">;</span></span>
<span id="cb260-36"><a href="#cb260-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Could do it again!</span></span>
<span id="cb260-37"><a href="#cb260-37" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Messenger <span class="op">{</span> <span class="kw">ref</span> message<span class="op">:</span> msg <span class="op">}</span> <span class="op">=</span> messenger<span class="op">;</span></span>
<span id="cb260-38"><a href="#cb260-38" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(msg<span class="op">,</span> <span class="st">&quot;MSG&quot;</span>)<span class="op">;</span></span>
<span id="cb260-39"><a href="#cb260-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// This also does the borrowing.</span></span>
<span id="cb260-40"><a href="#cb260-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> Messenger <span class="op">{</span> message<span class="op">:</span> msg <span class="op">}</span> <span class="op">=</span> <span class="op">&amp;</span>messenger<span class="op">;</span></span>
<span id="cb260-41"><a href="#cb260-41" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(msg<span class="op">,</span> <span class="st">&quot;MSG&quot;</span>)<span class="op">;</span></span>
<span id="cb260-42"><a href="#cb260-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="12" type="1">
<li>Destructuring Enums.</li>
</ol>
<div class="sourceCode" id="cb261"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Message <span class="op">{</span></span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a>        Quit<span class="op">,</span></span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>        Move <span class="op">{},</span></span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Write</span>(<span class="dt">String</span>)<span class="op">,</span></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a>        SetColor(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)<span class="op">,</span></span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> msg <span class="op">=</span> <span class="pp">Message::</span>SetColor(<span class="dv">0</span><span class="op">,</span> <span class="dv">177</span><span class="op">,</span> <span class="dv">255</span>)<span class="op">;</span></span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> msg <span class="op">{</span></span>
<span id="cb261-12"><a href="#cb261-12" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>Quit <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb261-13"><a href="#cb261-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb261-14"><a href="#cb261-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-15"><a href="#cb261-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>Move <span class="op">{</span>x<span class="op">,</span> y<span class="op">}</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb261-16"><a href="#cb261-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb261-17"><a href="#cb261-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-18"><a href="#cb261-18" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span><span class="bu">Write</span>(text) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb261-19"><a href="#cb261-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb261-20"><a href="#cb261-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-21"><a href="#cb261-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>SetColor(r<span class="op">,</span> g<span class="op">,</span> b) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb261-22"><a href="#cb261-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">},</span></span>
<span id="cb261-23"><a href="#cb261-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb261-24"><a href="#cb261-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Now `msg` is no longer usable, its ownership taken.</span></span>
<span id="cb261-25"><a href="#cb261-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="13" type="1">
<li>Ignoring an Entire Value with <code>_</code></li>
</ol>
<div class="sourceCode" id="cb262"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> foo(_<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;This code only uses the y parameter: {y}&quot;</span>)<span class="op">;</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a>        foo(<span class="dv">100</span><span class="op">,</span> <span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="14" type="1">
<li>Ignoring Remaining Parts of a Value with <code>..</code></li>
</ol>
<div class="sourceCode" id="cb263"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a>        z<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> origin <span class="op">=</span> Point <span class="op">{</span></span>
<span id="cb263-9"><a href="#cb263-9" aria-hidden="true" tabindex="-1"></a>            x<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb263-10"><a href="#cb263-10" aria-hidden="true" tabindex="-1"></a>            y<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb263-11"><a href="#cb263-11" aria-hidden="true" tabindex="-1"></a>            z<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb263-12"><a href="#cb263-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb263-13"><a href="#cb263-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> origin <span class="op">{</span></span>
<span id="cb263-14"><a href="#cb263-14" aria-hidden="true" tabindex="-1"></a>            Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">0</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">0</span><span class="op">,</span> z<span class="op">:</span> <span class="dv">0</span> <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;ORIGIN!&quot;</span>)<span class="op">,</span></span>
<span id="cb263-15"><a href="#cb263-15" aria-hidden="true" tabindex="-1"></a>            Point <span class="op">{</span> x<span class="op">,</span> <span class="op">..</span> <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;x is {x}!&quot;</span>)<span class="op">,</span></span>
<span id="cb263-16"><a href="#cb263-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb263-17"><a href="#cb263-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-18"><a href="#cb263-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> numbers <span class="op">=</span> (<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb263-19"><a href="#cb263-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> numbers <span class="op">{</span></span>
<span id="cb263-20"><a href="#cb263-20" aria-hidden="true" tabindex="-1"></a>            (<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;ZERO&quot;</span>)<span class="op">,</span></span>
<span id="cb263-21"><a href="#cb263-21" aria-hidden="true" tabindex="-1"></a>            (first<span class="op">,</span> <span class="op">..,</span> last) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;First and Last: {}, {}&quot;</span><span class="op">,</span> first<span class="op">,</span> last)<span class="op">,</span></span>
<span id="cb263-22"><a href="#cb263-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb263-23"><a href="#cb263-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="15" type="1">
<li>Extra Conditionals with Match Guards.</li>
</ol>
<div class="sourceCode" id="cb264"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(<span class="dv">0</span>) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Zero&quot;</span>)<span class="op">,</span></span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(i) <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;&gt;0&quot;</span>)<span class="op">,</span></span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Some</span>(i) <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;&lt;0&quot;</span>)<span class="op">,</span></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>            <span class="cn">None</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;None&quot;</span>)<span class="op">,</span></span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cond <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb264-12"><a href="#cb264-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb264-13"><a href="#cb264-13" aria-hidden="true" tabindex="-1"></a>            <span class="dv">1</span> <span class="op">|</span> <span class="dv">2</span> <span class="op">|</span> <span class="dv">3</span> <span class="cf">if</span> cond <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;YES&quot;</span>)<span class="op">,</span></span>
<span id="cb264-14"><a href="#cb264-14" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;NO&quot;</span>)<span class="op">,</span></span>
<span id="cb264-15"><a href="#cb264-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb264-16"><a href="#cb264-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; NO</span></span>
<span id="cb264-17"><a href="#cb264-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="16" type="1">
<li>The <code>at</code> operator <code>@</code> lets us create a
variable that holds a value at the same time as we‚Äôre testing that value
for a pattern match.</li>
</ol>
<div class="sourceCode" id="cb265"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Message <span class="op">{</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a>        Hello <span class="op">{</span> id<span class="op">:</span> <span class="dt">i32</span> <span class="op">},</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a>        x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>        y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a>        z<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> msg <span class="op">=</span> <span class="pp">Message::</span>Hello <span class="op">{</span> id<span class="op">:</span> <span class="dv">5</span> <span class="op">};</span></span>
<span id="cb265-13"><a href="#cb265-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> msg <span class="op">{</span></span>
<span id="cb265-14"><a href="#cb265-14" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>Hello <span class="op">{</span></span>
<span id="cb265-15"><a href="#cb265-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Bind the entire `id` to `special_id` while also checking that it&#39;s within the range 1..10</span></span>
<span id="cb265-16"><a href="#cb265-16" aria-hidden="true" tabindex="-1"></a>                id<span class="op">:</span> special_id <span class="op">@</span> <span class="dv">0</span><span class="op">..</span><span class="dv">10</span><span class="op">,</span></span>
<span id="cb265-17"><a href="#cb265-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb265-18"><a href="#cb265-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Found an id in range: {special_id}&quot;</span>)<span class="op">,</span></span>
<span id="cb265-19"><a href="#cb265-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-20"><a href="#cb265-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>Hello <span class="op">{</span></span>
<span id="cb265-21"><a href="#cb265-21" aria-hidden="true" tabindex="-1"></a>                id<span class="op">:</span> <span class="dv">10</span><span class="op">..=</span><span class="dv">100</span></span>
<span id="cb265-22"><a href="#cb265-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb265-23"><a href="#cb265-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Found an id {id} in another range!&quot;</span>)<span class="op">,</span></span>
<span id="cb265-24"><a href="#cb265-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-25"><a href="#cb265-25" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Message::</span>Hello <span class="op">{</span> id <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;{id}&quot;</span>)</span>
<span id="cb265-26"><a href="#cb265-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb265-27"><a href="#cb265-27" aria-hidden="true" tabindex="-1"></a>        <span class="co">// -&gt; Found an id in range: 5</span></span>
<span id="cb265-28"><a href="#cb265-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-29"><a href="#cb265-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-30"><a href="#cb265-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span></span>
<span id="cb265-31"><a href="#cb265-31" aria-hidden="true" tabindex="-1"></a>            x<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb265-32"><a href="#cb265-32" aria-hidden="true" tabindex="-1"></a>            y<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb265-33"><a href="#cb265-33" aria-hidden="true" tabindex="-1"></a>            z<span class="op">:</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb265-34"><a href="#cb265-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb265-35"><a href="#cb265-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> p <span class="op">{</span></span>
<span id="cb265-36"><a href="#cb265-36" aria-hidden="true" tabindex="-1"></a>            origin <span class="op">@</span> Point <span class="op">{</span> x<span class="op">:</span><span class="dv">0</span><span class="op">,</span> y<span class="op">:</span><span class="dv">0</span><span class="op">,</span> z<span class="op">:</span><span class="dv">0</span> <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;({}, {}, {})&quot;</span><span class="op">,</span> origin<span class="op">.</span>x<span class="op">,</span> origin<span class="op">.</span>y<span class="op">,</span> origin<span class="op">.</span>z)<span class="op">,</span></span>
<span id="cb265-37"><a href="#cb265-37" aria-hidden="true" tabindex="-1"></a>            Point <span class="op">{</span> z<span class="op">,</span> <span class="op">..</span> <span class="op">}</span> <span class="cf">if</span> z <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;{z}&quot;</span>)<span class="op">,</span></span>
<span id="cb265-38"><a href="#cb265-38" aria-hidden="true" tabindex="-1"></a>            _ <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;No match!&quot;</span>)<span class="op">,</span></span>
<span id="cb265-39"><a href="#cb265-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb265-40"><a href="#cb265-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="unsafe-rust">Unsafe Rust</h3>
<ol type="1">
<li>All the code we‚Äôve discussed so far has had Rust‚Äôs memory safety
guarantees enforced at compile time. However, Rust has a second language
hidden inside it that doesn‚Äôt enforce these memory safety guarantees,
it‚Äôs called <code>unsafe</code> Rust and works just like regular Rust,
but gives us extra superpowers.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Unsafe Rust exists because, by nature, static analysis is
conservative. When the compiler tries to determine whether or not code
upholds the guarantees, it‚Äôs better for it to reject some valid programs
than to accept some invalid programs. Although the code might be okay,
if the Rust compiler doesn‚Äôt have enough information to be confident, it
will reject the code. In these cases, you can use unsafe code to tell
the compiler, ‚ÄúTrust me, I know what I‚Äôm doing.‚Äù</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Another reason Rust has an <code>unsafe</code> alter ego is that the
underlying computer hardware is inherently <code>unsafe</code>. If Rust
didn‚Äôt let you do <code>unsafe</code> operations, you couldn‚Äôt do
certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or
even writing your own operating system. Working with low-level systems
programming is one of the goals of the language.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>To switch to <code>unsafe</code> Rust, use the <code>unsafe</code>
keyword and then start a new block that holds the <code>unsafe</code>
code. You can take five actions in <code>unsafe</code> Rust that you
can‚Äôt in safe Rust, which we call <strong>unsafe superpowers</strong>.
Those superpowers include the ability to:
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
<li>Access fields of a union</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>It‚Äôs important to note that <code>unsafe</code> does NOT turn off
the borrow checker or disable any other of Rust‚Äôs safety checks, if you
use a reference in <code>unsafe</code> code, it will still be checked.
The <code>unsafe</code> keyword only gives you access to these five
features that are then not checked by the compiler for memory
safety.</li>
</ol>
<hr/>
<h3 id="dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</h3>
<ol type="1">
<li>A raw pointer is a special kind of pointer that can point to ANY
memory address.<br />
Unsafe Rust has two new types called <strong>raw pointers</strong> that
are similar to references.<br />
As with references, raw pointers can be immutable or mutable and are
written as <code>*const T</code> and <code>*mut T</code>,
respectively.<br />
The asterisk isn‚Äôt the dereference operator, it‚Äôs part of the type
name.<br />
When we say a pointer is immutable, it means that after you dereference
the pointer (that is, when you access the value the pointer is pointing
to), you can‚Äôt directly modify that value.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li><p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li><p>Are allowed to ignore the borrowing rules by having both
immutable and mutable pointers or multiple mutable pointers to the same
location.</p></li>
<li><p>Aren‚Äôt guaranteed to point to valid memory.</p></li>
<li><p>Are allowed to be <code>std::ptr::null()</code>.</p></li>
<li><p>Don‚Äôt implement any automatic cleanup.</p></li>
</ul>
<div class="sourceCode" id="cb266"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::</span>slice<span class="op">;</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-3"><a href="#cb266-3" aria-hidden="true" tabindex="-1"></a><span class="kw">static</span> <span class="kw">mut</span> COUNTER<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb266-4"><a href="#cb266-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-5"><a href="#cb266-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> incre_count(inc<span class="op">:</span> <span class="dt">u32</span>) <span class="op">{</span></span>
<span id="cb266-6"><a href="#cb266-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-7"><a href="#cb266-7" aria-hidden="true" tabindex="-1"></a>        COUNTER <span class="op">+=</span> inc<span class="op">;</span></span>
<span id="cb266-8"><a href="#cb266-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-9"><a href="#cb266-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-10"><a href="#cb266-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-11"><a href="#cb266-11" aria-hidden="true" tabindex="-1"></a><span class="co">// A trait is unsafe when at least one of its methods has some invariant that the compiler can‚Äôt verify.</span></span>
<span id="cb266-12"><a href="#cb266-12" aria-hidden="true" tabindex="-1"></a><span class="co">// ÂÖ®Âá≠Ëá™ËßâÔºÅ</span></span>
<span id="cb266-13"><a href="#cb266-13" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">trait</span> Foo <span class="op">{</span></span>
<span id="cb266-14"><a href="#cb266-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> divide(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> divisor<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb266-15"><a href="#cb266-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-16"><a href="#cb266-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-17"><a href="#cb266-17" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">impl</span> Foo <span class="cf">for</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb266-18"><a href="#cb266-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> divide(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> divisor<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb266-19"><a href="#cb266-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> divisor <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb266-20"><a href="#cb266-20" aria-hidden="true" tabindex="-1"></a>            <span class="pp">panic!</span>(<span class="st">&quot;Division by zero!&quot;</span>)<span class="op">;</span></span>
<span id="cb266-21"><a href="#cb266-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb266-22"><a href="#cb266-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span> <span class="op">/</span> divisor</span>
<span id="cb266-23"><a href="#cb266-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-24"><a href="#cb266-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-25"><a href="#cb266-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-26"><a href="#cb266-26" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb266-27"><a href="#cb266-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-28"><a href="#cb266-28" aria-hidden="true" tabindex="-1"></a>    incre_count(<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb266-29"><a href="#cb266-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-30"><a href="#cb266-30" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> COUNTER)<span class="op">;</span></span>
<span id="cb266-31"><a href="#cb266-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-32"><a href="#cb266-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-33"><a href="#cb266-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-34"><a href="#cb266-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-35"><a href="#cb266-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-36"><a href="#cb266-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb266-37"><a href="#cb266-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-38"><a href="#cb266-38" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;10 / 2 = {}&quot;</span><span class="op">,</span> x<span class="op">.</span>divide(<span class="dv">2</span>))</span>
<span id="cb266-39"><a href="#cb266-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-40"><a href="#cb266-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-41"><a href="#cb266-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-42"><a href="#cb266-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-43"><a href="#cb266-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-44"><a href="#cb266-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb266-45"><a href="#cb266-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> valid_ptr<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span> <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb266-46"><a href="#cb266-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> null_ptr<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span> <span class="op">=</span> <span class="pp">std::ptr::</span>null()<span class="op">;</span></span>
<span id="cb266-47"><a href="#cb266-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-48"><a href="#cb266-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-49"><a href="#cb266-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> valid_ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb266-50"><a href="#cb266-50" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;valid_ptr is null.&quot;</span>)<span class="op">;</span></span>
<span id="cb266-51"><a href="#cb266-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb266-52"><a href="#cb266-52" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;valid_ptr points to {}&quot;</span><span class="op">,</span> <span class="op">*</span>valid_ptr)<span class="op">;</span></span>
<span id="cb266-53"><a href="#cb266-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb266-54"><a href="#cb266-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-55"><a href="#cb266-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> null_ptr<span class="op">.</span>is_null() <span class="op">{</span></span>
<span id="cb266-56"><a href="#cb266-56" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;null_ptr is null.&quot;</span>)<span class="op">;</span></span>
<span id="cb266-57"><a href="#cb266-57" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb266-58"><a href="#cb266-58" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;null_ptr points to {}&quot;</span><span class="op">,</span> <span class="op">*</span>null_ptr)<span class="op">;</span></span>
<span id="cb266-59"><a href="#cb266-59" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb266-60"><a href="#cb266-60" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-61"><a href="#cb266-61" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-62"><a href="#cb266-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-63"><a href="#cb266-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-64"><a href="#cb266-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-65"><a href="#cb266-65" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> address <span class="op">=</span> <span class="dv">0x012345usize</span><span class="op">;</span></span>
<span id="cb266-66"><a href="#cb266-66" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> address <span class="op">=</span> address <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb266-67"><a href="#cb266-67" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-68"><a href="#cb266-68" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The address points to {}&quot;</span><span class="op">,</span> <span class="op">*</span>address)<span class="op">;</span></span>
<span id="cb266-69"><a href="#cb266-69" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-70"><a href="#cb266-70" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-71"><a href="#cb266-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-72"><a href="#cb266-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-73"><a href="#cb266-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-74"><a href="#cb266-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb266-75"><a href="#cb266-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r1 <span class="op">=</span> <span class="op">&amp;</span>n <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb266-76"><a href="#cb266-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r2 <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> n <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb266-77"><a href="#cb266-77" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-78"><a href="#cb266-78" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span><span class="op">,</span> <span class="op">*</span>r1<span class="op">,</span> <span class="op">*</span>r2)<span class="op">;</span></span>
<span id="cb266-79"><a href="#cb266-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>r2 <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb266-80"><a href="#cb266-80" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span><span class="op">,</span> <span class="op">*</span>r1<span class="op">,</span> <span class="op">*</span>r2)<span class="op">;</span></span>
<span id="cb266-81"><a href="#cb266-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-82"><a href="#cb266-82" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> n)<span class="op">;</span></span>
<span id="cb266-83"><a href="#cb266-83" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-84"><a href="#cb266-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-85"><a href="#cb266-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-86"><a href="#cb266-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-87"><a href="#cb266-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-88"><a href="#cb266-88" aria-hidden="true" tabindex="-1"></a>        dangerous()<span class="op">;</span></span>
<span id="cb266-89"><a href="#cb266-89" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-90"><a href="#cb266-90" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-91"><a href="#cb266-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-92"><a href="#cb266-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-93"><a href="#cb266-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-94"><a href="#cb266-94" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span>]<span class="op">;</span></span>
<span id="cb266-95"><a href="#cb266-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> r <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> v[<span class="op">..</span>]<span class="op">;</span></span>
<span id="cb266-96"><a href="#cb266-96" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (a<span class="op">,</span> b) <span class="op">=</span> split_at_mut(r<span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb266-97"><a href="#cb266-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-98"><a href="#cb266-98" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(a<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>])<span class="op">;</span></span>
<span id="cb266-99"><a href="#cb266-99" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(b<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span>])<span class="op">;</span></span>
<span id="cb266-100"><a href="#cb266-100" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-101"><a href="#cb266-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-102"><a href="#cb266-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-103"><a href="#cb266-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-104"><a href="#cb266-104" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-105"><a href="#cb266-105" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> abs(<span class="op">-</span><span class="dv">3</span>))<span class="op">;</span></span>
<span id="cb266-106"><a href="#cb266-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-107"><a href="#cb266-107" aria-hidden="true" tabindex="-1"></a>    <span class="co">///</span></span>
<span id="cb266-108"><a href="#cb266-108" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-109"><a href="#cb266-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-110"><a href="#cb266-110" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">fn</span> dangerous() <span class="op">{}</span></span>
<span id="cb266-111"><a href="#cb266-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-112"><a href="#cb266-112" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> split_at_mut(</span>
<span id="cb266-113"><a href="#cb266-113" aria-hidden="true" tabindex="-1"></a>    values<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">i32</span>]<span class="op">,</span></span>
<span id="cb266-114"><a href="#cb266-114" aria-hidden="true" tabindex="-1"></a>    mid<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb266-115"><a href="#cb266-115" aria-hidden="true" tabindex="-1"></a>)  <span class="op">-&gt;</span> (<span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">i32</span>]<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">i32</span>])</span>
<span id="cb266-116"><a href="#cb266-116" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb266-117"><a href="#cb266-117" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> len <span class="op">=</span> values<span class="op">.</span>len()<span class="op">;</span></span>
<span id="cb266-118"><a href="#cb266-118" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ptr <span class="op">=</span> values<span class="op">.</span>as_mut_ptr()<span class="op">;</span></span>
<span id="cb266-119"><a href="#cb266-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-120"><a href="#cb266-120" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert!</span>(mid <span class="op">&lt;=</span> len)<span class="op">;</span></span>
<span id="cb266-121"><a href="#cb266-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-122"><a href="#cb266-122" aria-hidden="true" tabindex="-1"></a>    <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb266-123"><a href="#cb266-123" aria-hidden="true" tabindex="-1"></a>        (</span>
<span id="cb266-124"><a href="#cb266-124" aria-hidden="true" tabindex="-1"></a>            <span class="pp">slice::</span>from_raw_parts_mut(ptr<span class="op">,</span> mid)<span class="op">,</span></span>
<span id="cb266-125"><a href="#cb266-125" aria-hidden="true" tabindex="-1"></a>            <span class="pp">slice::</span>from_raw_parts_mut(ptr<span class="op">.</span>add(mid)<span class="op">,</span> len <span class="op">-</span> mid)</span>
<span id="cb266-126"><a href="#cb266-126" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb266-127"><a href="#cb266-127" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb266-128"><a href="#cb266-128" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb266-129"><a href="#cb266-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb266-130"><a href="#cb266-130" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="op">{</span></span>
<span id="cb266-131"><a href="#cb266-131" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> abs(input<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">;</span></span>
<span id="cb266-132"><a href="#cb266-132" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><br />
</p></li>
<li><p>We can also use <code>extern</code> keyword to create an
interface that allows other languages to call Rust functions.<br />
Instead of creating a whole <code>extern</code> block, we add the
<code>extern</code> keyword and specify the ABI to use just before the
<code>fn</code> keyword for the relevant function. We also need to add a
<code>#[no_mangle]</code> annotation to tell the Rust compiler not to
mangle the name of this function. <strong>Mangling</strong> is when a
compiler changes the name we‚Äôve given a function to a different name
that contains more information for other parts of the compilation
process to consume but is less human readable. Every programming
language compiler mangles names slightly differently, so for a Rust
function to be nameable by other languages, we must disable the Rust
compiler‚Äôs name mangling.</p></li>
</ol>
<div class="sourceCode" id="cb267"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>no_mangle<span class="at">]</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">extern</span> <span class="st">&quot;C&quot;</span> <span class="kw">fn</span> call_from_c() <span class="op">{</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Just called a Rust function from C!&quot;</span>)<span class="op">;</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// safely callable.</span></span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a>        call_from_c()<span class="op">;</span></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>This usage of `extern` does not require `unsafe`.</code></pre>
<hr/>
<h3 id="advanced-traits">Advanced Traits</h3>
<ol type="1">
<li><strong>Associated types</strong> connect a
<code>type placeholder</code> with a <code>trait</code> such that the
trait method definitions can use these placeholder types in their
signatures. The implementor of a trait will specify the concrete type to
be used for the particular implementation.<br />
One example of a trait with an <strong>associated type</strong> is the
<code>Iterator</code> trait that the standard library provides.</li>
</ol>
<div class="sourceCode" id="cb269"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">Iterator</span> <span class="op">{</span></span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">type</span> Item<span class="op">;</span></span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;;</span></span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-6"><a href="#cb269-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// --snipet--</span></span>
<span id="cb269-7"><a href="#cb269-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb269-8"><a href="#cb269-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-9"><a href="#cb269-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> <span class="bu">Iterator</span> <span class="cf">for</span> Counter <span class="op">{</span></span>
<span id="cb269-10"><a href="#cb269-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">type</span> Item <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb269-11"><a href="#cb269-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-12"><a href="#cb269-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">Self</span><span class="pp">::</span>Item<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb269-13"><a href="#cb269-13" aria-hidden="true" tabindex="-1"></a>            <span class="co">// --snipet--</span></span>
<span id="cb269-14"><a href="#cb269-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb269-15"><a href="#cb269-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>This syntax seems comparable to that of generics.<br />
So the question is: why not just define the Iterator trait with
generics? Like follow:</li>
</ol>
<div class="sourceCode" id="cb270"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">trait</span> <span class="bu">Iterator</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> next(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span>T<span class="op">&gt;;</span></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The difference is that when using generics, we must annotate the
types in each implementation.</li>
<li>In other words, when a trait has a generic parameter, it can be
implemented for a type multiple times, changing the concrete types of
the generic type parameters each time.</li>
<li>For example <code>impl Iterator&lt;String&gt; for Counter</code> and
also <code>impl Iterator&lt;i32&gt; for Counter</code> again. With
associated types, we don‚Äôt need to annotate types because we can‚Äôt
implement a trait on a type multiple times. there can only be one
<code>impl Iterator for Counter</code>.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>Rust can also use <code>type</code> keyword for type aliases.</li>
</ol>
<div class="sourceCode" id="cb271"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Kilometers <span class="op">=</span> <span class="dt">u32</span><span class="op">;</span></span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> ResultAlias<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Result</span><span class="op">&lt;</span>T<span class="op">,</span> <span class="pp">std::io::</span><span class="bu">Error</span><span class="op">&gt;;</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Meters(<span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Meter <span class="op">=</span> Meters<span class="op">;</span></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> read_file_content() <span class="op">-&gt;</span> ResultAlias<span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::fs::</span>File<span class="op">;</span></span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span><span class="op">,</span> <span class="bu">Read</span><span class="op">};</span></span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-11"><a href="#cb271-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> file <span class="op">=</span> <span class="pp">File::</span>open(<span class="st">&quot;file.txt&quot;</span>)<span class="op">?;</span></span>
<span id="cb271-12"><a href="#cb271-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> contents <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb271-13"><a href="#cb271-13" aria-hidden="true" tabindex="-1"></a>        file<span class="op">.</span>read_to_string(<span class="op">&amp;</span><span class="kw">mut</span> contents)<span class="op">?;</span></span>
<span id="cb271-14"><a href="#cb271-14" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(contents)</span>
<span id="cb271-15"><a href="#cb271-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb271-16"><a href="#cb271-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-17"><a href="#cb271-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb271-18"><a href="#cb271-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> distance<span class="op">:</span> Kilometers <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb271-19"><a href="#cb271-19" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> distance)<span class="op">;</span></span>
<span id="cb271-20"><a href="#cb271-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-21"><a href="#cb271-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">match</span> read_file_content() <span class="op">{</span></span>
<span id="cb271-22"><a href="#cb271-22" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>(contents) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;File content: {}&quot;</span><span class="op">,</span> contents)<span class="op">,</span></span>
<span id="cb271-23"><a href="#cb271-23" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Error reading file: {}&quot;</span><span class="op">,</span> e)<span class="op">,</span></span>
<span id="cb271-24"><a href="#cb271-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb271-25"><a href="#cb271-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-26"><a href="#cb271-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> m1<span class="op">:</span> Meters <span class="op">=</span> Meters(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb271-27"><a href="#cb271-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> m2<span class="op">:</span> Meter <span class="op">=</span> Meters(<span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb271-28"><a href="#cb271-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> m3 <span class="op">=</span> Meter(<span class="dv">300</span>)<span class="op">;</span></span>
<span id="cb271-29"><a href="#cb271-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3
id="default-generic-type-parameters-and-operator-overloading">Default
Generic Type Parameters and Operator Overloading</h3>
<ol type="1">
<li>When we use generic type parameters, we can specify a default
concrete type for the generic type.<br />
This eliminates the need for implementors of the trait to specify a
concrete type if the default type works.<br />
You specify a default type when declaring a generic type with the
<code>&lt;PlaceholderType=ConcreteType&gt;</code> syntax.</li>
</ol>
<div class="sourceCode" id="cb272"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Container<span class="op">&lt;</span>T <span class="op">=</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> get_value(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> T<span class="op">;</span></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> StringContainer<span class="op">;</span></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Container <span class="cf">for</span> StringContainer <span class="op">{</span></span>
<span id="cb272-8"><a href="#cb272-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> get_value(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb272-9"><a href="#cb272-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;STR&quot;</span>)<span class="op">;</span></span>
<span id="cb272-10"><a href="#cb272-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb272-11"><a href="#cb272-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb272-12"><a href="#cb272-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-13"><a href="#cb272-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> I32Container<span class="op">;</span></span>
<span id="cb272-14"><a href="#cb272-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb272-15"><a href="#cb272-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Container<span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="cf">for</span> I32Container <span class="op">{</span></span>
<span id="cb272-16"><a href="#cb272-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> get_value(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb272-17"><a href="#cb272-17" aria-hidden="true" tabindex="-1"></a>            <span class="dv">100</span></span>
<span id="cb272-18"><a href="#cb272-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb272-19"><a href="#cb272-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li><p>Rust doesn‚Äôt allow you to create your own operators or overload
arbitrary operators.<br />
But you can overload the operations and corresponding traits listed in
<code>std::ops</code> by implementing the traits associated with the
operator.</p>
<p>The following example implements <code>Add</code> trait on a Point
struct for <code>+</code> operator.</p>
<div class="sourceCode" id="cb273"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::ops::</span><span class="bu">Add</span><span class="op">;</span></span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> <span class="bu">Copy</span><span class="op">,</span> <span class="bu">Clone</span><span class="op">,</span> <span class="bu">PartialEq</span><span class="at">)]</span></span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Add</span> <span class="cf">for</span> Point <span class="op">{</span></span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> Output <span class="op">=</span> Point<span class="op">;</span></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> other<span class="op">:</span> Point) <span class="op">-&gt;</span> Point <span class="op">{</span></span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a>        Point <span class="op">{</span></span>
<span id="cb273-14"><a href="#cb273-14" aria-hidden="true" tabindex="-1"></a>            x<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">+</span> other<span class="op">.</span>x<span class="op">,</span></span>
<span id="cb273-15"><a href="#cb273-15" aria-hidden="true" tabindex="-1"></a>            y<span class="op">:</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">+</span> other<span class="op">.</span>y<span class="op">,</span></span>
<span id="cb273-16"><a href="#cb273-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb273-17"><a href="#cb273-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb273-18"><a href="#cb273-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<ul>
<li>The default generic type of <code>Add</code> trait is here:</li>
</ul>
<div class="sourceCode" id="cb274"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> <span class="bu">Add</span><span class="op">&lt;</span>Rhs<span class="op">=</span><span class="dt">Self</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb274-2"><a href="#cb274-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">type</span> Output<span class="op">;</span></span>
<span id="cb274-3"><a href="#cb274-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb274-4"><a href="#cb274-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> add(<span class="kw">self</span><span class="op">,</span> rhs<span class="op">:</span> Rhs) <span class="op">-&gt;</span> <span class="dt">Self</span><span class="pp">::</span>Output<span class="op">;</span></span>
<span id="cb274-5"><a href="#cb274-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>When calling methods with the same name, you‚Äôll need to tell Rust
which one you want to use.</li>
</ol>
<div class="sourceCode" id="cb275"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Pilot <span class="op">{</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> fly(<span class="op">&amp;</span><span class="kw">self</span>)<span class="op">;</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Wizard <span class="op">{</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> fly(<span class="op">&amp;</span><span class="kw">self</span>)<span class="op">;</span></span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Human<span class="op">;</span></span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Pilot <span class="cf">for</span> Human <span class="op">{</span></span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> fly(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pilot fly&quot;</span>)<span class="op">;</span></span>
<span id="cb275-14"><a href="#cb275-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb275-15"><a href="#cb275-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-16"><a href="#cb275-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-17"><a href="#cb275-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Wizard <span class="cf">for</span> Human <span class="op">{</span></span>
<span id="cb275-18"><a href="#cb275-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> fly(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb275-19"><a href="#cb275-19" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Wizard fly&quot;</span>)<span class="op">;</span></span>
<span id="cb275-20"><a href="#cb275-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb275-21"><a href="#cb275-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-22"><a href="#cb275-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-23"><a href="#cb275-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Human <span class="op">{</span></span>
<span id="cb275-24"><a href="#cb275-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> fly(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb275-25"><a href="#cb275-25" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Human fly&quot;</span>)<span class="op">;</span></span>
<span id="cb275-26"><a href="#cb275-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb275-27"><a href="#cb275-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb275-28"><a href="#cb275-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-29"><a href="#cb275-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb275-30"><a href="#cb275-30" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> human <span class="op">=</span> Human<span class="op">;</span></span>
<span id="cb275-31"><a href="#cb275-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-32"><a href="#cb275-32" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Pilot::</span>fly(<span class="op">&amp;</span>human)<span class="op">;</span></span>
<span id="cb275-33"><a href="#cb275-33" aria-hidden="true" tabindex="-1"></a>        <span class="pp">Wizard::</span>fly(<span class="op">&amp;</span>human)<span class="op">;</span></span>
<span id="cb275-34"><a href="#cb275-34" aria-hidden="true" tabindex="-1"></a>        human<span class="op">.</span>fly()<span class="op">;</span></span>
<span id="cb275-35"><a href="#cb275-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Another Example:</li>
</ul>
<div class="sourceCode" id="cb276"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Animal <span class="op">{</span></span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> name() <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb276-3"><a href="#cb276-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb276-4"><a href="#cb276-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-5"><a href="#cb276-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Dog<span class="op">;</span></span>
<span id="cb276-6"><a href="#cb276-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-7"><a href="#cb276-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Animal <span class="cf">for</span> Dog <span class="op">{</span></span>
<span id="cb276-8"><a href="#cb276-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> name() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb276-9"><a href="#cb276-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Puppy&quot;</span>)</span>
<span id="cb276-10"><a href="#cb276-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb276-11"><a href="#cb276-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb276-12"><a href="#cb276-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-13"><a href="#cb276-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Dog <span class="op">{</span></span>
<span id="cb276-14"><a href="#cb276-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> name() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb276-15"><a href="#cb276-15" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;Dogg&quot;</span></span>
<span id="cb276-16"><a href="#cb276-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb276-17"><a href="#cb276-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb276-18"><a href="#cb276-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb276-19"><a href="#cb276-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb276-20"><a href="#cb276-20" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="op">&lt;</span>Dog <span class="kw">as</span> Animal<span class="op">&gt;</span><span class="pp">::</span>name())<span class="op">;</span></span>
<span id="cb276-21"><a href="#cb276-21" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Dog::</span>name())<span class="op">;</span></span>
<span id="cb276-22"><a href="#cb276-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li><p>Sometimes, you might write a trait definition that depends on
another trait:<br />
for a type to implement the first trait, you want to require that type
to also implement the second trait.<br />
You would do this so that your trait definition can make use of the
associated items of the second trait.<br />
The trait your trait definition is relying on is called a
<strong>supertrait</strong> of your trait.<br />
In Rust, a trait can also have <em>multiple</em> supertraits.</p>
<p>In this example, we‚Äôll create two traits: <code>Displayable</code>
and <code>Printable</code>.<br />
The <code>Printable</code> trait will depend on the
<code>Displayable</code> trait,<br />
meaning any type that implements <code>Printable</code> must also
implement <code>Displayable</code>.</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::fmt::</span><span class="bu">Display</span><span class="op">;</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Displayable <span class="op">:</span> <span class="bu">Display</span> <span class="op">{</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> display_value(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Printable <span class="op">:</span> Displayable <span class="op">{</span></span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>display_value())<span class="op">;</span></span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-13"><a href="#cb277-13" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> FancyPrintable <span class="op">:</span> Displayable <span class="op">+</span> <span class="bu">Clone</span> <span class="op">{</span></span>
<span id="cb277-14"><a href="#cb277-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> fancy_print(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb277-15"><a href="#cb277-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> cloned_self <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>clone()<span class="op">;</span></span>
<span id="cb277-16"><a href="#cb277-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> cloned_self<span class="op">.</span>display_value())<span class="op">;</span></span>
<span id="cb277-17"><a href="#cb277-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb277-18"><a href="#cb277-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-19"><a href="#cb277-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-20"><a href="#cb277-20" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Displayable <span class="cf">for</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb277-21"><a href="#cb277-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> display_value(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb277-22"><a href="#cb277-22" aria-hidden="true" tabindex="-1"></a>        <span class="pp">format!</span>(<span class="st">&quot;i32 {}&quot;</span><span class="op">,</span> <span class="kw">self</span>)</span>
<span id="cb277-23"><a href="#cb277-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb277-24"><a href="#cb277-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-25"><a href="#cb277-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-26"><a href="#cb277-26" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Printable <span class="cf">for</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb277-27"><a href="#cb277-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-28"><a href="#cb277-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-29"><a href="#cb277-29" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point(<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb277-30"><a href="#cb277-30" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="bu">Display</span> <span class="cf">for</span> Point <span class="op">{</span></span>
<span id="cb277-31"><a href="#cb277-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> fmt(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">std::fmt::</span>Formatter) <span class="op">-&gt;</span> <span class="pp">std::fmt::</span><span class="dt">Result</span> <span class="op">{</span></span>
<span id="cb277-32"><a href="#cb277-32" aria-hidden="true" tabindex="-1"></a>        <span class="pp">write!</span>(f<span class="op">,</span> <span class="st">&quot;({}, {})&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span><span class="dv">1</span>)</span>
<span id="cb277-33"><a href="#cb277-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb277-34"><a href="#cb277-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb277-35"><a href="#cb277-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-36"><a href="#cb277-36" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb277-37"><a href="#cb277-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb277-38"><a href="#cb277-38" aria-hidden="true" tabindex="-1"></a>    n<span class="op">.</span>print()<span class="op">;</span></span>
<span id="cb277-39"><a href="#cb277-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<hr/>
<h3 id="advanced-types">Advanced Types</h3>
<ol type="1">
<li>The Newtype Pattern in Rust involves creating a wrapper type (a ‚Äúnew
type‚Äù)<br />
around an existing type to provide additional type safety, abstraction,
or to implement traits differently.</li>
</ol>
<div class="sourceCode" id="cb278"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Meters(<span class="dt">i32</span>)<span class="op">;</span>     <span class="co">// Newtype around i32</span></span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Kilometers(<span class="dt">i32</span>)<span class="op">;</span> <span class="co">// Also newtype around i32</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Meters <span class="op">{</span></span>
<span id="cb278-5"><a href="#cb278-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> to_kilometers(<span class="kw">self</span>) <span class="op">-&gt;</span> Kilometers <span class="op">{</span></span>
<span id="cb278-6"><a href="#cb278-6" aria-hidden="true" tabindex="-1"></a>            Kilometers(<span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">/</span> <span class="dv">1000</span>)</span>
<span id="cb278-7"><a href="#cb278-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb278-8"><a href="#cb278-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb278-9"><a href="#cb278-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb278-10"><a href="#cb278-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Kilometers <span class="op">{</span></span>
<span id="cb278-11"><a href="#cb278-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> to_meters(<span class="kw">self</span>) <span class="op">-&gt;</span> Meters <span class="op">{</span></span>
<span id="cb278-12"><a href="#cb278-12" aria-hidden="true" tabindex="-1"></a>            Meters(<span class="kw">self</span><span class="op">.</span>o <span class="op">*</span> <span class="dv">1000</span>)</span>
<span id="cb278-13"><a href="#cb278-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb278-14"><a href="#cb278-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Rust has a special type named <code>!</code> that‚Äôs known in type
theory lingo as the <strong>empty type</strong>, because it has no
values.<br />
We prefer to call it the <strong>never</strong> type because it stands
in the place of the return type when a function will never return.</li>
</ol>
<div class="sourceCode" id="cb279"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> never_returns() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">panic!</span>(<span class="st">&quot;This function never returns!&quot;</span>)<span class="op">;</span></span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> infinite_loop() <span class="op">-&gt;</span> <span class="op">!</span> <span class="op">{</span></span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;LOOP&quot;</span>)<span class="op">;</span></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>Rust needs to know certain details about its types, such as how much
space to allocate for a value of a particular type. This leaves one
corner of its type system a little confusing at first: the concept of
<strong>dynamically sized types</strong>.<br />
Sometimes referred to as __DST__s or <strong>unsized</strong> types,
these types let us write code using values whose size we can know only
at runtime.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Let‚Äôs dig into the details of a dynamically sized type called
<code>str</code>, which we‚Äôve been using throughout the book.<br />
That‚Äôs right, not <code>&amp;str</code>, but <code>str</code> on its
own, is a <strong>DST</strong>.<br />
We can‚Äôt know how long the string is until runtime, meaning we can‚Äôt
create a variable of type <code>str</code>, nor can we take an argument
of type <code>str</code>.<br />
Consider the following code, which does not work:</li>
</ol>
<div class="sourceCode" id="cb280"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s1<span class="op">:</span> <span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;Hello there!&quot;</span><span class="op">;</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s2<span class="op">:</span> <span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;How&#39;s it going?&quot;</span><span class="op">;</span></span></code></pre></div>
<ul>
<li>Rust needs to know how much memory to allocate for any value of a
particular type, and all values of a type must use the same amount of
memory.</li>
<li>If Rust allowed us to write this code, these two <code>str</code>
values would need to take up the same amount of space.</li>
<li>But they have different lengths: <strong><em>s1</em></strong> needs
<code>12</code> bytes of storage and <strong><em>s2</em></strong> needs
<code>15</code>.</li>
<li>This is why it‚Äôs not possible to create a variable holding a
dynamically sized type.</li>
</ul>
<p><br />
</p>
<ol start="5" type="1">
<li>So what do we do? In this case, you already know the answer: we make
the types of <strong><em>s1</em></strong> and
<strong><em>s2</em></strong> a <code>&amp;str</code> rather than a
<code>str</code>. As such, we can know the size of a
<code>&amp;str</code> value at compile time: it‚Äôs twice the length of a
<code>usize</code>. That is, we always know the size of a
<code>&amp;str</code>, no matter how long the string it refers to
is.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li>We can also combine <code>str</code> with all kinds of pointers: for
example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>.<br />
In fact, you‚Äôve seen this before but with a different dynamically sized
type: <code>traits</code>.<br />
Every <code>trait</code> is a dynamically sized type we can refer to by
using the name of the trait. &gt; To use traits as trait objects, we
must put them behind a pointer, such as <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code>
would work too). &gt; To work with DSTs, Rust provides the
<code>Sized</code> trait to determine whether or not a type‚Äôs size is
known at compile time. This trait is automatically implemented for
everything whose size is known at compile time. In addition, Rust
implicitly adds a bound on <code>Sized</code> to every generic function.
For example, if we wrote:</li>
</ol>
<div class="sourceCode" id="cb281"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> generic_fn<span class="op">&lt;</span>T<span class="op">&gt;</span>(t<span class="op">:</span> T) <span class="op">{</span></span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// --snipet--</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>It will be automatically considered as:</code></pre>
<div class="sourceCode" id="cb283"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> generic_fn<span class="op">&lt;</span>T<span class="op">:</span> <span class="bu">Sized</span><span class="op">&gt;</span>(t<span class="op">:</span> T) <span class="op">{</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a>        <span class="co">// --snipet--</span></span>
<span id="cb283-3"><a href="#cb283-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>By default, generic functions will work only on types that have a
known size at compile time.<br />
However, you can use the following special syntax to relax this
restriction:</li>
</ol>
<div class="sourceCode" id="cb284"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> generic_fn<span class="op">&lt;</span>T<span class="op">:</span> <span class="op">?</span><span class="bu">Sized</span><span class="op">&gt;</span>(t<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>A trait bound on <code>?Sized</code> means ‚Äú<code>T</code> may or
may not be <code>Sized</code>‚Äù and this notation overrides the default
that generic types must have a known size at compile time.</li>
<li>The <code>?Trait</code> syntax with this meaning is only available
for <code>Sized</code>, not any other traits.</li>
<li>Also note that we switched the type of the
<strong><em>t</em></strong> parameter from <code>T</code> to
<code>&amp;T</code>.</li>
<li>Because the type might not be <code>Sized</code>, we need to use it
behind some kind of pointer.</li>
<li>In this case, we‚Äôve chosen a reference.</li>
</ul>
<p><br />
</p>
<ol start="8" type="1">
<li>Example Usage with <code>?Size</code>.<br />
You need to do so when working with trait objects or slices etc.</li>
</ol>
<div class="sourceCode" id="cb285"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_debug<span class="op">&lt;</span>T<span class="op">:</span> <span class="op">?</span><span class="bu">Sized</span> <span class="op">+</span> <span class="pp">std::fmt::</span><span class="bu">Debug</span><span class="op">&gt;</span>(t<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> t)<span class="op">;</span></span>
<span id="cb285-3"><a href="#cb285-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb285-4"><a href="#cb285-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-5"><a href="#cb285-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb285-6"><a href="#cb285-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb285-7"><a href="#cb285-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> slice_integers<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">i32</span>] <span class="op">=</span> <span class="op">&amp;</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb285-8"><a href="#cb285-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb285-9"><a href="#cb285-9" aria-hidden="true" tabindex="-1"></a>        print_debug(<span class="op">&amp;</span>x)<span class="op">;</span>                <span class="co">// To work with a sized type.</span></span>
<span id="cb285-10"><a href="#cb285-10" aria-hidden="true" tabindex="-1"></a>        print_debug(slice_integers)<span class="op">;</span>    <span class="co">// To work with an unsied type. (slice)</span></span>
<span id="cb285-11"><a href="#cb285-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="advanced-functions-and-closures">Advanced Functions and
Closures</h3>
<ol type="1">
<li>We‚Äôve talked about how to pass closures to functions, you can also
pass regular functions to functions! This technique is useful when you
want to pass a function you‚Äôve already defined rather than defining a
new closure. Functions coerce to the type <code>fn</code>. The
<code>fn</code> type is called a function pointer. Passing functions
with function pointers will allow you to use functions as arguments to
other functions.</li>
</ol>
<div class="sourceCode" id="cb286"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Status <span class="op">{</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a>        Value(<span class="dt">u32</span>)<span class="op">,</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a>        Stop<span class="op">,</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add_one(x<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-10"><a href="#cb286-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> do_twice(f<span class="op">:</span> <span class="kw">fn</span>(<span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">,</span> arg<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb286-11"><a href="#cb286-11" aria-hidden="true" tabindex="-1"></a>        f(arg) <span class="op">+</span> f(arg)</span>
<span id="cb286-12"><a href="#cb286-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb286-13"><a href="#cb286-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-14"><a href="#cb286-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb286-15"><a href="#cb286-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> do_twice(add_one<span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb286-16"><a href="#cb286-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span>                 <span class="co">// -&gt; 12</span></span>
<span id="cb286-17"><a href="#cb286-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> do_twice(<span class="op">|</span>x<span class="op">|</span> <span class="op">{</span>x <span class="op">+</span> <span class="dv">1</span><span class="op">},</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb286-18"><a href="#cb286-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span>                 <span class="co">// -&gt; 12</span></span>
<span id="cb286-19"><a href="#cb286-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-20"><a href="#cb286-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> list_of_numbers <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb286-21"><a href="#cb286-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> list_of_strings<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb286-22"><a href="#cb286-22" aria-hidden="true" tabindex="-1"></a>            list_of_numbers</span>
<span id="cb286-23"><a href="#cb286-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>iter()</span>
<span id="cb286-24"><a href="#cb286-24" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>map(<span class="op">|</span>i<span class="op">|</span> i<span class="op">.</span>to_string())</span>
<span id="cb286-25"><a href="#cb286-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb286-26"><a href="#cb286-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-27"><a href="#cb286-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> list_of_numbers <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb286-28"><a href="#cb286-28" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> list_of_strings<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb286-29"><a href="#cb286-29" aria-hidden="true" tabindex="-1"></a>            list_of_numbers</span>
<span id="cb286-30"><a href="#cb286-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>iter()</span>
<span id="cb286-31"><a href="#cb286-31" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>map(<span class="bu">ToString</span><span class="pp">::</span>to_string)</span>
<span id="cb286-32"><a href="#cb286-32" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb286-33"><a href="#cb286-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-34"><a href="#cb286-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-35"><a href="#cb286-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> list_of_statuses<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Status<span class="op">&gt;</span> <span class="op">=</span></span>
<span id="cb286-36"><a href="#cb286-36" aria-hidden="true" tabindex="-1"></a>            (<span class="dv">0u32</span><span class="op">..</span><span class="dv">20</span>)</span>
<span id="cb286-37"><a href="#cb286-37" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>map(<span class="pp">Status::</span>Value)</span>
<span id="cb286-38"><a href="#cb286-38" aria-hidden="true" tabindex="-1"></a>                <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb286-39"><a href="#cb286-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-40"><a href="#cb286-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Closures are represented by <code>traits</code>, which means you
can‚Äôt return closures directly. In most cases where you might want to
return a <code>trait</code>, you can instead use the concrete type that
implements the <code>trait</code> as the return value of the function.
However, you can‚Äôt do that with closures because they don‚Äôt have a
concrete type that is returnable, you‚Äôre also not allowed to use the
function pointer <code>fn</code> as a return type. The solution is:</li>
</ol>
<div class="sourceCode" id="cb287"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> returns_closure() <span class="op">-&gt;</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Fn</span>(<span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Box</span><span class="pp">::</span>new(<span class="op">|</span>x<span class="op">|</span> x <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="macros">Macros</h3>
<ol type="1">
<li><p>The term <code>macro</code> refers to a family of features in
Rust: <strong>declarative macros</strong> with <code>macro_rules!</code>
and three kinds of <strong>procedural macros</strong>:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with
the derive attribute used on structs and enums.</li>
<li>Attribute-like macros that define custom attributes usable on any
item.</li>
<li>Function-like macros that look like function calls but operate on
the tokens specified as their argument.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>The most widely used form of macros in Rust is the
<strong>declarative macro</strong>. These are also sometimes referred to
as ‚Äúmacros by exampl,‚Äù, ‚Äú<code>macro_rules!</code> macros‚Äù, or just
plain ‚Äúmacros‚Äù. At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>To define a macro, you use the <code>macro_rules!</code> construct.
Let‚Äôs explore how to use <code>macro_rules!</code> by looking at how the
<code>vec!</code> macro is defined.</li>
</ol>
<div class="sourceCode" id="cb288"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>macro_export<span class="at">]</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> vec <span class="op">{</span></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a>        ( <span class="op">$</span>( <span class="op">$</span>x<span class="op">:</span>expr )<span class="op">,*</span> ) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>                <span class="kw">let</span> <span class="kw">mut</span> temp_vec <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">$</span>(</span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a>                    temp_vec<span class="op">.</span>push(<span class="op">$</span>x)<span class="op">;</span></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a>                )<span class="op">*</span></span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true" tabindex="-1"></a>                temp_vec</span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>This shows a slightly simplified definition of the <code>vec!</code>
macro.</li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>The <code>#[macro_export]</code> annotation indicates that this
macro should be made available whenever the crate in which the macro is
defined is brought into scope. Without this annotation, the macro can‚Äôt
be brought into scope. &gt; We then start the macro definition with
<code>macro_rules!</code> and the name of the macro we‚Äôre defining
without the exclamation mark. The name, in this case
<strong><em>vec</em></strong>, is followed by curly brackets denoting
the body of the macro definition. &gt; The structure in the
<code>vec!</code> body is similar to the structure of a
<code>match</code> expression. Here we have one arm with the pattern
<code>( $( $x:expr ),* )</code>, followed by <code>=&gt;</code> and the
associated code block with this pattern. If the pattern matches, the
associated block of code will be emitted. Given that this is the only
pattern in this macro, there is only one valid way to match, any other
pattern will result in an error. More complex macros will have more than
one arm. &gt; First, we use a set of parentheses to encompass the whole
pattern. We use a dollar sign (<code>$</code>) to declare a variable in
the macro system that will contain the Rust code matching the pattern.
The <code>$</code> makes it clear this is a macro variable as opposed to
a regular Rust variable. Next comes a set of parentheses that captures
values that match the pattern within the parentheses for use in the
replacement code. Within <code>$()</code> is <code>$x:expr</code>, which
matches any Rust expression and gives the expression the name
<code>$x</code>. &gt; The comma following <code>$()</code> indicates
that a literal comma separator character could optionally appear after
the code that matches the code in <code>$()</code>. The <code>*</code>
specifies that the pattern matches <code>zero or more</code> of whatever
precedes the <code>*</code>. &gt; When we call this macro with
<code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and
<code>3</code>.</li>
</ol>
<p><br />
</p>
<ol start="5" type="1">
<li>The second form of macros is the procedural macro, which acts more
like a function (and is a type of procedure). Procedural macros accept
some code as an input, operate on that code, and produce some code as an
output rather than matching against patterns and replacing the code with
other code as declarative macros. The three kinds of procedural macros
are custom derive, attribute-like, and function-like, and all work in a
similar fashion.</li>
</ol>
<p><br />
</p>
<ol start="6" type="1">
<li>When creating procedural macros, the definitions must reside in
their own crate with a special crate type. This is for complex technical
reasons that we hope to eliminate in the future. We‚Äôll show now how to
define a procedural macro, where <code>some_attribute</code> is a
placeholder for using a specific macro variety.</li>
</ol>
<div class="sourceCode" id="cb289"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> proc_macro<span class="op">;</span></span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>some_attribute<span class="at">]</span></span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> some_name(input<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The function that defines a procedural macro takes a
<code>TokenStream</code> as an input and produces a
<code>TokenStream</code> as an output. The <code>TokenStream</code> type
is defined by the <code>proc_macro</code> crate that is included with
Rust and represents a sequence of tokens. This is the core of the macro:
the source code that the macro is operating on makes up the input
<code>TokenStream</code>, and the code the macro produces is the output
<code>TokenStream</code>. The function also has an attribute attached to
it that specifies which kind of procedural macro we‚Äôre creating. We can
have multiple kinds of procedural macros in the same crate.</li>
</ul>
<hr/>
<h3 id="example-of-a-procedural-macro-using-proc_macro">Example of a
Procedural Macro Using <code>proc_macro</code></h3>
<ol type="1">
<li>This example demonstrates a procedural macro that repeats any given
input code twice,<br />
essentially ‚Äúduplicating‚Äù it.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>To create a new procedural macro crate.</li>
</ol>
<div class="sourceCode" id="cb290"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new my_macro <span class="at">--lib</span></span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd my_macro/</span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>Inside the generated <code>Cargo.toml</code>, you must specify that
this crate is for procedural macros by adding the
<code>proc-macro = true</code> attribute.</li>
</ol>
<blockquote>
<ul>
<li>Cargo.toml</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb291"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[lib]</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">proc-macro</span> <span class="op">=</span> <span class="cn">true</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>Now let‚Äôs implement it.</li>
</ol>
<blockquote>
<ul>
<li>src/lib.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb292"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This marks the `duplicate()` function as procedural macro.</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>proc_macro<span class="at">]</span></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> duplicate(input<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Convert the input TokenStream into a string of code.</span></span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> input_code <span class="op">=</span> input<span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Duplicate the input code.</span></span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> output_code <span class="op">=</span> <span class="pp">format!</span>(<span class="st">&quot;{}{}&quot;</span><span class="op">,</span> input_code<span class="op">,</span> input_code)<span class="op">;</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Convert the string back to TokenStream and return it.</span></span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a>        output_code<span class="op">.</span>parse()<span class="op">.</span>unwrap()</span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>To create an executable crate.</li>
</ol>
<div class="sourceCode" id="cb293"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new macro_client</span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd macro_client/</span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Inside the <code>Cargo.toml</code>, add the procedural macro crate
(my_macro) as dependency.</li>
</ol>
<div class="sourceCode" id="cb294"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[dependencies]</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">my_macro</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">path</span><span class="op"> =</span> <span class="st">&quot;../my_macro&quot;</span><span class="op"> }</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li>Inside <code>src/main.rs</code>, use the procedural macro.</li>
</ol>
<div class="sourceCode" id="cb295"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">my_macro::</span>duplicate<span class="op">;</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">duplicate!</span> <span class="op">{</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;A&quot;</span>)<span class="op">;</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="8" type="1">
<li>Run the <code>macro_client</code>.</li>
</ol>
<div class="sourceCode" id="cb296"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo run</span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">A</span></span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">A</span></span></code></pre></div>
<p><br />
</p>
<ol start="9" type="1">
<li>Procedural macros cannot be defined in the same crate as the
executable, because they must be compiled before they are used, having
them in the same crate might break the compilation order.</li>
</ol>
<p><br />
</p>
<ol start="10" type="1">
<li>More Complex Example (Function Generator)</li>
</ol>
<div class="sourceCode" id="cb297"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">quote::</span>quote<span class="op">;</span></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>proc_macro<span class="at">]</span></span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> generate_fn(_input<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> expanded <span class="op">=</span> <span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> hello_world() <span class="op">{</span></span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true" tabindex="-1"></a>        expanded<span class="op">.</span>into()</span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>To use it in another project be like:</code></pre>
<div class="sourceCode" id="cb299"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">my_macro::</span>generate_fn<span class="op">;</span></span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// This generates the `hello_world` function</span></span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">generate_fn!</span>()<span class="op">;</span></span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true" tabindex="-1"></a>        hello_world()<span class="op">;</span></span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="how-to-write-a-custom-derive-macro">How to Write a Custom
<code>derive</code> Macro</h3>
<ol type="1">
<li>Writing a custom <code>derive</code> macro in Rust allows you to
automatically generate code for implementing a trait for a given type
(usually structs or enums).</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>To create a procedural macro crate.</li>
</ol>
<div class="sourceCode" id="cb300"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new my_derive_macro <span class="at">--lib</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd my_derive_macro/</span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>In <code>my_derive_macro/Cargo.toml</code>,<br />
mark this crate as a procedural macro crate by adding
<code>proc-macro = true</code>.</li>
</ol>
<div class="sourceCode" id="cb301"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[package]</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">name</span> <span class="op">=</span> <span class="st">&quot;my_derive_macro&quot;</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">version</span> <span class="op">=</span> <span class="st">&quot;0.1.0&quot;</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">edition</span> <span class="op">=</span> <span class="st">&quot;2021&quot;</span></span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[lib]</span></span>
<span id="cb301-7"><a href="#cb301-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">proc-macro</span> <span class="op">=</span> <span class="cn">true</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>To create custom derive macros, we often use the <code>syn</code>
and <code>quote</code> crates to help parse Rust code and generate code
respectively.<br />
Add them into the <code>Cargo.toml</code>.</li>
</ol>
<div class="sourceCode" id="cb302"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[dependencies]</span></span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">syn</span> <span class="op">=</span> <span class="st">&quot;2.0&quot;</span></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">quote</span> <span class="op">=</span> <span class="st">&quot;1.0&quot;</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>In <code>src/lib.rs</code>, define your custom derive macro.</li>
</ol>
<div class="sourceCode" id="cb303"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span></span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">quote::</span>quote<span class="op">;</span></span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> syn<span class="op">;</span></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>proc_macro_derive<span class="at">(</span>MyDebug<span class="at">)]</span></span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> my_debug_derive(input<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Parse the input tokens into a syntax tree.</span></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> ast <span class="op">=</span> <span class="pp">syn::</span>parse(input)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb303-9"><a href="#cb303-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-10"><a href="#cb303-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Build the implementation of the Debug trait.</span></span>
<span id="cb303-11"><a href="#cb303-11" aria-hidden="true" tabindex="-1"></a>        impl_my_debug(<span class="op">&amp;</span>ast)</span>
<span id="cb303-12"><a href="#cb303-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb303-13"><a href="#cb303-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-14"><a href="#cb303-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> impl_my_debug(ast<span class="op">:</span> <span class="op">&amp;</span><span class="pp">syn::</span>DeriveInput) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb303-15"><a href="#cb303-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get the name of the struct or enum.</span></span>
<span id="cb303-16"><a href="#cb303-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> name <span class="op">=</span> <span class="op">&amp;</span>ast<span class="op">.</span>ident<span class="op">;</span></span>
<span id="cb303-17"><a href="#cb303-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-18"><a href="#cb303-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Generate code using the quote! macro.</span></span>
<span id="cb303-19"><a href="#cb303-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> gen <span class="op">=</span> <span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb303-20"><a href="#cb303-20" aria-hidden="true" tabindex="-1"></a>            <span class="kw">impl</span> <span class="pp">std::fmt::</span><span class="bu">Debug</span> <span class="cf">for</span> #name <span class="op">{</span></span>
<span id="cb303-21"><a href="#cb303-21" aria-hidden="true" tabindex="-1"></a>                <span class="kw">fn</span> fmt(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">std::fmt::</span>Formatter) <span class="op">-&gt;</span> <span class="pp">std::fmt::</span><span class="dt">Result</span> <span class="op">{</span></span>
<span id="cb303-22"><a href="#cb303-22" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">write!</span>(f<span class="op">,</span> <span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">stringify!</span>(#name))</span>
<span id="cb303-23"><a href="#cb303-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb303-24"><a href="#cb303-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb303-25"><a href="#cb303-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb303-26"><a href="#cb303-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-27"><a href="#cb303-27" aria-hidden="true" tabindex="-1"></a>        gen<span class="op">.</span>into()</span>
<span id="cb303-28"><a href="#cb303-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>To create a new binary project.</li>
</ol>
<div class="sourceCode" id="cb304"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new my_macro_client</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd my_macro_client/</span></code></pre></div>
<blockquote>
<p>Cargo.toml</p>
</blockquote>
<div class="sourceCode" id="cb305"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[dependencies]</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">my_derive_macro</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a><span class="op">        </span><span class="dt">path</span><span class="op"> =</span> <span class="st">&quot;../my_derive_macro&quot;</span></span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a><span class="op">    }</span></span></code></pre></div>
<blockquote>
<p>src/main.rs</p>
</blockquote>
<div class="sourceCode" id="cb306"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">my_derive_macro::</span>MyDebug<span class="op">;</span></span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-3"><a href="#cb306-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>derive<span class="at">(</span>MyDebug<span class="at">)]</span></span>
<span id="cb306-4"><a href="#cb306-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> TestStruct <span class="op">{</span></span>
<span id="cb306-5"><a href="#cb306-5" aria-hidden="true" tabindex="-1"></a>        value<span class="op">:</span> <span class="dt">i32</span></span>
<span id="cb306-6"><a href="#cb306-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb306-7"><a href="#cb306-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb306-8"><a href="#cb306-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb306-9"><a href="#cb306-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> test <span class="op">=</span> TestStruct <span class="op">{</span> value<span class="op">:</span> <span class="dv">10</span> <span class="op">};</span></span>
<span id="cb306-10"><a href="#cb306-10" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> test)<span class="op">;</span> <span class="co">// -&gt; TestStruct</span></span>
<span id="cb306-11"><a href="#cb306-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="attribute-like-macros">Attribute-like Macros</h3>
<ol type="1">
<li>Attribute-like macros in Rust allow you to define custom attributes
for items like functions, structs, and enums. These macros can modify
the code at compile time, similar to <code>#[derive]</code> macros, but
they give you more flexibility since they can work on any item (not just
enums or structures).</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>To create new procedural macro crate.</li>
</ol>
<div class="sourceCode" id="cb307"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new my_attr_macro <span class="at">--lib</span></span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd my_attr_macro/</span></code></pre></div>
<blockquote>
<ul>
<li>Cargo.toml</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb308"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[lib]</span></span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">proc-macro</span> <span class="op">=</span> <span class="cn">true</span></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[dependencies]</span></span>
<span id="cb308-5"><a href="#cb308-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">syn</span> <span class="op">=</span> <span class="st">&quot;2.0&quot;</span></span>
<span id="cb308-6"><a href="#cb308-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">quote</span> <span class="op">=</span> <span class="st">&quot;1.0&quot;</span></span></code></pre></div>
<blockquote>
<ul>
<li>src/lib.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb309"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">proc_macro::</span>TokenStream<span class="op">;</span></span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">quote::</span>quote<span class="op">;</span></span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">syn::</span><span class="op">{</span>parse_macro_input<span class="op">,</span> ItemFn<span class="op">};</span></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>proc_macro_attribute<span class="at">]</span></span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> my_custom_attrbute(_attr<span class="op">:</span> TokenStream<span class="op">,</span> item<span class="op">:</span> TokenStream) <span class="op">-&gt;</span> TokenStream <span class="op">{</span></span>
<span id="cb309-7"><a href="#cb309-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Parse the input token stream as a function.</span></span>
<span id="cb309-8"><a href="#cb309-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> input <span class="op">=</span> <span class="pp">parse_macro_input!</span>(item <span class="kw">as</span> ItemFn)<span class="op">;</span></span>
<span id="cb309-9"><a href="#cb309-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> fn_name <span class="op">=</span> <span class="op">&amp;</span>input<span class="op">.</span>sig<span class="op">.</span>ident<span class="op">;</span></span>
<span id="cb309-10"><a href="#cb309-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> code_block <span class="op">=</span> <span class="op">&amp;</span>input<span class="op">.</span>block<span class="op">;</span></span>
<span id="cb309-11"><a href="#cb309-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-12"><a href="#cb309-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Generate the modified function body.</span></span>
<span id="cb309-13"><a href="#cb309-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> output <span class="op">=</span> <span class="pp">quote!</span> <span class="op">{</span></span>
<span id="cb309-14"><a href="#cb309-14" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> #fn_name() <span class="op">{</span></span>
<span id="cb309-15"><a href="#cb309-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">// This will insert the original function body</span></span>
<span id="cb309-16"><a href="#cb309-16" aria-hidden="true" tabindex="-1"></a>                #block</span>
<span id="cb309-17"><a href="#cb309-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Add some custom behavior: Print after calling the function.</span></span>
<span id="cb309-18"><a href="#cb309-18" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Function &#39;{}&#39; is called&quot;</span><span class="op">,</span> <span class="pp">stringify!</span>(#fn_name))<span class="op">;</span></span>
<span id="cb309-19"><a href="#cb309-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb309-20"><a href="#cb309-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-21"><a href="#cb309-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb309-22"><a href="#cb309-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-23"><a href="#cb309-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Convert the output back into a token stream</span></span>
<span id="cb309-24"><a href="#cb309-24" aria-hidden="true" tabindex="-1"></a>        output<span class="op">.</span>into()</span>
<span id="cb309-25"><a href="#cb309-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>To create a binary execuable.</li>
</ol>
<div class="sourceCode" id="cb310"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo new macro_client</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cd macro_client/</span></code></pre></div>
<blockquote>
<ul>
<li>Cargo.toml</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb311"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">[dependencies]</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">my_attr_macro</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">path</span><span class="op"> =</span> <span class="st">&quot;../my_attr_macro&quot;</span><span class="op"> }</span></span></code></pre></div>
<blockquote>
<ul>
<li>src/main.rs</li>
</ul>
</blockquote>
<div class="sourceCode" id="cb312"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">my_attr_macro::</span>my_custom_attrbute<span class="op">;</span></span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-3"><a href="#cb312-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>my_custom_attrbute<span class="at">]</span></span>
<span id="cb312-4"><a href="#cb312-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> test_function() <span class="op">{</span></span>
<span id="cb312-5"><a href="#cb312-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Inside the function!&quot;</span>)<span class="op">;</span></span>
<span id="cb312-6"><a href="#cb312-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb312-7"><a href="#cb312-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb312-8"><a href="#cb312-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb312-9"><a href="#cb312-9" aria-hidden="true" tabindex="-1"></a>        test_function()<span class="op">;</span></span>
<span id="cb312-10"><a href="#cb312-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb313"><pre
class="sourceCode zsh"><code class="sourceCode zsh"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>    <span class="ex">$</span> cargo run</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Inside</span> the function!</span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Function</span> <span class="st">&#39;test_function&#39;</span> is called.</span></code></pre></div>
<hr/>
<h3 id="dyn-keyword"><code>dyn</code> Keyword</h3>
<ol type="1">
<li>The <code>dyn</code> keyword in Rust is short for ‚Äúdynamic dispatch‚Äù
and is used when working with <code>trait</code> objects. Trait objects
allow for dynamic polymorphism, meaning that at runtime, Rust can
dynamically choose which implementation of a trait to call based on the
concrete type of the object, rather than at compile time (which is known
as ‚Äústatic dispatch‚Äù).</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>When you use <code>dyn</code> in Rust,<br />
you are telling the compiler that you want to use ‚Äúdynamic dispatch‚Äù to
handle trait method calls.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Syntax:</li>
</ol>
<div class="sourceCode" id="cb314"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// `x` is a trait object, pointing to `some_type` that implements `Trait`.</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> Trait <span class="op">=</span> <span class="op">&amp;</span>some_type<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li>Example in action:</li>
</ol>
<div class="sourceCode" id="cb315"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Draw <span class="op">{</span></span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>)<span class="op">;</span></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Circle <span class="op">{</span></span>
<span id="cb315-6"><a href="#cb315-6" aria-hidden="true" tabindex="-1"></a>        radius<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb315-7"><a href="#cb315-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-8"><a href="#cb315-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-9"><a href="#cb315-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Squre <span class="op">{</span></span>
<span id="cb315-10"><a href="#cb315-10" aria-hidden="true" tabindex="-1"></a>        side<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb315-11"><a href="#cb315-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-12"><a href="#cb315-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-13"><a href="#cb315-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Draw <span class="cf">for</span> Circle <span class="op">{</span></span>
<span id="cb315-14"><a href="#cb315-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb315-15"><a href="#cb315-15" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Drawing circle with radius {}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>radius)<span class="op">;</span></span>
<span id="cb315-16"><a href="#cb315-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb315-17"><a href="#cb315-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-18"><a href="#cb315-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-19"><a href="#cb315-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Draw <span class="cf">for</span> Squre <span class="op">{</span></span>
<span id="cb315-20"><a href="#cb315-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> draw(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb315-21"><a href="#cb315-21" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Drawing square with side length {}&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>side)<span class="op">;</span></span>
<span id="cb315-22"><a href="#cb315-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb315-23"><a href="#cb315-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-24"><a href="#cb315-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-25"><a href="#cb315-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb315-26"><a href="#cb315-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> circle <span class="op">=</span> Circle <span class="op">{</span></span>
<span id="cb315-27"><a href="#cb315-27" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">:</span> <span class="dv">10.0</span><span class="op">,</span></span>
<span id="cb315-28"><a href="#cb315-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb315-29"><a href="#cb315-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> square <span class="op">=</span> Squre <span class="op">{</span></span>
<span id="cb315-30"><a href="#cb315-30" aria-hidden="true" tabindex="-1"></a>            size<span class="op">:</span> <span class="dv">5.0</span><span class="op">,</span></span>
<span id="cb315-31"><a href="#cb315-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb315-32"><a href="#cb315-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-33"><a href="#cb315-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// let shapes: Vec&lt;Box&lt;dyn Draw&gt;&gt; = vec![Box::new(circle), Box::new(square)];</span></span>
<span id="cb315-34"><a href="#cb315-34" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> shapes<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;&amp;</span><span class="kw">dyn</span> Draw<span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="op">&amp;</span>circle<span class="op">,</span> <span class="op">&amp;</span>square]<span class="op">;</span></span>
<span id="cb315-35"><a href="#cb315-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-36"><a href="#cb315-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> shape <span class="kw">in</span> shapes <span class="op">{</span></span>
<span id="cb315-37"><a href="#cb315-37" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">.</span>draw()<span class="op">;</span></span>
<span id="cb315-38"><a href="#cb315-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb315-39"><a href="#cb315-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-40"><a href="#cb315-40" aria-hidden="true" tabindex="-1"></a>        static_dispatch(<span class="op">&amp;</span>circle)<span class="op">;</span></span>
<span id="cb315-41"><a href="#cb315-41" aria-hidden="true" tabindex="-1"></a>        static_dispatch(<span class="op">&amp;</span>square)<span class="op">;</span></span>
<span id="cb315-42"><a href="#cb315-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-43"><a href="#cb315-43" aria-hidden="true" tabindex="-1"></a>        dynamic_dispatch(<span class="op">&amp;</span>circle)<span class="op">;</span></span>
<span id="cb315-44"><a href="#cb315-44" aria-hidden="true" tabindex="-1"></a>        dynamic_dispatch(<span class="op">&amp;</span>square)<span class="op">;</span></span>
<span id="cb315-45"><a href="#cb315-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-46"><a href="#cb315-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-47"><a href="#cb315-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> static_dispatch<span class="op">&lt;</span>T<span class="op">:</span> Draw<span class="op">&gt;</span>(shape<span class="op">:</span> <span class="op">&amp;</span>T) <span class="op">{</span></span>
<span id="cb315-48"><a href="#cb315-48" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">.</span>draw()<span class="op">;</span></span>
<span id="cb315-49"><a href="#cb315-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb315-50"><a href="#cb315-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-51"><a href="#cb315-51" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> dynamic_dispatch(shape<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> Draw) <span class="op">{</span></span>
<span id="cb315-52"><a href="#cb315-52" aria-hidden="true" tabindex="-1"></a>        shape<span class="op">.</span>draw()<span class="op">;</span></span>
<span id="cb315-53"><a href="#cb315-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="raw-identifiers">Raw Identifiers</h3>
<ol type="1">
<li>Raw identifiers are the syntax that lets you use keywords where they
wouldn‚Äôt normally be allowed. You use a raw identifier by prefixing a
keyword with <code>r#</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>For example, <code>match</code> is a keyword, but what if you wanna
use it as a fn name?</li>
</ol>
<div class="sourceCode" id="cb316"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> r#match(needle<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> haystack<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>        haystack<span class="op">.</span>contains(needle)<span class="op">;</span></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert!</span>(<span class="an">r#</span>match(<span class="st">&quot;foo&quot;</span><span class="op">,</span> <span class="st">&quot;foobar&quot;</span>))<span class="op">;</span></span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h1 id="operators">Operators</h1>
<ol type="1">
<li>Macro expansion <code>!</code>
<ul>
<li><code>ident!(...)</code></li>
<li><code>ident![...]</code></li>
<li><code>ident!{...}</code></li>
</ul></li>
<li>Bitwise or logical complement <code>!</code>
<ul>
<li><code>!expr</code></li>
<li>[Trait] <strong>NOT</strong></li>
</ul></li>
<li>Nonequality comparsion <code>!=</code>
<ul>
<li><code>expr != expr</code></li>
<li>[Trait] <strong>PartialEq</strong></li>
</ul></li>
<li>Arithmetic remainder <code>%</code>
<ul>
<li><code>expr % expr</code></li>
<li>[Trait] <strong>REM</strong></li>
</ul></li>
<li>Arithmetic remainder and assignment <code>%=</code>
<ul>
<li><code>var %= expr</code></li>
<li>[Trait] <strong>RemAssign</strong></li>
</ul></li>
<li>Borrow <code>&amp;</code>
<ul>
<li><code>&amp;expr</code></li>
<li><code>&amp;mut expr</code></li>
</ul></li>
<li>Borrowed pointer type <code>&amp;</code>
<ul>
<li><code>&amp;type</code></li>
<li><code>&amp;mut type</code></li>
<li><code>&amp;'a type</code></li>
<li><code>&amp;'a mut type</code></li>
</ul></li>
<li>Bitwise AND <code>&amp;</code>
<ul>
<li><code>expr &amp; expr</code></li>
<li>[Trait] <strong>BitAnd</strong></li>
</ul></li>
<li>Bitwise AND and assignment <code>&amp;=</code>
<ul>
<li><code>var &amp;= expr</code></li>
<li>[Trait] <strong>BitAndAssign</strong></li>
</ul></li>
<li>Short-circuiting logical AND <code>&amp;&amp;</code>
<ul>
<li><code>expr &amp;&amp; expr</code></li>
</ul></li>
<li>Dereference <code>*</code>
<ul>
<li><code>expr * expr</code></li>
<li>[Trait] <strong>Deref</strong></li>
</ul></li>
<li>Row pointer <code>*</code>
<ul>
<li><code>*const type</code></li>
<li><code>*mut type</code></li>
</ul></li>
<li>Compound type constraint <code>+</code>
<ul>
<li><code>trait + trait</code></li>
<li><code>'a + trait</code></li>
</ul></li>
<li>Arithmetic addition <code>+</code>
<ul>
<li><code>expr + expr</code></li>
<li>[Trait] <strong>Add</strong></li>
</ul></li>
<li>Arithmetic addition and assignment <code>+=</code>
<ul>
<li><code>var += expr</code></li>
<li>[Trait] <strong>AddAssign</strong></li>
</ul></li>
<li>Argument and element separator <code>,</code>
<ul>
<li><code>expr, expr</code></li>
</ul></li>
<li>Arithmetic negation <code>-</code>
<ul>
<li><code>- expr</code></li>
<li>[Trait] <strong>Neg</strong></li>
</ul></li>
<li>Arithmetic subtraction <code>-</code>
<ul>
<li><code>expr - expr</code></li>
<li>[Trait] <strong>Sub</strong></li>
</ul></li>
<li>Arithmetic subtraction and assignment <code>-=</code>
<ul>
<li><code>var -= expr</code></li>
<li>[Trait] <strong>SubAssign</strong></li>
</ul></li>
<li>Function and closure return type <code>-&gt;</code>
<ul>
<li><code>fn(...) -&gt; type</code></li>
<li><code>|...| -&gt; type</code></li>
</ul></li>
<li>Member access <code>.</code>
<ul>
<li><code>expr.ident</code></li>
</ul></li>
<li>Right-exclusive range literal <code>..</code>
<ul>
<li><code>..</code></li>
<li><code>expr..</code></li>
<li><code>..expr</code></li>
<li><code>expr..expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Right-inclusive range literal <code>..=</code>
<ul>
<li><code>..=expr</code></li>
<li><code>expr..=expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Structure literal update syntax <code>..</code>
<ul>
<li><code>..expr</code></li>
</ul></li>
<li>‚ÄúAnd the rest‚Äù pattern binding <code>..</code>
<ul>
<li><code>variant(x, ..)</code></li>
<li><code>struct_type { x, .. }</code></li>
</ul></li>
<li>Arithmetic division <code>/</code>
<ul>
<li><code>expr / expr</code></li>
<li>[Trait] <strong>Div</strong></li>
</ul></li>
<li>Arithmetic division and assignment <code>/=</code>
<ul>
<li><code>var /= expr</code></li>
<li>[Trait] <strong>DivAssign</strong></li>
</ul></li>
<li>Constraints <code>:</code>
<ul>
<li><code>pat: type</code></li>
<li><code>ident: type</code></li>
</ul></li>
<li>Struct field initializer <code>:</code>
<ul>
<li><code>ident: expr</code></li>
</ul></li>
<li>Loop lable <code>:</code>
<ul>
<li><code>'a: loop {...}</code></li>
</ul></li>
<li>Statement and item terminator <code>;</code>
<ul>
<li><code>expr;</code></li>
</ul></li>
<li>Part of fixed-size array syntax <code>;</code>
<ul>
<li><code>[...; len]</code></li>
</ul></li>
<li>Left-shift <code>&lt;&lt;</code>
<ul>
<li><code>expr &lt;&lt; expr</code></li>
<li>[Trait] <strong>Shl</strong></li>
</ul></li>
<li>Left-shift and assignment <code>&lt;&lt;=</code>
<ul>
<li><code>var &lt;&lt;= expr</code></li>
<li>[Trait] <strong>ShlAssign</strong></li>
</ul></li>
<li>Less than comparison <code>&lt;</code>
<ul>
<li><code>expr &lt; expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Less than or equal comparison <code>&lt;=</code>
<ul>
<li><code>expr &lt;= expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Assignment / const equivalence <code>=</code>
<ul>
<li><code>var = expr</code></li>
<li><code>ident = type</code></li>
</ul></li>
<li>Equality comparison <code>==</code>
<ul>
<li><code>expr == expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Part of match arm syntax <code>=&gt;</code>
<ul>
<li><code>pat =&gt; expr</code></li>
</ul></li>
<li>Greater than comparison <code>&gt;</code>
<ul>
<li><code>expr &gt; expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Greater than or equal to comparison <code>&gt;=</code>
<ul>
<li><code>expr &gt;= expr</code></li>
<li>[Trait] <strong>PartialOrd</strong></li>
</ul></li>
<li>Right-shift <code>&gt;&gt;</code>
<ul>
<li><code>expr &gt;&gt; expr</code></li>
<li>[Trait] <strong>Shr</strong></li>
</ul></li>
<li>Right-shift and assignment <code>&gt;&gt;=</code>
<ul>
<li><code>var &gt;&gt;= expr</code></li>
<li>[Trait] <strong>ShrAssign</strong></li>
</ul></li>
<li>Pattern binding <code>@</code>
<ul>
<li><code>ident @ pat</code></li>
</ul></li>
<li>Bitwise exclusive OR <code>^</code>
<ul>
<li><code>expr ^ expr</code></li>
<li>[Trait] <strong>BitXor</strong></li>
</ul></li>
<li>Bitwise exclusive OR and assignment <code>^=</code>
<ul>
<li><code>var ^= expr</code></li>
<li>[Trait] <strong>BitXorAssign</strong></li>
</ul></li>
<li>Pattern alternatives <code>|</code>
<ul>
<li><code>pat | pat</code></li>
</ul></li>
<li>Bitwise OR <code>|</code>
<ul>
<li><code>expr | expr</code></li>
<li>[Trait] <strong>BitOr</strong></li>
</ul></li>
<li>Bitwise OR and assignment <code>|=</code>
<ul>
<li><code>var |= expr</code></li>
<li>[Trait] <strong>BitOrAssign</strong></li>
</ul></li>
<li>Short-cuiting logical OR <code>||</code>
<ul>
<li><code>expr || expr</code></li>
</ul></li>
<li>Error propagating <code>?</code>
<ul>
<li><code>expr?</code></li>
</ul></li>
</ol>
<hr/>
<h3 id="non-operator-symbols">Non-Operator Symbols</h3>
<ol type="1">
<li>Named life time or loop label.
<ul>
<li><code>'ident</code></li>
</ul></li>
<li>String literal.
<ul>
<li><code>"..."</code></li>
</ul></li>
<li>Raw string literal, escape characters are not processed.
<ul>
<li><code>r"..."</code></li>
<li><code>r#"..."#</code></li>
<li><code>r##"..."##</code></li>
<li>etc.</li>
</ul></li>
<li>Byte string literal, consturcts an array of bytes instead of a
string.
<ul>
<li><code>b"..."</code></li>
</ul></li>
<li>Raw byte string literal, combination of raw and byte string literal.
<ul>
<li><code>br"..."</code></li>
<li><code>br#"..."#</code></li>
<li><code>br##"..."##</code></li>
<li>etc.</li>
</ul></li>
<li>Character literal.
<ul>
<li><code>'...'</code></li>
</ul></li>
<li>ASCII byte literal.
<ul>
<li><code>b'...'</code></li>
</ul></li>
<li>Namespace path.
<ul>
<li><code>ident::ident</code></li>
</ul></li>
<li>Path relative to the crate root.
<ul>
<li><code>::path</code></li>
</ul></li>
<li>Path relative to the current module.
<ul>
<li><code>self::path</code></li>
</ul></li>
<li>Associated constants, functions and types.
<ul>
<li><code>type::ident</code></li>
<li><code>&lt;type as trait&gt;::ident</code></li>
</ul></li>
<li>Associated item for a type that cannot be directly named.
(e.g.¬†<code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>,
etc.)
<ul>
<li><code>&lt;type&gt;::...</code></li>
</ul></li>
<li>Specifies parameters to generic type in a type.
(e.g.¬†<code>Vec&lt;u8&gt;</code>)
<ul>
<li><code>path&lt;...&gt;</code></li>
</ul></li>
<li>Specifies parameters to generic type, function or method in an
expression. Often refers to as turbofish.
<ul>
<li><code>path::&lt;...&gt;</code></li>
<li><code>method::&lt;...&gt;(...)</code></li>
</ul></li>
<li>Higher-ranked lifetime bounds.
<ul>
<li><code>for&lt;...&gt; type</code></li>
</ul></li>
<li>Generic lifetime <code>'b</code> must outlive lifetime
<code>'a</code>
<ul>
<li><code>'b: 'a</code></li>
</ul></li>
<li>Generic type <code>T</code> must outlive lifetime <code>'a</code>
(meaning the type cannot transitively contain any references with
lifetimes shorter than <code>'a</code>).
<ul>
<li><code>T: 'a</code></li>
</ul></li>
<li>Generic type <code>T</code> contains no borrowed references other
than <code>'static</code> ones.
<ul>
<li><code>T: 'static</code></li>
</ul></li>
<li>Compound type constraint.
<ul>
<li><code>'a + trait + trait + trait</code></li>
</ul></li>
</ol>
<hr/>
<h3 id="macros-and-attributes">Macros and Attributes</h3>
<ol type="1">
<li>Outer attribute.
<ul>
<li><code>#[meta]</code></li>
</ul></li>
<li>Inner attribute.
<ul>
<li><code>#![meta]</code></li>
</ul></li>
<li>Macro substitution.
<ul>
<li><code>$ident</code></li>
</ul></li>
<li>Macro capture.
<ul>
<li><code>$ident:expr</code></li>
</ul></li>
<li>Macro repetition.
<ul>
<li><code>$(...)...</code></li>
</ul></li>
</ol>
<hr/>
<h3 id="comments">Comments</h3>
<ol type="1">
<li>Line comment.
<ul>
<li><code>//</code></li>
</ul></li>
<li>Inner line doc comment.
<ul>
<li><code>//!</code></li>
</ul></li>
<li>Outer line doc comment.
<ul>
<li><code>///</code></li>
</ul></li>
<li>Block comment.
<ul>
<li><code>/* ... */</code></li>
</ul></li>
<li>Inner block doc comment.
<ul>
<li><code>/*! ... */</code></li>
</ul></li>
<li>Outer block doc comment.
<ul>
<li><code>/** ... */</code></li>
</ul></li>
</ol>
<hr/>
<h1 id="macros-1">Macros</h1>
<h2 id="declarative-macros">Declarative Macros</h2>
<ol type="1">
<li>Basic Declarative Macro Syntax.</li>
</ol>
<div class="sourceCode" id="cb317"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> my_macro <span class="op">{</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a>        () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern for no argument.&quot;</span>)<span class="op">;</span></span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>val<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern with one expression.&quot;</span>)<span class="op">;</span></span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-10"><a href="#cb317-10" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>(<span class="op">$</span>x<span class="op">:</span>expr)<span class="op">,*</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-11"><a href="#cb317-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern for multiple values.&quot;</span>)<span class="op">;</span></span>
<span id="cb317-12"><a href="#cb317-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>(</span>
<span id="cb317-13"><a href="#cb317-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Value: {}&quot;</span><span class="op">,</span> <span class="op">$</span>x)<span class="op">;</span></span>
<span id="cb317-14"><a href="#cb317-14" aria-hidden="true" tabindex="-1"></a>            )<span class="op">*</span></span>
<span id="cb317-15"><a href="#cb317-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-16"><a href="#cb317-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-17"><a href="#cb317-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-18"><a href="#cb317-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add <span class="op">{</span></span>
<span id="cb317-19"><a href="#cb317-19" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>b<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-20"><a href="#cb317-20" aria-hidden="true" tabindex="-1"></a>            ((<span class="op">$</span>a) <span class="op">+</span> (<span class="op">$</span>b))</span>
<span id="cb317-21"><a href="#cb317-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-22"><a href="#cb317-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-23"><a href="#cb317-23" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-24"><a href="#cb317-24" aria-hidden="true" tabindex="-1"></a>            ((<span class="op">$</span>a) <span class="op">+</span> (<span class="dv">1</span>))</span>
<span id="cb317-25"><a href="#cb317-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-26"><a href="#cb317-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-27"><a href="#cb317-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-28"><a href="#cb317-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add_as <span class="op">{</span></span>
<span id="cb317-29"><a href="#cb317-29" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>b<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>c<span class="op">:</span>ty) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-30"><a href="#cb317-30" aria-hidden="true" tabindex="-1"></a>            ( ((<span class="op">$</span>a) <span class="kw">as</span> (<span class="op">$</span>c)) <span class="op">+</span> ((<span class="op">$</span>b) <span class="kw">as</span> (<span class="op">$</span>c)) )</span>
<span id="cb317-31"><a href="#cb317-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb317-32"><a href="#cb317-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-33"><a href="#cb317-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-34"><a href="#cb317-34" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add_all <span class="op">{</span></span>
<span id="cb317-35"><a href="#cb317-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>(<span class="op">$</span>a<span class="op">:</span>expr)<span class="op">,*</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-36"><a href="#cb317-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// to handle the case without any arguments.</span></span>
<span id="cb317-37"><a href="#cb317-37" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span></span>
<span id="cb317-38"><a href="#cb317-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">// block to be repeated.</span></span>
<span id="cb317-39"><a href="#cb317-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>(<span class="op">+</span> (<span class="op">$</span>a))<span class="op">*</span></span>
<span id="cb317-40"><a href="#cb317-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb317-41"><a href="#cb317-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-42"><a href="#cb317-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-43"><a href="#cb317-43" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> ok_or_return <span class="op">{</span></span>
<span id="cb317-44"><a href="#cb317-44" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>ident(<span class="op">$</span>(<span class="op">$</span>b<span class="op">:</span>tt)<span class="op">*</span>)) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-45"><a href="#cb317-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="op">$</span>a(<span class="op">$</span>(<span class="op">$</span>b)<span class="op">*</span>) <span class="op">{</span></span>
<span id="cb317-46"><a href="#cb317-46" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Ok</span>(value) <span class="op">=&gt;</span> value<span class="op">,</span></span>
<span id="cb317-47"><a href="#cb317-47" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb317-48"><a href="#cb317-48" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="cn">Err</span>(e)<span class="op">;</span></span>
<span id="cb317-49"><a href="#cb317-49" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb317-50"><a href="#cb317-50" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb317-51"><a href="#cb317-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb317-52"><a href="#cb317-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-53"><a href="#cb317-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-54"><a href="#cb317-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb317-55"><a href="#cb317-55" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb317-56"><a href="#cb317-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">add!</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb317-57"><a href="#cb317-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">add!</span>(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb317-58"><a href="#cb317-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-59"><a href="#cb317-59" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">add_as!</span>(<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dt">u8</span>))<span class="op">;</span></span>
<span id="cb317-60"><a href="#cb317-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-61"><a href="#cb317-61" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">add_all!</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb317-62"><a href="#cb317-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-63"><a href="#cb317-63" aria-hidden="true" tabindex="-1"></a>        <span class="pp">ok_or_return!</span>(some_work(<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span>))<span class="op">;</span></span>
<span id="cb317-64"><a href="#cb317-64" aria-hidden="true" tabindex="-1"></a>        <span class="pp">ok_or_return!</span>(some_work(<span class="dv">20</span><span class="op">,</span> <span class="dv">10</span>))<span class="op">;</span></span>
<span id="cb317-65"><a href="#cb317-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-66"><a href="#cb317-66" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(())</span>
<span id="cb317-67"><a href="#cb317-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb317-68"><a href="#cb317-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-69"><a href="#cb317-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> some_work(i<span class="op">:</span> <span class="dt">i64</span><span class="op">,</span> j<span class="op">:</span> <span class="dt">i64</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>(<span class="dt">i64</span><span class="op">,</span> <span class="dt">i64</span>)<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb317-70"><a href="#cb317-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> j <span class="op">{</span></span>
<span id="cb317-71"><a href="#cb317-71" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>( (i<span class="op">,</span>j) )</span>
<span id="cb317-72"><a href="#cb317-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb317-73"><a href="#cb317-73" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(<span class="st">&quot;ERROR&quot;</span><span class="op">.</span>to_owned())</span>
<span id="cb317-74"><a href="#cb317-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb317-75"><a href="#cb317-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>The declarative macros are declared using
<code>macro_rules!</code>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Each branch can take multiple arguments, starting with the
<code>$</code> sign and followed by a <code>token type</code>:
<ul>
<li><strong>item</strong> an item, like a function, struct, module,
etc.</li>
<li><strong>block</strong> a block of statements, expression, surrounded
by braces.</li>
<li><strong>stmt</strong> a statement.</li>
<li><strong>pat</strong> a pattern.</li>
<li><strong>expr</strong> an expression.</li>
<li><strong>ty</strong> a type.</li>
<li><strong>ident</strong> an identifier.</li>
<li><strong>path</strong> a path, like <code>foo</code>,
<code>::std::mem::replace</code>,
<code>transmute::&lt;_, int&gt;</code>, ‚Ä¶</li>
<li><strong>meta</strong> a meta item, the things that go inside
<code>#[...]</code> and <code>#![...]</code> attributes.</li>
<li><strong>tt</strong> a single token tree.</li>
<li><strong>vis</strong> a possibly empty visibility qualifier, like
<code>pub</code>.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>The token type that repeats is enclosed in <code>$()</code>,
followed by a separator and a <code>*</code> or a <code>+</code>,
indicating the number of times the token will repeat. The separator is
used to distinguish the tokens from each other. The <code>$()</code>
block followed by <code>*</code> or <code>+</code> is used to indicate
the repeating block of code. <code>*</code> means 0 or more,
<code>+</code> means one or more, <code>?</code> for zero or one.</li>
</ol>
<h2 id="procedural-macros">Procedural Macros</h2>
<ol type="1">
<li>Procedural macros allow you to operate on the abstract syntax tree
(AST) of the Rust code it is given. A proc macro is a function from a
<code>TokenStream</code> (or two) to another <code>TokenStream</code>,
where the output replaces the macro invocation.</li>
</ol>
<hr/>
<h1 id="unions">Unions</h1>
<ol type="1">
<li><code>union</code> declaration uses the same syntax as a
<code>struct</code> declaration,<br />
except with <code>union</code> in place of <code>struct</code>.</li>
</ol>
<div class="sourceCode" id="cb318"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> MyUnion <span class="op">{</span></span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a>        f1<span class="op">:</span> <span class="dt">u32</span><span class="op">,</span></span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a>        f2<span class="op">:</span> <span class="dt">f32</span><span class="op">,</span></span>
<span id="cb318-5"><a href="#cb318-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>The key property of <code>union</code> is that all fields of a
<code>union</code> share common storage.</li>
<li>As a result, writes to one field of a union can overwrite its other
fields, and size of a union is determined by the size of its
<em>largest</em> field.</li>
</ul>
<p><br />
</p>
<ol start="2" type="1">
<li><p>Union field types are restricted to the following subset of
types:</p>
<ul>
<li><code>Copy</code> types</li>
<li>References (<code>&amp;T</code> and <code>&amp;mut T</code> for
arbitrary <code>T</code>)</li>
<li><code>ManuallyDrop&lt;T&gt;</code> (for arbitrary
<code>T</code>)</li>
<li><code>Tuples</code> and <code>arrays</code> containing only allowed
union field types</li>
</ul>
<p>This restriction ensures, in particular, that <code>union</code>
fields never need to be dropped. Like for structs and enums, it is
possible to <code>impl Drop</code> for a <code>union</code> to manually
define what happens when it gets dropped.</p></li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Unions without any fields are not accepted by the compiler, but can
be accepted by macros.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>To access the <code>union</code> field, you have to use
<code>unsafe</code>.</li>
</ol>
<div class="sourceCode" id="cb319"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_union <span class="op">=</span> MyUnion <span class="op">{</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>        f1<span class="op">:</span> <span class="dv">10</span></span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> f <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>        u<span class="op">.</span>f1</span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Another way to access <code>union</code> fields is to use pattern
matching.</li>
</ol>
<div class="sourceCode" id="cb320"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> access_union_fields(u<span class="op">:</span> MyUnion) <span class="op">{</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> u <span class="op">{</span></span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a>                MyUnion <span class="op">{</span> f1<span class="op">:</span><span class="dv">10</span> <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;f1 TEN&quot;</span>)<span class="op">,</span></span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a>                MyUnion <span class="op">{</span> f2 <span class="op">}</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;f2 {f2}&quot;</span>)<span class="op">,</span></span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>When you use <code>#[repr(C)]</code>, you are telling the Rust
compiler to use the C language‚Äôs memory layout for the type, which
ensures compatibility with C when interfacing with external (foreign)
code or libraries written in C. (commonly referred to as FFI, Foreign
Function Interface)</li>
</ol>
<p><br />
</p>
<ol start="7" type="1">
<li>When you apply <code>#[repr(u32)]</code> to an <code>enum</code>,
each variant of the <code>enum</code> is represented internally as a
<code>u32</code>, meaning that the compiler will assign specific
<code>u32</code> values to each variant. This is particularly useful
when working with FFI (Foreign Function Interface).</li>
</ol>
<hr/>
<h1 id="conditional-compilation">Conditional Compilation</h1>
<ol type="1">
<li>The <code>cfg</code> attribute conditionally includes the thing it
is attached to based on a configuration predicate.<br />
It is written as <code>cfg</code> <code>(</code> a configuration
predicate <code>)</code>.</li>
</ol>
<div class="sourceCode" id="cb321"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function is only included in the build when compiling for macOS.</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>target_os <span class="op">=</span> <span class="st">&quot;macos&quot;</span><span class="at">)]</span></span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> macos_only() <span class="op">{</span></span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function is only included when either `foo` or `bar` is defined.</span></span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>any<span class="at">(</span>foo<span class="op">,</span> bar<span class="at">))]</span></span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> needs_foo_or_bar() <span class="op">{</span></span>
<span id="cb321-9"><a href="#cb321-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-10"><a href="#cb321-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-11"><a href="#cb321-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function is only included when compiling for a unix-ish OS with a 32-bit architecture.</span></span>
<span id="cb321-12"><a href="#cb321-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>all<span class="at">(</span>unix<span class="op">,</span> target_pointer_width <span class="op">=</span> <span class="st">&quot;32&quot;</span><span class="at">))]</span></span>
<span id="cb321-13"><a href="#cb321-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> on_32bit_unit() <span class="op">{</span></span>
<span id="cb321-14"><a href="#cb321-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-15"><a href="#cb321-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-16"><a href="#cb321-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function is only included when foo is not defined.</span></span>
<span id="cb321-17"><a href="#cb321-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>not<span class="at">(</span>foo<span class="at">))]</span></span>
<span id="cb321-18"><a href="#cb321-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> needs_not_foo() <span class="op">{</span></span>
<span id="cb321-19"><a href="#cb321-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb321-20"><a href="#cb321-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb321-21"><a href="#cb321-21" aria-hidden="true" tabindex="-1"></a><span class="co">        In a project using Cargo, you could define `foo` in `Cargo.toml` under [features],</span></span>
<span id="cb321-22"><a href="#cb321-22" aria-hidden="true" tabindex="-1"></a><span class="co">        [features]</span></span>
<span id="cb321-23"><a href="#cb321-23" aria-hidden="true" tabindex="-1"></a><span class="co">        foo = []</span></span>
<span id="cb321-24"><a href="#cb321-24" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb321-25"><a href="#cb321-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-26"><a href="#cb321-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The function is only included when the panic strategy is set to unwind.</span></span>
<span id="cb321-27"><a href="#cb321-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>cfg<span class="at">(</span>panic <span class="op">=</span> <span class="st">&quot;unwind&quot;</span><span class="at">)]</span></span>
<span id="cb321-28"><a href="#cb321-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> when_unwinding() <span class="op">{</span></span>
<span id="cb321-29"><a href="#cb321-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>The built-in <code>cfg!</code> macro takes in a single configuration
predicate and evaluates.</li>
</ol>
<div class="sourceCode" id="cb322"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> machine <span class="op">=</span> <span class="cf">if</span> <span class="pp">cfg!</span>(unix) <span class="op">{</span></span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;unix&quot;</span></span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="pp">cfg!</span>(windows) <span class="op">{</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;windows&quot;</span></span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;other&quot;</span></span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-9"><a href="#cb322-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;I&#39;m running on a {} machine.&quot;</span><span class="op">,</span> machine)<span class="op">;</span></span></code></pre></div>
<hr/>
<h1 id="crate-level-attribute">Crate-Level Attribute</h1>
<ol type="1">
<li>In Rust, <code>#![]</code> is a crate-level attribute, meaning it
applies to the entire crate or module, not just a single item like
<code>#[...]</code>. Crate-level attributes are typically placed at the
top of your main source file (<code>main.rs</code> or
<code>lib.rs</code>) and are used to configure certain aspects of the
entire crate or program.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>To allow unused variables throughout the entire crate.</li>
</ol>
<div class="sourceCode" id="cb323"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#![</span>allow<span class="at">(</span>unused_variables<span class="at">)]</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// This would normally trigger a warning, but it&#39;s allowed</span></span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="3" type="1">
<li>The following example makes all warnings into errors at the crate
level.</li>
</ol>
<div class="sourceCode" id="cb324"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#![</span>deny<span class="at">(</span>warnings<span class="at">)]</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Any warning (e.g., unused variable) will now trigger a compile-time error</span></span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>The `#![deny(...)]` is to make specific warnings into errors at crate level.</code></pre>
<p><br />
</p>
<ol start="4" type="1">
<li>To not link the standard library (<code>std</code>).<br />
This is commonly used for embedded systems or writing low-level code
where the standard library isn‚Äôt available.</li>
</ol>
<div class="sourceCode" id="cb326"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#![</span>no_std<span class="at">]</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb326-4"><a href="#cb326-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// You cannot use features from `std`, like printing to the console</span></span>
<span id="cb326-5"><a href="#cb326-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>These attributes specify the name and type of the crate.<br />
This is mainly useful for libraries.</li>
</ol>
<div class="sourceCode" id="cb327"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#![</span>crate_name <span class="op">=</span> <span class="st">&quot;my_library&quot;</span><span class="at">]</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">#![</span>crate_type <span class="op">=</span> <span class="st">&quot;lib&quot;</span><span class="at">]</span></span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb327-4"><a href="#cb327-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">fn</span> my_function() <span class="op">{</span></span>
<span id="cb327-5"><a href="#cb327-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello from my_library&quot;</span>)<span class="op">;</span></span>
<span id="cb327-6"><a href="#cb327-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li><code>crate_name</code> sets the name of the crate (which would
normally be derived from the file name).</li>
<li><code>crate_type</code> specifies whether the crate is a library
(<code>lib</code>), a binary (<code>bin</code>), or other types.</li>
</ul>
<hr/>
<h1 id="const-generics">Const generics</h1>
<ol type="1">
<li>Constant can be used with structs.</li>
</ol>
<div class="sourceCode" id="cb328"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>Derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Miles(<span class="dt">u32</span>)<span class="op">;</span></span>
<span id="cb328-3"><a href="#cb328-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-4"><a href="#cb328-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> FIFTY_MILES<span class="op">:</span> Miles <span class="op">=</span> Miles(<span class="dv">50</span>)<span class="op">;</span></span>
<span id="cb328-5"><a href="#cb328-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb328-6"><a href="#cb328-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb328-7"><a href="#cb328-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> FIFTY_MILES)<span class="op">;</span></span>
<span id="cb328-8"><a href="#cb328-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>Const generics in Rust allow you to define types that are
parameterized by constant values,<br />
such as integers, booleans, or even other types of constants.</li>
</ol>
<div class="sourceCode" id="cb329"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print_array<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">const</span> N<span class="op">:</span> <span class="dt">usize</span><span class="op">&gt;</span>(arr<span class="op">:</span> [T<span class="op">;</span> N]) <span class="op">{</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Array has {} elements.&quot;</span><span class="op">,</span> N)<span class="op">;</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> elem <span class="kw">in</span> arr<span class="op">.</span>iter() <span class="op">{</span></span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> elem)<span class="op">;</span></span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb329-8"><a href="#cb329-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-9"><a href="#cb329-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Matrix<span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">const</span> ROWS<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> <span class="kw">const</span> COLS<span class="op">:</span> <span class="dt">usize</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb329-10"><a href="#cb329-10" aria-hidden="true" tabindex="-1"></a>        data<span class="op">:</span> [[T<span class="op">;</span> COLS]<span class="op">;</span> ROWS]<span class="op">.</span></span>
<span id="cb329-11"><a href="#cb329-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb329-12"><a href="#cb329-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-13"><a href="#cb329-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">,</span> <span class="kw">const</span> ROWS<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> <span class="kw">const</span> COLS<span class="op">:</span> <span class="dt">usize</span><span class="op">&gt;</span> Matrix<span class="op">&lt;</span>T<span class="op">,</span> ROWS<span class="op">,</span> COLS<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb329-14"><a href="#cb329-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> new(data<span class="op">:</span> [[T<span class="op">;</span> COLS]<span class="op">;</span> ROWS]) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb329-15"><a href="#cb329-15" aria-hidden="true" tabindex="-1"></a>            Matrix <span class="op">{</span> data <span class="op">}</span></span>
<span id="cb329-16"><a href="#cb329-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb329-17"><a href="#cb329-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-18"><a href="#cb329-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> dimensions(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> (<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>) <span class="op">{</span></span>
<span id="cb329-19"><a href="#cb329-19" aria-hidden="true" tabindex="-1"></a>            (ROWS<span class="op">,</span> COLS)</span>
<span id="cb329-20"><a href="#cb329-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb329-21"><a href="#cb329-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb329-22"><a href="#cb329-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-23"><a href="#cb329-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb329-24"><a href="#cb329-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb329-25"><a href="#cb329-25" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> arr)<span class="op">;</span></span>
<span id="cb329-26"><a href="#cb329-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-27"><a href="#cb329-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> matrix <span class="op">=</span> <span class="pp">Matrix::</span>new([[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">,</span> [<span class="dv">3</span><span class="op">,</span> <span class="dv">4</span>]])<span class="op">;</span></span>
<span id="cb329-28"><a href="#cb329-28" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> matrix<span class="op">.</span>dimensions())<span class="op">;</span></span>
<span id="cb329-29"><a href="#cb329-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h1 id="associated-constant">Associated Constant</h1>
<ol type="1">
<li>In Rust, <strong>associated constants</strong> are constants that
are associated with a specific type,<br />
such as a <code>struct</code>, <code>enum</code>, or
<code>trait</code>.<br />
These constants are defined as part of the type itself and can be
accessed without creating an instance of the type</li>
</ol>
<div class="sourceCode" id="cb330"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> Color <span class="op">{</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>        Red<span class="op">,</span></span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a>        Green<span class="op">,</span></span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>        Blue<span class="op">,</span></span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-7"><a href="#cb330-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Color <span class="op">{</span></span>
<span id="cb330-8"><a href="#cb330-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> DEFAULT<span class="op">:</span> Color <span class="op">=</span> <span class="pp">Color::</span>Red<span class="op">;</span></span>
<span id="cb330-9"><a href="#cb330-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-10"><a href="#cb330-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-11"><a href="#cb330-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Shape <span class="op">{</span></span>
<span id="cb330-12"><a href="#cb330-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> DEFAULT<span class="op">:</span> <span class="dt">Self</span><span class="op">;</span></span>
<span id="cb330-13"><a href="#cb330-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-14"><a href="#cb330-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-15"><a href="#cb330-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Circle <span class="op">{</span></span>
<span id="cb330-16"><a href="#cb330-16" aria-hidden="true" tabindex="-1"></a>        radius<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb330-17"><a href="#cb330-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-18"><a href="#cb330-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-19"><a href="#cb330-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Circle <span class="op">{</span></span>
<span id="cb330-20"><a href="#cb330-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> PI<span class="op">:</span> <span class="dt">f64</span> <span class="op">=</span> <span class="dv">3.1415926</span><span class="op">;</span></span>
<span id="cb330-21"><a href="#cb330-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-22"><a href="#cb330-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> <span class="kw">fn</span> new(radius<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> Circle <span class="op">{</span></span>
<span id="cb330-23"><a href="#cb330-23" aria-hidden="true" tabindex="-1"></a>            Circle <span class="op">{</span> radius <span class="op">}</span></span>
<span id="cb330-24"><a href="#cb330-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb330-25"><a href="#cb330-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-26"><a href="#cb330-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> area(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb330-27"><a href="#cb330-27" aria-hidden="true" tabindex="-1"></a>            <span class="pp">Circle::</span>PI <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>radius <span class="op">*</span> <span class="kw">self</span><span class="op">.</span>radius</span>
<span id="cb330-28"><a href="#cb330-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb330-29"><a href="#cb330-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-30"><a href="#cb330-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-31"><a href="#cb330-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Shape <span class="cf">for</span> Circle <span class="op">{</span></span>
<span id="cb330-32"><a href="#cb330-32" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> DEFAULT<span class="op">:</span> Slef <span class="op">=</span> Circle <span class="op">{</span> radius<span class="op">:</span> <span class="dv">0</span> <span class="op">};</span></span>
<span id="cb330-33"><a href="#cb330-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb330-34"><a href="#cb330-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-35"><a href="#cb330-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb330-36"><a href="#cb330-36" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> circle <span class="op">=</span> Circle <span class="op">{</span></span>
<span id="cb330-37"><a href="#cb330-37" aria-hidden="true" tabindex="-1"></a>            radius<span class="op">:</span> <span class="dv">2.0</span><span class="op">,</span></span>
<span id="cb330-38"><a href="#cb330-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb330-39"><a href="#cb330-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-40"><a href="#cb330-40" aria-hidden="true" tabindex="-1"></a>        <span class="kw">const</span> CIRCLE<span class="op">:</span> Circle <span class="op">=</span> <span class="pp">Circle::</span>new(<span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb330-41"><a href="#cb330-41" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> another_circle <span class="op">=</span> <span class="pp">Circle::</span>new(<span class="dv">10.0</span>)<span class="op">;</span></span>
<span id="cb330-42"><a href="#cb330-42" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> circle<span class="op">.</span>area())<span class="op">;</span></span>
<span id="cb330-43"><a href="#cb330-43" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">Circle::</span>PI)<span class="op">;</span></span>
<span id="cb330-44"><a href="#cb330-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li><code>const fn</code> keyword allows you to define functions that
can be evaluated at compile time.</li>
<li>This means that the function can be used in contexts where the
result of the function needs to be known and fixed before the program
runs, such as in constant expressions, static variables, or array
sizes.</li>
<li>On the other hand, a regular (non-const) function can only be
evaluated at runtime.</li>
</ul>
<hr/>
<h1 id="for..in-inner"><code>for..in</code> Inner</h1>
<ol type="1">
<li>When you use a <code>for .. in</code> loop in Rust, the loop
automatically invokes the <code>into_iter()</code> method on the
collection being iterated over. Rust‚Äôs <code>for .. in</code> loop
desugars into an iterator-based approach, meaning that it transforms the
iterable into an iterator behind the scenes, which is then used to
generate the values for each iteration.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Consider you wrote such code:</li>
</ol>
<div class="sourceCode" id="cb331"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> v <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> elem <span class="kw">in</span> v <span class="op">{</span></span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> elem)<span class="op">;</span></span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<pre><code>It&#39;s kinda internally transformed into:</code></pre>
<div class="sourceCode" id="cb333"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> v_iter <span class="op">=</span> v<span class="op">.</span>into_iter()<span class="op">;</span></span>
<span id="cb333-2"><a href="#cb333-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="kw">let</span> <span class="cn">Some</span>(elem) <span class="op">=</span> iter<span class="op">.</span>next() <span class="op">{</span></span>
<span id="cb333-3"><a href="#cb333-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> elem)<span class="op">;</span></span>
<span id="cb333-4"><a href="#cb333-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h1 id="lifetime-elision">Lifetime Elision</h1>
<ol type="1">
<li>The placeholder lifetime, <code>'_</code>, can be used to have a
lifetime inferred. For lifetimes in paths, using <code>'_</code> is
preferred. <code>Trait</code> object lifetimes follow different rules
which will be discussed later.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>Each elided lifetime in the parameters becomes a distinct lifetime
parameter. If there is exactly one lifetime used in the parameters
(elided or not), that lifetime is assigned to all elided output
lifetimes.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>In method signatures there is another rule that if the receiver has
type <code>&amp;Self</code> or <code>&amp;mut Self</code>, then the
lifetime of that reference to <code>Self</code> is assigned to all
elided output lifetime parameters.</li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>Examples:</li>
</ol>
<div class="sourceCode" id="cb334"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> STRING1<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;str&quot;</span><span class="op">;</span></span>
<span id="cb334-2"><a href="#cb334-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> STRING2<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;str&quot;</span><span class="op">;</span></span>
<span id="cb334-3"><a href="#cb334-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-4"><a href="#cb334-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print1(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-5"><a href="#cb334-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print2(s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;_</span> <span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-6"><a href="#cb334-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> print3<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-7"><a href="#cb334-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-8"><a href="#cb334-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> debug1(lvl<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-9"><a href="#cb334-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> debug2(lvl<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;_</span> <span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-10"><a href="#cb334-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> debug3<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(lvl<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span> s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb334-11"><a href="#cb334-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-12"><a href="#cb334-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> substr1(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> util<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-13"><a href="#cb334-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> substr2<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(s<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">,</span> util<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-14"><a href="#cb334-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-15"><a href="#cb334-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_mut1(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">dyn</span> T<span class="op">;</span></span>
<span id="cb334-16"><a href="#cb334-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_mut2<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">dyn</span> T<span class="op">;</span></span>
<span id="cb334-17"><a href="#cb334-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-18"><a href="#cb334-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> args1<span class="op">&lt;</span>T<span class="op">:</span> ToCStr<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> args<span class="op">:</span> <span class="op">&amp;</span>[T]) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="kw">mut</span> Command<span class="op">;</span></span>
<span id="cb334-19"><a href="#cb334-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> args2<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">,</span> T<span class="op">:</span> ToCStr<span class="op">&gt;</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> args<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;b</span> [T]) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> Command<span class="op">;</span></span>
<span id="cb334-20"><a href="#cb334-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-21"><a href="#cb334-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new1(buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> Thing<span class="op">;</span></span>
<span id="cb334-22"><a href="#cb334-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new2(buf<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> Thing<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;;</span></span>
<span id="cb334-23"><a href="#cb334-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new3<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(buf<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">mut</span> [<span class="dt">u8</span>]) <span class="op">-&gt;</span> Thing<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;;</span></span>
<span id="cb334-24"><a href="#cb334-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-25"><a href="#cb334-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> FunPtr1 <span class="op">=</span> <span class="kw">fn</span>(<span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-26"><a href="#cb334-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> FunPtr2 <span class="op">=</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="kw">fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-27"><a href="#cb334-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-28"><a href="#cb334-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> FunTrait1 <span class="op">=</span> <span class="kw">dyn</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-29"><a href="#cb334-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> FunTrait2 <span class="op">=</span> <span class="kw">dyn</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">;</span></span>
<span id="cb334-30"><a href="#cb334-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-31"><a href="#cb334-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RESOLVED_SINGLE1<span class="op">:</span> <span class="kw">fn</span>(<span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span> x<span class="op">;</span></span>
<span id="cb334-32"><a href="#cb334-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RESOLVED_SINGLE2<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="kw">fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">=</span> <span class="op">|</span>x<span class="op">|</span> x<span class="op">;</span></span>
<span id="cb334-33"><a href="#cb334-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb334-34"><a href="#cb334-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RESOLVED_MULTIPLE1<span class="op">:</span> <span class="op">&amp;</span><span class="kw">dyn</span> <span class="bu">Fn</span>(<span class="op">&amp;</span>Foo<span class="op">,</span> <span class="op">&amp;</span>Bar<span class="op">,</span> <span class="op">&amp;</span>Baz) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">=</span> <span class="op">&amp;</span>some_func<span class="op">;</span></span>
<span id="cb334-35"><a href="#cb334-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> RESOLVED_MULTIPLE2<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">,</span> <span class="ot">&#39;c</span><span class="op">&gt;</span> <span class="op">&amp;</span><span class="kw">dyn</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> Foo<span class="op">,</span> <span class="op">&amp;</span><span class="ot">&#39;b</span> Bar<span class="op">,</span> <span class="op">&amp;</span><span class="ot">&#39;c</span> Baz) <span class="op">-&gt;</span> <span class="dt">usize</span> <span class="op">=</span> <span class="op">&amp;</span>some_func<span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>The following examples are illegal where is not allowed to elide the
lifetime parameter:</li>
</ol>
<div class="sourceCode" id="cb335"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cannot infer, because there are no parameters to infer from.</span></span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_str() <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">;</span></span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb335-4"><a href="#cb335-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Cannot infer, ambiguous if it is borrowed from the first or second parameter.</span></span>
<span id="cb335-5"><a href="#cb335-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> frob(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> t<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">;</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Default trait object lifetimes.</li>
</ol>
<div class="sourceCode" id="cb336"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For the following trait...</span></span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Foo <span class="op">{}</span></span>
<span id="cb336-3"><a href="#cb336-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-4"><a href="#cb336-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T1 <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> Foo<span class="op">&gt;;</span></span>
<span id="cb336-5"><a href="#cb336-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T2 <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> Foo <span class="op">+</span> <span class="ot">&#39;static</span><span class="op">&gt;;</span></span>
<span id="cb336-6"><a href="#cb336-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-7"><a href="#cb336-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> <span class="kw">dyn</span> Foo <span class="op">{}</span></span>
<span id="cb336-8"><a href="#cb336-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> <span class="kw">dyn</span> Foo <span class="op">+</span> <span class="ot">&#39;static</span> <span class="op">{}</span></span>
<span id="cb336-9"><a href="#cb336-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-10"><a href="#cb336-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T3<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="kw">dyn</span> Foo<span class="op">;</span></span>
<span id="cb336-11"><a href="#cb336-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T4<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> (<span class="kw">dyn</span> Foo <span class="op">+</span> <span class="ot">&#39;a</span>)<span class="op">;</span></span>
<span id="cb336-12"><a href="#cb336-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-13"><a href="#cb336-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T5<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">std::cell::</span>Ref<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="kw">dyn</span> Foo<span class="op">&gt;;</span></span>
<span id="cb336-14"><a href="#cb336-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T6<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">std::cell::</span>Ref<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="kw">dyn</span> Foo <span class="op">+</span> <span class="ot">&#39;a</span><span class="op">&gt;;</span></span>
<span id="cb336-15"><a href="#cb336-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-16"><a href="#cb336-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-17"><a href="#cb336-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">trait</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;:</span> <span class="ot">&#39;a</span> <span class="op">{}</span></span>
<span id="cb336-18"><a href="#cb336-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-19"><a href="#cb336-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T7<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;&gt;;</span></span>
<span id="cb336-20"><a href="#cb336-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> T8<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;a</span><span class="op">&gt;;</span></span>
<span id="cb336-21"><a href="#cb336-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb336-22"><a href="#cb336-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="kw">dyn</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{}</span></span>
<span id="cb336-23"><a href="#cb336-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="kw">dyn</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ot">&#39;a</span> <span class="op">{}</span></span></code></pre></div>
<p><br />
</p>
<ol start="7" type="1">
<li><code>Bar&lt;'a&gt;</code> (No Lifetime Bound):
<ul>
<li>This means the trait <code>Bar</code> is parameterized by the
lifetime <code>'a</code>, but there is no restriction on how the
lifetime <code>'a</code> relates to the implementing type‚Äôs
lifetime.</li>
<li>The <code>'a</code> lifetime is simply used for any references that
might be returned by the methods of the trait.
<code>Bar&lt;'a&gt;</code>: <code>'a</code> (Lifetime Bound):</li>
<li>This adds a lifetime bound to the trait, meaning that any type
implementing <code>Bar&lt;'a&gt;</code> must live at least as long as
the lifetime <code>'a</code>.</li>
<li>This constraint ensures that the implementing type is valid for the
entire <code>'a</code> lifetime and that no part of the implementation
can outlive <code>'a</code>.</li>
</ul>
<div class="sourceCode" id="cb337"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;:</span> <span class="ot">&#39;a</span> <span class="op">{</span></span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_data(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">;</span></span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-5"><a href="#cb337-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyStruct<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb337-6"><a href="#cb337-6" aria-hidden="true" tabindex="-1"></a>    data<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span><span class="op">;</span></span>
<span id="cb337-7"><a href="#cb337-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb337-8"><a href="#cb337-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-9"><a href="#cb337-9" aria-hidden="true" tabindex="-1"></a><span class="co">// OK, MyStruct&lt;&#39;a&gt; lives at least as long as &#39;a</span></span>
<span id="cb337-10"><a href="#cb337-10" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="cf">for</span> MyStruct<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb337-11"><a href="#cb337-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_data(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb337-12"><a href="#cb337-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data</span>
<span id="cb337-13"><a href="#cb337-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb337-14"><a href="#cb337-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb337-15"><a href="#cb337-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-16"><a href="#cb337-16" aria-hidden="true" tabindex="-1"></a><span class="co">// ERR, &#39;b might be shorter than &#39;a</span></span>
<span id="cb337-17"><a href="#cb337-17" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">&gt;</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="cf">for</span> MyStruct<span class="op">&lt;</span><span class="ot">&#39;b</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb337-18"><a href="#cb337-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_data(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb337-19"><a href="#cb337-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data</span>
<span id="cb337-20"><a href="#cb337-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb337-21"><a href="#cb337-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb337-22"><a href="#cb337-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-23"><a href="#cb337-23" aria-hidden="true" tabindex="-1"></a><span class="co">// OK, &#39;b is longer than &#39;a</span></span>
<span id="cb337-24"><a href="#cb337-24" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> <span class="ot">&#39;b</span><span class="op">&gt;</span> Bar<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="cf">for</span> MyStruct<span class="op">&lt;</span><span class="ot">&#39;b</span><span class="op">&gt;</span></span>
<span id="cb337-25"><a href="#cb337-25" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb337-26"><a href="#cb337-26" aria-hidden="true" tabindex="-1"></a>    <span class="ot">&#39;b</span><span class="op">:</span> <span class="ot">&#39;a</span></span>
<span id="cb337-27"><a href="#cb337-27" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb337-28"><a href="#cb337-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_data(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span> <span class="op">{</span></span>
<span id="cb337-29"><a href="#cb337-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>data</span>
<span id="cb337-30"><a href="#cb337-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb337-31"><a href="#cb337-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<hr/>
<h1
id="fora-higher-ranked-trait-bounds-hrtbs"><code>for&lt;'a&gt;</code>
Higher-Ranked Trait Bounds (HRTBs)</h1>
<ol type="1">
<li>It allows you to define <code>trait</code> implementations that must
hold for all lifetimes, rather than for a specific lifetime
<code>'a</code>.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>In Rust, when you write a generic trait or function, lifetimes are
usually specific. For example:</li>
</ol>
<div class="sourceCode" id="cb338"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> foo<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span>(x<span class="op">:</span> <span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>) <span class="op">{}</span></span></code></pre></div>
<ul>
<li>Here, <code>'a</code> represents a specific lifetime tied to a
concrete scope at runtime, which the compiler determines when you use
the function.</li>
<li>However, sometimes you want to say: ‚Äúthis function or trait should
work for any possible lifetime.‚Äù This is where higher-ranked trait
bounds (HRTBs) come in. They allow you to say that the trait or function
works for all lifetimes, not just one specific lifetime. The syntax to
express this is <code>for&lt;'a&gt;</code>.</li>
</ul>
<div class="sourceCode" id="cb339"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> foo<span class="op">&lt;</span>F<span class="op">&gt;</span>(f<span class="op">:</span> F)</span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a>        F<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Here, <code>for&lt;'a&gt; Fn(&amp;'a str)</code> means the function
<strong><em>f</em></strong> should work for any lifetime
<code>'a</code>.</li>
</ul>
<p><br />
</p>
<ol start="3" type="1">
<li>To explain the need for HRTBs, consider the following case. Imagine
you want to write a function that takes a closure, and this closure can
accept references with any lifetime.</li>
</ol>
<div class="sourceCode" id="cb340"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> call_with_ref<span class="op">&lt;</span>F<span class="op">&gt;</span>(f<span class="op">:</span> F)</span>
<span id="cb340-2"><a href="#cb340-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb340-3"><a href="#cb340-3" aria-hidden="true" tabindex="-1"></a>        F<span class="op">:</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">&#39;static</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb340-4"><a href="#cb340-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb340-5"><a href="#cb340-5" aria-hidden="true" tabindex="-1"></a>        f(<span class="st">&quot;Hello, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb340-6"><a href="#cb340-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>In this example, the closure f is constrained to work only with
<code>'static</code> references.</li>
<li>But what if you want the closure to work with references that have
any lifetime, not just <code>'static</code>?</li>
</ul>
<div class="sourceCode" id="cb341"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> call_with_ref<span class="op">&lt;</span>F<span class="op">&gt;</span>(f<span class="op">:</span> F)</span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb341-3"><a href="#cb341-3" aria-hidden="true" tabindex="-1"></a>        F<span class="op">:</span> <span class="cf">for</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span> <span class="bu">Fn</span>(<span class="op">&amp;</span><span class="ot">&#39;a</span> <span class="dt">str</span>)<span class="op">,</span></span>
<span id="cb341-4"><a href="#cb341-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb341-5"><a href="#cb341-5" aria-hidden="true" tabindex="-1"></a>        f(<span class="st">&quot;Hello, World!&quot;</span>)<span class="op">;</span></span>
<span id="cb341-6"><a href="#cb341-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Now, the closure <strong><em>f</em></strong> can accept references
with any lifetime,<br />
and the compiler ensures that <strong><em>f</em></strong> works for all
possible lifetimes <code>'a</code>.</li>
</ul>
<hr/>
<h1 id="names">Names</h1>
<ol type="1">
<li>A <strong>prelude</strong> is a collection of names that are
automatically brought into scope of every module in a crate.<br />
It‚Äôs a convention name, you can also name differently.</li>
</ol>
<div class="sourceCode" id="cb342"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> prelude <span class="op">{</span></span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::types::</span><span class="op">{</span>TypeA<span class="op">,</span> TypeB<span class="op">};</span> <span class="co">// Re-export commonly used types</span></span>
<span id="cb342-3"><a href="#cb342-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::traits::</span>MyTrait<span class="op">;</span>       <span class="co">// Re-export a commonly used trait</span></span>
<span id="cb342-4"><a href="#cb342-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb342-5"><a href="#cb342-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-6"><a href="#cb342-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> types <span class="op">{</span></span>
<span id="cb342-7"><a href="#cb342-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> TypeA<span class="op">;</span></span>
<span id="cb342-8"><a href="#cb342-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">struct</span> TypeB<span class="op">;</span></span>
<span id="cb342-9"><a href="#cb342-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb342-10"><a href="#cb342-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-11"><a href="#cb342-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">mod</span> traits <span class="op">{</span></span>
<span id="cb342-12"><a href="#cb342-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pub</span> <span class="kw">trait</span> MyTrait <span class="op">{</span></span>
<span id="cb342-13"><a href="#cb342-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> do_something(<span class="op">&amp;</span><span class="kw">self</span>)<span class="op">;</span></span>
<span id="cb342-14"><a href="#cb342-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb342-15"><a href="#cb342-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb342-16"><a href="#cb342-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-17"><a href="#cb342-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// In the main part of your code:</span></span>
<span id="cb342-18"><a href="#cb342-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">crate</span><span class="pp">::prelude::</span><span class="op">*;</span> <span class="co">// Import all items from the &quot;prelude&quot; module</span></span>
<span id="cb342-19"><a href="#cb342-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-20"><a href="#cb342-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb342-21"><a href="#cb342-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> _a <span class="op">=</span> <span class="pp">types::</span>TypeA<span class="op">;</span></span>
<span id="cb342-22"><a href="#cb342-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> _b <span class="op">=</span> <span class="pp">types::</span>TypeB<span class="op">;</span></span>
<span id="cb342-23"><a href="#cb342-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h1 id="macros-2">Macros</h1>
<h2 id="declarative-macros-1">Declarative Macros</h2>
<ol type="1">
<li>Basic Declarative Macro Syntax.</li>
</ol>
<div class="sourceCode" id="cb343"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> my_macro <span class="op">{</span></span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a>        () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-3"><a href="#cb343-3" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern for no argument.&quot;</span>)<span class="op">;</span></span>
<span id="cb343-4"><a href="#cb343-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-5"><a href="#cb343-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-6"><a href="#cb343-6" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>val<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-7"><a href="#cb343-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern with one expression.&quot;</span>)<span class="op">;</span></span>
<span id="cb343-8"><a href="#cb343-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-9"><a href="#cb343-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-10"><a href="#cb343-10" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>(<span class="op">$</span>x<span class="op">:</span>expr)<span class="op">,*</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-11"><a href="#cb343-11" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;Pattern for multiple values.&quot;</span>)<span class="op">;</span></span>
<span id="cb343-12"><a href="#cb343-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>(</span>
<span id="cb343-13"><a href="#cb343-13" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;Value: {}&quot;</span><span class="op">,</span> <span class="op">$</span>x)<span class="op">;</span></span>
<span id="cb343-14"><a href="#cb343-14" aria-hidden="true" tabindex="-1"></a>            )<span class="op">*</span></span>
<span id="cb343-15"><a href="#cb343-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-16"><a href="#cb343-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-17"><a href="#cb343-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-18"><a href="#cb343-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add <span class="op">{</span></span>
<span id="cb343-19"><a href="#cb343-19" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>b<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-20"><a href="#cb343-20" aria-hidden="true" tabindex="-1"></a>            ((<span class="op">$</span>a) <span class="op">+</span> (<span class="op">$</span>b))</span>
<span id="cb343-21"><a href="#cb343-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-22"><a href="#cb343-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-23"><a href="#cb343-23" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-24"><a href="#cb343-24" aria-hidden="true" tabindex="-1"></a>            ((<span class="op">$</span>a) <span class="op">+</span> (<span class="dv">1</span>))</span>
<span id="cb343-25"><a href="#cb343-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-26"><a href="#cb343-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-27"><a href="#cb343-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-28"><a href="#cb343-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add_as <span class="op">{</span></span>
<span id="cb343-29"><a href="#cb343-29" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>b<span class="op">:</span>expr<span class="op">,</span> <span class="op">$</span>c<span class="op">:</span>ty) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-30"><a href="#cb343-30" aria-hidden="true" tabindex="-1"></a>            ( ((<span class="op">$</span>a) <span class="kw">as</span> (<span class="op">$</span>c)) <span class="op">+</span> ((<span class="op">$</span>b) <span class="kw">as</span> (<span class="op">$</span>c)) )</span>
<span id="cb343-31"><a href="#cb343-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb343-32"><a href="#cb343-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-33"><a href="#cb343-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-34"><a href="#cb343-34" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> add_all <span class="op">{</span></span>
<span id="cb343-35"><a href="#cb343-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>(<span class="op">$</span>a<span class="op">:</span>expr)<span class="op">,*</span> <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-36"><a href="#cb343-36" aria-hidden="true" tabindex="-1"></a>            <span class="co">// to handle the case without any arguments.</span></span>
<span id="cb343-37"><a href="#cb343-37" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span></span>
<span id="cb343-38"><a href="#cb343-38" aria-hidden="true" tabindex="-1"></a>            <span class="co">// block to be repeated.</span></span>
<span id="cb343-39"><a href="#cb343-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">$</span>(<span class="op">+</span> (<span class="op">$</span>a))<span class="op">*</span></span>
<span id="cb343-40"><a href="#cb343-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb343-41"><a href="#cb343-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-42"><a href="#cb343-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-43"><a href="#cb343-43" aria-hidden="true" tabindex="-1"></a>    <span class="pp">macro_rules!</span> ok_or_return <span class="op">{</span></span>
<span id="cb343-44"><a href="#cb343-44" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>a<span class="op">:</span>ident(<span class="op">$</span>(<span class="op">$</span>b<span class="op">:</span>tt)<span class="op">*</span>)) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-45"><a href="#cb343-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="op">$</span>a(<span class="op">$</span>(<span class="op">$</span>b)<span class="op">*</span>) <span class="op">{</span></span>
<span id="cb343-46"><a href="#cb343-46" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Ok</span>(value) <span class="op">=&gt;</span> value<span class="op">,</span></span>
<span id="cb343-47"><a href="#cb343-47" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Err</span>(e) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb343-48"><a href="#cb343-48" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="cn">Err</span>(e)<span class="op">;</span></span>
<span id="cb343-49"><a href="#cb343-49" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb343-50"><a href="#cb343-50" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb343-51"><a href="#cb343-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb343-52"><a href="#cb343-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-53"><a href="#cb343-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-54"><a href="#cb343-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb343-55"><a href="#cb343-55" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb343-56"><a href="#cb343-56" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">add!</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb343-57"><a href="#cb343-57" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="pp">add!</span>(<span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb343-58"><a href="#cb343-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-59"><a href="#cb343-59" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">add_as!</span>(<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dt">u8</span>))<span class="op">;</span></span>
<span id="cb343-60"><a href="#cb343-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-61"><a href="#cb343-61" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">add_all!</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb343-62"><a href="#cb343-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-63"><a href="#cb343-63" aria-hidden="true" tabindex="-1"></a>        <span class="pp">ok_or_return!</span>(some_work(<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span>))<span class="op">;</span></span>
<span id="cb343-64"><a href="#cb343-64" aria-hidden="true" tabindex="-1"></a>        <span class="pp">ok_or_return!</span>(some_work(<span class="dv">20</span><span class="op">,</span> <span class="dv">10</span>))<span class="op">;</span></span>
<span id="cb343-65"><a href="#cb343-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-66"><a href="#cb343-66" aria-hidden="true" tabindex="-1"></a>        <span class="cn">Ok</span>(())</span>
<span id="cb343-67"><a href="#cb343-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb343-68"><a href="#cb343-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb343-69"><a href="#cb343-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> some_work(i<span class="op">:</span> <span class="dt">i64</span><span class="op">,</span> j<span class="op">:</span> <span class="dt">i64</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>(<span class="dt">i64</span><span class="op">,</span> <span class="dt">i64</span>)<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb343-70"><a href="#cb343-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> j <span class="op">{</span></span>
<span id="cb343-71"><a href="#cb343-71" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Ok</span>( (i<span class="op">,</span>j) )</span>
<span id="cb343-72"><a href="#cb343-72" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb343-73"><a href="#cb343-73" aria-hidden="true" tabindex="-1"></a>            <span class="cn">Err</span>(<span class="st">&quot;ERROR&quot;</span><span class="op">.</span>to_owned())</span>
<span id="cb343-74"><a href="#cb343-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb343-75"><a href="#cb343-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="2" type="1">
<li>The declarative macros are declared using
<code>macro_rules!</code>.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li><p>Each branch can take multiple arguments, starting with the
<code>$</code> sign and followed by a <code>token type</code>:</p>
<ul>
<li><strong>item</strong> an item, like a function, struct, module,
etc.</li>
<li><strong>block</strong> a block of statements, expression, surrounded
by braces.</li>
<li><strong>stmt</strong> a statement.</li>
<li><strong>pat</strong> a pattern.</li>
<li><strong>expr</strong> an expression.</li>
<li><strong>ty</strong> a type.</li>
<li><strong>ident</strong> an identifier.</li>
<li><strong>path</strong> a path, like <code>foo</code>,
<code>::std::mem::replace</code>,
<code>transmute::&lt;_, int&gt;</code>, ‚Ä¶</li>
<li><strong>meta</strong> a meta item, the things that go inside
<code>#[...]</code> and <code>#![...]</code> attributes.</li>
<li><strong>tt</strong> a single token tree.</li>
<li><strong>vis</strong> a possibly empty visibility qualifier, like
<code>pub</code>.</li>
</ul></li>
</ol>
<p><br />
</p>
<ol start="4" type="1">
<li>The token type that repeats is enclosed in <code>$()</code>,
followed by a separator and a <code>*</code> or a <code>+</code>,
indicating the number of times the token will repeat. The separator is
used to distinguish the tokens from each other. The <code>$()</code>
block followed by <code>*</code> or <code>+</code> is used to indicate
the repeating block of code. <code>*</code> means 0 or more,
<code>+</code> means one or more, <code>?</code> for zero or one.</li>
</ol>
<hr/>
<h3 id="basic-async-and-await">Basic <code>async</code> and
<code>await</code></h3>
<ol type="1">
<li>In Rust, <strong><code>async</code></strong> and
<strong><code>await</code></strong> are used to write asynchronous code
in a more readable and efficient way.<br />
Asynchronous programming allows your code to perform tasks without
blocking the main thread while waiting for operations like I/O (network
calls, file reads/writes) to complete.<br />
This is especially useful when you have tasks that can run
concurrently.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>When you declare a function as <strong><code>async</code></strong>
in Rust,<br />
it allows that fn to return a <strong><code>future</code></strong>
instead of blocking while waiting for the function‚Äôs result.<br />
A <strong><code>future</code></strong> is a value that represents a
value that might be available at some point in the future.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>A function marked with <strong><code>async</code></strong> does NOT
run to completion when called,<br />
instead, it returns a <strong><code>future</code></strong> that needs to
be executed by an <strong><code>executor</code></strong>.</li>
</ol>
<div class="sourceCode" id="cb344"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> fetch_data() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Data fetched!&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="4" type="1">
<li><strong><code>await</code></strong> is used to wait for a
<strong><code>future</code></strong> to complete and get its
result.<br />
When you use <strong><code>await</code></strong>, it pauses the current
function,<br />
and the fn temporarily yields control (i.e., it does not block the
current thread)<br />
and waits for the asynchronous operation to complete.<br />
Once it‚Äôs done, the code resumes.</li>
</ol>
<div class="sourceCode" id="cb345"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> process_data() <span class="op">{</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> fetch_data()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb345-5"><a href="#cb345-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="5" type="1">
<li>Example: Simple Asynchronous Functions.</li>
</ol>
<div class="sourceCode" id="cb346"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> fetch_data() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Data fetched!&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-5"><a href="#cb346-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> process_data() <span class="op">{</span></span>
<span id="cb346-6"><a href="#cb346-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> result <span class="op">=</span> fetch_data()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb346-7"><a href="#cb346-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> result)<span class="op">;</span></span>
<span id="cb346-8"><a href="#cb346-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb346-9"><a href="#cb346-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-10"><a href="#cb346-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Entry point for asynchronous code (requires an executor)</span></span>
<span id="cb346-11"><a href="#cb346-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Or #[async_std::main] if using async-std</span></span>
<span id="cb346-12"><a href="#cb346-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span><span class="pp">tokio::</span>main<span class="at">]</span></span>
<span id="cb346-13"><a href="#cb346-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb346-14"><a href="#cb346-14" aria-hidden="true" tabindex="-1"></a>        process_data()<span class="op">.</span><span class="kw">await</span><span class="op">;</span></span>
<span id="cb346-15"><a href="#cb346-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><br />
</p>
<ol start="6" type="1">
<li>Example : Simple Executor.</li>
</ol>
<div class="sourceCode" id="cb347"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::future::</span><span class="bu">Future</span><span class="op">;</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::pin::</span>Pin<span class="op">;</span></span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::task::</span><span class="op">{</span>Context<span class="op">,</span> Poll<span class="op">,</span> Waker<span class="op">};</span></span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::collections::</span>VecDeque<span class="op">;</span></span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">futures::task::</span>noop_waker<span class="op">;</span></span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Task <span class="op">{</span></span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true" tabindex="-1"></a>        future<span class="op">:</span> Pin<span class="op">&lt;</span><span class="dt">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="bu">Future</span><span class="op">&lt;</span>Output<span class="op">=</span>()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span><span class="op">&gt;&gt;,</span></span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb347-10"><a href="#cb347-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-11"><a href="#cb347-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Executor <span class="op">{</span></span>
<span id="cb347-12"><a href="#cb347-12" aria-hidden="true" tabindex="-1"></a>        tasks<span class="op">:</span> VecDeque<span class="op">&lt;</span>Task<span class="op">&gt;;</span></span>
<span id="cb347-13"><a href="#cb347-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb347-14"><a href="#cb347-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-15"><a href="#cb347-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb347-16"><a href="#cb347-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> executor <span class="op">=</span> <span class="pp">Executor::</span>new()<span class="op">;</span></span>
<span id="cb347-17"><a href="#cb347-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-18"><a href="#cb347-18" aria-hidden="true" tabindex="-1"></a>        executor<span class="op">.</span>spawn(<span class="pp">Task::</span>new(simple_task(<span class="dv">1</span>)))<span class="op">;</span></span>
<span id="cb347-19"><a href="#cb347-19" aria-hidden="true" tabindex="-1"></a>        executor<span class="op">.</span>spawn(<span class="pp">Task::</span>new(simple_task(<span class="dv">2</span>)))<span class="op">;</span></span>
<span id="cb347-20"><a href="#cb347-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-21"><a href="#cb347-21" aria-hidden="true" tabindex="-1"></a>        executor<span class="op">.</span>run()<span class="op">;</span></span>
<span id="cb347-22"><a href="#cb347-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb347-23"><a href="#cb347-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-24"><a href="#cb347-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">async</span> <span class="kw">fn</span> simple_task(id<span class="op">:</span> <span class="dt">u32</span>) <span class="op">{</span></span>
<span id="cb347-25"><a href="#cb347-25" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Task {} started...&quot;</span><span class="op">,</span> id)<span class="op">;</span></span>
<span id="cb347-26"><a href="#cb347-26" aria-hidden="true" tabindex="-1"></a>        <span class="pp">std::thread::</span>sleep(<span class="pp">std::time::Duration::</span>from_secs(<span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb347-27"><a href="#cb347-27" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Task {} completed...&quot;</span><span class="op">,</span> id)<span class="op">;</span></span>
<span id="cb347-28"><a href="#cb347-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb347-29"><a href="#cb347-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-30"><a href="#cb347-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Task <span class="op">{</span></span>
<span id="cb347-31"><a href="#cb347-31" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> new(future<span class="op">:</span> <span class="kw">impl</span> <span class="bu">Future</span><span class="op">&lt;</span>Output<span class="op">=</span>()<span class="op">&gt;</span> <span class="op">+</span> <span class="bu">Send</span> <span class="op">+</span> <span class="ot">&#39;static</span>) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb347-32"><a href="#cb347-32" aria-hidden="true" tabindex="-1"></a>            Task <span class="op">{</span></span>
<span id="cb347-33"><a href="#cb347-33" aria-hidden="true" tabindex="-1"></a>                future<span class="op">:</span> <span class="dt">Box</span><span class="pp">::</span>pin(future)<span class="op">,</span></span>
<span id="cb347-34"><a href="#cb347-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb347-35"><a href="#cb347-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-36"><a href="#cb347-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-37"><a href="#cb347-37" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> poll(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> cx<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Context) <span class="op">-&gt;</span> Poll<span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb347-38"><a href="#cb347-38" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>future<span class="op">.</span>as_mut()<span class="op">.</span>poll(cx)</span>
<span id="cb347-39"><a href="#cb347-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-40"><a href="#cb347-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb347-41"><a href="#cb347-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-42"><a href="#cb347-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> Executor <span class="op">{</span></span>
<span id="cb347-43"><a href="#cb347-43" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> new() <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb347-44"><a href="#cb347-44" aria-hidden="true" tabindex="-1"></a>            Executor <span class="op">{</span></span>
<span id="cb347-45"><a href="#cb347-45" aria-hidden="true" tabindex="-1"></a>                tasks<span class="op">:</span> <span class="pp">VecDeque::</span>new()<span class="op">,</span></span>
<span id="cb347-46"><a href="#cb347-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb347-47"><a href="#cb347-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-48"><a href="#cb347-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-49"><a href="#cb347-49" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> spawn(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span><span class="op">,</span> task<span class="op">:</span> Task) <span class="op">{</span></span>
<span id="cb347-50"><a href="#cb347-50" aria-hidden="true" tabindex="-1"></a>            <span class="kw">self</span><span class="op">.</span>tasks<span class="op">.</span>push_back(task)<span class="op">;</span></span>
<span id="cb347-51"><a href="#cb347-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-52"><a href="#cb347-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-53"><a href="#cb347-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> run(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb347-54"><a href="#cb347-54" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> waker <span class="op">=</span> noop_waker()<span class="op">;</span></span>
<span id="cb347-55"><a href="#cb347-55" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> <span class="kw">mut</span> cx <span class="op">=</span> <span class="pp">Context::</span>from_waker(<span class="op">&amp;</span>waker)<span class="op">;</span></span>
<span id="cb347-56"><a href="#cb347-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-57"><a href="#cb347-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="kw">let</span> <span class="cn">Some</span>(<span class="kw">mut</span> task) <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>tasks<span class="op">.</span>pop_front() <span class="op">{</span></span>
<span id="cb347-58"><a href="#cb347-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> task<span class="op">.</span>poll(<span class="op">&amp;</span><span class="kw">mut</span> cx)<span class="op">.</span>is_pending() <span class="op">{</span></span>
<span id="cb347-59"><a href="#cb347-59" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">self</span><span class="op">.</span>tasks<span class="op">.</span>push_back(task)<span class="op">;</span></span>
<span id="cb347-60"><a href="#cb347-60" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb347-61"><a href="#cb347-61" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb347-62"><a href="#cb347-62" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb347-63"><a href="#cb347-63" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<hr/>
<h3 id="pinning">Pinning</h3>
<ol type="1">
<li>In Rust, <strong><code>Box::pin()</code></strong> is used to create
a pinned heap-allocated value.<br />
The concept of pinning is important when dealing with types that should
NOT be moved in memory after they are created,<br />
typically when working with asynchronous programming or self-referential
types.</li>
</ol>
<p><br />
</p>
<ol start="2" type="1">
<li>In Rust, most values are free to move around in memory.<br />
For example, if you pass a value to a function or return it from one,
Rust might move it to a new memory location.</li>
</ol>
<p><br />
</p>
<ol start="3" type="1">
<li>Considering the following example:</li>
</ol>
<div class="sourceCode" id="cb348"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> tracker <span class="op">=</span> AddressTracker(<span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true" tabindex="-1"></a>        tracker<span class="op">.</span>check_address()<span class="op">;</span></span>
<span id="cb348-4"><a href="#cb348-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> tracker <span class="op">=</span> tracker<span class="op">;</span></span>
<span id="cb348-5"><a href="#cb348-5" aria-hidden="true" tabindex="-1"></a>        tracker<span class="op">.</span>check_address()<span class="op">;</span></span>
<span id="cb348-6"><a href="#cb348-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb348-7"><a href="#cb348-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb348-8"><a href="#cb348-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AddressTracker(<span class="dt">Option</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb348-9"><a href="#cb348-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb348-10"><a href="#cb348-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> AddressTracker <span class="op">{</span></span>
<span id="cb348-11"><a href="#cb348-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> check_address(<span class="op">&amp;</span><span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span></span>
<span id="cb348-12"><a href="#cb348-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> current_address <span class="op">=</span> <span class="kw">self</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">Self</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb348-13"><a href="#cb348-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">{</span></span>
<span id="cb348-14"><a href="#cb348-14" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(previous_address) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb348-15"><a href="#cb348-15" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;prev: {}&quot;</span><span class="op">,</span> previous_address)<span class="op">;</span></span>
<span id="cb348-16"><a href="#cb348-16" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;curr: {}&quot;</span><span class="op">,</span> current_address)<span class="op">;</span></span>
<span id="cb348-17"><a href="#cb348-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb348-18"><a href="#cb348-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb348-19"><a href="#cb348-19" aria-hidden="true" tabindex="-1"></a>                <span class="cn">None</span> <span class="op">=&gt;</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">=</span> <span class="cn">Some</span>(current_address)<span class="op">,</span></span>
<span id="cb348-20"><a href="#cb348-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb348-21"><a href="#cb348-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb348-22"><a href="#cb348-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Possible output:
<ul>
<li>prev: <code>6098595616</code></li>
<li>curr: <code>6098595648</code></li>
</ul></li>
</ul>
<p><br />
</p>
<ol start="4" type="1">
<li>How to solve it?</li>
</ol>
<div class="sourceCode" id="cb349"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> tracker <span class="op">=</span> AddressTracker(<span class="cn">None</span>)<span class="op">;</span></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> pinned_tracker <span class="op">=</span> <span class="pp">pin!</span>(tracker)<span class="op">;</span></span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a>        pinned_tracker<span class="op">.</span>as_mut()<span class="op">.</span>check_address()<span class="op">;</span></span>
<span id="cb349-5"><a href="#cb349-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> pinned_tracker <span class="op">=</span> pinned_tracker<span class="op">;</span></span>
<span id="cb349-6"><a href="#cb349-6" aria-hidden="true" tabindex="-1"></a>        pinned_tracker<span class="op">.</span>as_mut()<span class="op">.</span>check_address()<span class="op">;</span></span>
<span id="cb349-7"><a href="#cb349-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb349-8"><a href="#cb349-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-9"><a href="#cb349-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> AddressTracker(<span class="dt">Option</span><span class="op">&lt;</span><span class="dt">usize</span><span class="op">&gt;</span>)<span class="op">;</span></span>
<span id="cb349-10"><a href="#cb349-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-11"><a href="#cb349-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">impl</span> AddressTracker <span class="op">{</span></span>
<span id="cb349-12"><a href="#cb349-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">fn</span> check_address(<span class="kw">mut</span> <span class="kw">self</span><span class="op">:</span> Pin<span class="op">&lt;&amp;</span><span class="kw">mut</span> <span class="dt">Self</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb349-13"><a href="#cb349-13" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> current_address <span class="op">=</span> <span class="op">&amp;*</span><span class="kw">self</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">Self</span> <span class="kw">as</span> <span class="dt">usize</span><span class="op">;</span></span>
<span id="cb349-14"><a href="#cb349-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">match</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">{</span></span>
<span id="cb349-15"><a href="#cb349-15" aria-hidden="true" tabindex="-1"></a>                <span class="cn">Some</span>(previous_address) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb349-16"><a href="#cb349-16" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;prev: {}&quot;</span><span class="op">,</span> previous_address)<span class="op">;</span></span>
<span id="cb349-17"><a href="#cb349-17" aria-hidden="true" tabindex="-1"></a>                    <span class="pp">println!</span>(<span class="st">&quot;curr: {}&quot;</span><span class="op">,</span> current_address)<span class="op">;</span></span>
<span id="cb349-18"><a href="#cb349-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">},</span></span>
<span id="cb349-19"><a href="#cb349-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb349-20"><a href="#cb349-20" aria-hidden="true" tabindex="-1"></a>                <span class="cn">None</span> <span class="op">=&gt;</span> <span class="kw">self</span><span class="op">.</span><span class="dv">0</span> <span class="op">=</span> <span class="cn">Some</span>(current_address)<span class="op">,</span></span>
<span id="cb349-21"><a href="#cb349-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb349-22"><a href="#cb349-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb349-23"><a href="#cb349-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<ul>
<li>Possible output:
<ul>
<li>prev: <code>6098595616</code></li>
<li>curr: <code>6098595616</code></li>
</ul></li>
</ul>
